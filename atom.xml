<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  
  <subtitle>屈定&#39;s Blog - change from today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrdear.cn/"/>
  <updated>2018-01-01T14:14:30.000Z</updated>
  <id>http://mrdear.cn/</id>
  
  <author>
    <name>Qu Ding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年上半年目标</title>
    <link href="http://mrdear.cn/2018/01/01/%E9%9A%8F%E8%B0%88/2018%E5%B9%B4%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9B%AE%E6%A0%87/"/>
    <id>http://mrdear.cn/2018/01/01/随谈/2018年上半年目标/</id>
    <published>2018-01-01T14:14:28.000Z</published>
    <updated>2018-01-01T14:14:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年已经过去,在2018年第一天花了一下午时间把博客的主题换了下,新的一年新的开始,当然也要有新的皮肤主题啦.</p><hr><h3 id="2017年总结"><a href="#2017年总结" class="headerlink" title="2017年总结"></a>2017年总结</h3><p>2017年离开了校园,正式走向社会.半年的工作经验没感觉给自己带来过什么,反而带来了更多的急躁与迷茫.曾经我认为自己最大的优点就是自我认知度很高,每一个时期都能清楚的知道自己在这个阶段该做什么不该做什么,达到目标后下一步该做什么,然而工作半年后我却不知道自己该做什么了,我在想这个是为什么?<br>思来想去我才发现除了半年的工作磨灭了我刚入职时的上进心,这其中有一个缘由是我作为商业开发,面对的是频繁的需求变动以及面对bug时快速响应,毕竟关乎钱的事情,写代码都不自觉地手抖几下.还有就是作为一线城市的外乡奋斗者看不到希望,房价太高,工资涨得又太慢,每天上班挤地铁都面无表情的望着外面的广告,下车,进公司,开始一天的迭代,下班回家,到家已是8点多.都说工作是为了生活,然而这样我觉得自己是被动生活.<br>说是总结,结果几乎变成了自己压抑情绪的发泄,不想那么多了,好好过完上半年再说吧.</p><h3 id="2018年上半年计划"><a href="#2018年上半年计划" class="headerlink" title="2018年上半年计划"></a>2018年上半年计划</h3><p>1.我是2017年2月份入职实习,直到现在我已经成为技术部第四位老员工了(技术部20+人),不知道公司之前发生了什么还是将来发生什么,对我来说算是无关紧要,第一份工作至少满一年,一年以后的事情等我定下半年计划时在考虑吧.<br>2.学习Golang与TypeScript,虽然语言各有使用场景,但是对于动态语言我个人是比较反感的,因为动态类型,导致其写法太灵活,尤其是在维护他人的代码时那简直是噩梦,因此Golang成为了我代替Python的最佳选择,另外还有TypeScript是代替JavaScript的最佳选择.<br>3.阅读java.util包源码,巩固基础还是应该多看JDK源码.<br>4.阅读Spring源码,SSM框架一直在生产环境使用,那么不读读代码总觉得心里不踏实.<br>5.自己筹划的一个项目上线.<br>6.好好体会塞尔达荒野之息,一直在等二月份的中文版,打算细腻的体会那群执着的游戏设计师的小心思.</p><h3 id="2018年下半年计划"><a href="#2018年下半年计划" class="headerlink" title="2018年下半年计划"></a>2018年下半年计划</h3><p><strong>todo quding</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年已经过去,在2018年第一天花了一下午时间把博客的主题换了下,新的一年新的开始,当然也要有新的皮肤主题啦.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;2017年总结&quot;&gt;&lt;a href=&quot;#2017年总结&quot; class=&quot;headerlink&quot; title=&quot;2017年总结
      
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="选择" scheme="http://mrdear.cn/tags/%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(四)--TypeHandler的解析</title>
    <link href="http://mrdear.cn/2017/12/15/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)--Typehandler%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://mrdear.cn/2017/12/15/mybatis/Mybatis源码分析(四)--Typehandler的本质/</id>
    <published>2017-12-15T15:14:45.000Z</published>
    <updated>2017-12-15T15:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习前的疑问"><a href="#学习前的疑问" class="headerlink" title="学习前的疑问"></a>学习前的疑问</h3><ol><li>TypeHandler的主要功能是什么?</li><li>TypeHandler如何配置?</li><li>Mybatis是如何使用TypeHandler?(参数设置,结果映射)</li></ol><h3 id="TypeHandler的主要功能是什么"><a href="#TypeHandler的主要功能是什么" class="headerlink" title="TypeHandler的主要功能是什么?"></a>TypeHandler的主要功能是什么?</h3><p><code>TypeHandler</code>是一个接口,那么其所拥有什么功能最简单的方法是看接口方法与注释(这里mybatis注释相当少),那么看下列方法.<br>1.<code>void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;</code><br>该方法为设置参数使用的转换方法,所需要的参数基本都给你传过来了,因此很好理解.<br>2.<code>T getResult(ResultSet rs, String columnName) throws SQLException;</code><br>该方法是拿到结果集后根据列名称处理结果<br>3.<code>T getResult(ResultSet rs, int columnIndex) throws SQLException</code><br>该方法是拿到结果集后根据列序号处理结果<br>4.<code>T getResult(CallableStatement cs, int columnIndex) throws SQLException;</code><br>该方法是针对存储过程转换结果.</p><p>那么<code>TypeHandler</code>的作用就可以简单的理解为: </p><ol><li><strong>转换参数到sql中</strong></li><li><strong>转换查询结果到Java类中</strong></li></ol><h3 id="TypeHandler如何配置"><a href="#TypeHandler如何配置" class="headerlink" title="TypeHandler如何配置?"></a>TypeHandler如何配置?</h3><h4 id="1-系统默认转换器"><a href="#1-系统默认转换器" class="headerlink" title="1.系统默认转换器"></a>1.系统默认转换器</h4><p>TypeHandler有一个注册工厂为<code>TypeHandlerRegistry</code>类,该类中默认初始化了常用的转换器,其成员变量中有如下两个Map,可以看到<code>JDBC_TYPE_HANDLER_MAP</code>该map是针对jdbc转换到Java类的转换,为一对一结构,<code>TYPE_HANDLER_MAP</code>该map是针对Java类到JDBC类型的转换,为一对多结构.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = <span class="keyword">new</span> EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>以String类的转换器注册为例分析下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">register(String.class, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">register(String.class, JdbcType.CHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">register(String.class, JdbcType.CLOB, <span class="keyword">new</span> ClobTypeHandler());</span><br><span class="line">register(String.class, JdbcType.VARCHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">register(String.class, JdbcType.LONGVARCHAR, <span class="keyword">new</span> ClobTypeHandler());</span><br><span class="line">register(String.class, JdbcType.NVARCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">register(String.class, JdbcType.NCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">register(String.class, JdbcType.NCLOB, <span class="keyword">new</span> NClobTypeHandler());</span><br><span class="line">register(JdbcType.CHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">register(JdbcType.VARCHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">register(JdbcType.CLOB, <span class="keyword">new</span> ClobTypeHandler());</span><br><span class="line">register(JdbcType.LONGVARCHAR, <span class="keyword">new</span> ClobTypeHandler());</span><br><span class="line">register(JdbcType.NVARCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">register(JdbcType.NCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">register(JdbcType.NCLOB, <span class="keyword">new</span> NClobTypeHandler());</span><br></pre></td></tr></table></figure></p><p>那么对应的<strong>JDBC_TYPE_HANDLER_MAP</strong>内存里面为<br><img src="http://oobu4m7ko.bkt.clouddn.com/1513402348.png?imageMogr2/thumbnail/!70p" alt=""><br><strong>TYPE_HANDLER_MAP</strong>内存里面接口如下图,注意在其<code>TypeHandler</code>中有一个key为null的转换器,其对应的注册方法自然为<code>register(String.class, new StringTypeHandler());</code>,那么也就是说当没指定jdbc类型时对于String.class类的转换均使用该转换器作为默认的<code>TypeHandler</code>.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1513402290.png?imageMogr2/thumbnail/!70p" alt=""></p><h4 id="2-mybatis-type-handlers-package转换器"><a href="#2-mybatis-type-handlers-package转换器" class="headerlink" title="2.mybatis.type-handlers-package转换器"></a>2.mybatis.type-handlers-package转换器</h4><p>该指令是配置一个转换器所在的包,然后扫描该包下的<code>TypeHandler</code>的实现类,自动注册为转换器,详情可以看<code>org.apache.ibatis.type.TypeHandlerRegistry#register(java.lang.String)</code>方法<br>由于Java存在泛型擦除机制,那么该Handler针对的JavaType该方法从<code>TypeHandler</code>实现类是拿不到的,因此其需要配合<code>MappedTypes</code>注解,看如下实现方法,针对<code>TypeHandler</code>去主动获取其上的<code>MappedTypes</code>注解,使用注解中的JavaType作为该<code>TypeHandler</code>的转换主体,如果获取不到则使用null,因此需要额外注意.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt; typeHandlerClass)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> mappedTypeFound = <span class="keyword">false</span>;</span><br><span class="line">   MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);</span><br><span class="line">   <span class="keyword">if</span> (mappedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;</span><br><span class="line">       register(javaTypeClass, typeHandlerClass);</span><br><span class="line">       mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">     register(getInstance(<span class="keyword">null</span>, typeHandlerClass));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-Mapper中定义的TypeHandler"><a href="#3-Mapper中定义的TypeHandler" class="headerlink" title="3.Mapper中定义的TypeHandler"></a>3.Mapper中定义的TypeHandler</h4><p>首先我定义一个自定义的<code>TypeHandler</code>,该Handler只针对我所定义的枚举类处理,当然只能处理<code>UserIdentifyType</code>枚举类型,后面会实现一个通用的枚举转换器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserIdentifyTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">UserIdentifyType</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, UserIdentifyType parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setInt(i, parameter.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserIdentifyType <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UserIdentifyType.of(rs.getInt(columnName));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserIdentifyType <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UserIdentifyType.of(rs.getInt(columnIndex));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserIdentifyType <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UserIdentifyType.of(cs.getInt(columnIndex));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在mapper.xml文件中也是可以定义<code>TypeHandler</code>的,如下形式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findByOpenIdAnyType"</span> resultType=<span class="string">"com.itoolshub.user.repository.domain.UserAuth"</span>&gt;</span><br><span class="line">SELECT &lt;include refid=<span class="string">"RM-USERAUTH-ALLCOLS"</span>/&gt;</span><br><span class="line">FROM user_auth</span><br><span class="line">WHERE status = 1 AND openid = #&#123;openId&#125; AND identity_type = #&#123;type,typeHandler=com.itoolshub.user.convert.UserIdentifyTypeHandler&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>那么这个<code>TypeHandler</code>是什么时候初始化的呢?<br>这里涉及到<code>ParameterMapping</code>这个类,该类是Mybatis存储参数映射的地方,其内部有方法<code>org.apache.ibatis.builder.BaseBuilder#resolveTypeHandler(java.lang.Class&lt;?&gt;, java.lang.Class&lt;? extends org.apache.ibatis.type.TypeHandler&lt;?&gt;&gt;)</code>,该方法会获取到对应的<code>TypeHandler</code>,然后从<code>typeHandlerRegistry</code>中获取,获取不到则使用反射生成一个.<strong>生成后并没有加入到typeHandlerRegistry中,也就是该TypeHandler并非单例,多少个sqlStament中如果使用了该转换器那么就会实例化几个该转换器</strong>,因此正确的使用方法是把该<code>TypeHandler</code>注册到<code>typeHandlerRegistry</code>中,然后在xml中使用.那么针对上述sql的<code>ParameterMapping</code>如下.<br>另外由于我没有在xml中指定JavaType,那么其默认为Object,也就是参数设置是不能动态获取参数类型的.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1513414409.png?imageMogr2/thumbnail/!70p" alt=""></p><h3 id="参数如何使用TypeHandler设置到sql中"><a href="#参数如何使用TypeHandler设置到sql中" class="headerlink" title="参数如何使用TypeHandler设置到sql中?"></a>参数如何使用TypeHandler设置到sql中?</h3><p>上面说到对于每一个sqlSatment都会解析为一个ParameterMapping的Map集合,在该<code>ParameterMapping</code>中TypeHandler已经确定好了,那么设置参数就只需要简单的调用下<code>typeHandler.setParameter(ps, i + 1, value, jdbcType);</code>方法,具体可以参考<code>org.apache.ibatis.scripting.defaults.DefaultParameterHandler#setParameters</code>方法中对其的做法.<br>这里有一个很重要的点就是这里的<code>TypeHandler</code>的选择没有和我传入的参数类型绑定,举个例子我把上述参数去掉typehandler变成<code>identity_type = #{type}</code>,那么得到的则是一个<code>UnknownTypeHandler</code>.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1513423812.png?imageMogr2/thumbnail/!70p" alt=""></p><h4 id="UnknownTypeHandler并不Unknow"><a href="#UnknownTypeHandler并不Unknow" class="headerlink" title="UnknownTypeHandler并不Unknow"></a>UnknownTypeHandler并不Unknow</h4><p><code>UnknownTypeHandler</code>的实现中能获取到具体输入参数的类型,然后调用<code>org.apache.ibatis.type.UnknownTypeHandler#resolveTypeHandler(java.lang.Object, org.apache.ibatis.type.JdbcType)</code>方法从<code>TypeHandlerRegistry</code>中获取到真正的转换器,这里的获取是根据输入参数的具体类型的class名称.获取不到则使用<code>ObjectTypeHandler</code>作为转换器.</p><h3 id="结果如何使用TypeHandler设置到结果集中"><a href="#结果如何使用TypeHandler设置到结果集中" class="headerlink" title="结果如何使用TypeHandler设置到结果集中?"></a>结果如何使用TypeHandler设置到结果集中?</h3><p>相比参数设置结果的取出转换要复杂很多,方法<code>org.apache.ibatis.executor.resultset.ResultSetWrapper#getTypeHandler</code>中定义了一系列的获取<code>TypeHandler</code>的策略,总结如下顺序</p><ol><li>根据返回参数类型+jdbc类型</li><li>根据返回参数类型</li><li>根据jdbc类型<br>具体就不展开讨论了.</li></ol><h3 id="制作通用的枚举类处理器"><a href="#制作通用的枚举类处理器" class="headerlink" title="制作通用的枚举类处理器"></a>制作通用的枚举类处理器</h3><p>依照上述分析,如果想让枚举类的处理和基本类型一样的不需要显示的在mapper.xml上指定一些属性,几乎是不可能的一键事情,不过可以大大简化其使用方式,首先分析下对于枚举类两处的处理.</p><ol><li>参数设置时,mapper.xml中的sql字段什么都不指定直接#{value},那么最终会使用该value的<strong>class名称</strong>去获取到对应的typeHandler.</li><li>结果映射时,由上述优先级顺序可以得知对于枚举类会使用方式2<strong>根据返回参数类型,也就是class名称</strong>获取对应的typeHandler.</li></ol><p>那么通用转换器的实现思路很简单了,首先定义一个枚举类所使用的接口,然后编写通用处理,这里能实现还一个原因就是Class对象有<code>type.getEnumConstants()</code>方法可以获取到其所有枚举对象,也就是可以把数字映射为指定结果了,需要注意的是这里把每个枚举类都注入到<code>TypeHandlerRegistry</code>使用的是<code>@MappedTypes</code>注解,该注解生效是需要配置<code>mybatis.type-handlers-package</code>以包的形式扫,否则不生效.</p><p>下面的代码是copy自github,本文算是对其原理分析了一遍.<a href="https://github.com/mybatis/mybatis-3/issues/42" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/issues/42</a><br><strong>EnumHasValue</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnumHasValue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>EnumValueTypeHandler</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedTypes</span>(&#123;UserIdentifyType.class, UserRoleType.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumValueTypeHandler</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt; &amp; <span class="title">EnumHasValue</span>&gt; <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;E&gt; type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> E[] enums;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EnumValueTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Type argument cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.enums = type.getEnumConstants();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enums == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(type.getSimpleName() + <span class="string">" does not represent an enum type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, E parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setInt(i,parameter.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = rs.getInt(columnName);</span><br><span class="line">    <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (E enm : enums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == enm.getValue()) &#123;</span><br><span class="line">        <span class="keyword">return</span> enm;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot convert "</span> + value + <span class="string">" to "</span> + type.getSimpleName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = rs.getInt(columnIndex);</span><br><span class="line">    <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (E enm : enums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == enm.getValue()) &#123;</span><br><span class="line">        <span class="keyword">return</span> enm;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot convert "</span> + value + <span class="string">" to "</span> + type.getSimpleName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = cs.getInt(columnIndex);</span><br><span class="line">    <span class="keyword">if</span> (cs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (E enm : enums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == enm.getValue()) &#123;</span><br><span class="line">        <span class="keyword">return</span> enm;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot convert "</span> + value + <span class="string">" to "</span> + type.getSimpleName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>以上内容基于 <code>mybatis-spring-boot-starter</code>:1.3.0,其<code>mybatis</code>版本3.4.4</p><p>参考文章: <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学习前的疑问&quot;&gt;&lt;a href=&quot;#学习前的疑问&quot; class=&quot;headerlink&quot; title=&quot;学习前的疑问&quot;&gt;&lt;/a&gt;学习前的疑问&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;TypeHandler的主要功能是什么?&lt;/li&gt;
&lt;li&gt;TypeHandler如何配置?&lt;/
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>由需求而产生的一款db导出excel的工具</title>
    <link href="http://mrdear.cn/2017/12/02/%E5%B7%A5%E5%85%B7/%E7%94%B1%E9%9C%80%E6%B1%82%E8%80%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%80%E6%AC%BEdb%E5%AF%BC%E5%87%BAexcel%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>http://mrdear.cn/2017/12/02/工具/由需求而产生的一款db导出excel的工具/</id>
    <published>2017-12-02T02:03:05.000Z</published>
    <updated>2017-12-02T02:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序员最大的毛病可能就是懒,因为懒所以做出了许许多多提高自己工作效率的工具.<br>起因于我是商业开发,既然是商业项目避免不了各种数据统计,虽然公司有专门的数据平台,但是应对一些临时性需求还是免不了开发人员去导出一些数据.每一次有需求来我都是写一个复杂的sql,然后放到<code>DataGrip</code>中执行,利用其功能导出cvs,然而越来越多的需求该功能无法满足,比如导出组合表,也就是一个excel中有多个sheet表.那么应该这个需求我写了一个为自己的工具.</p><h3 id="我理想中的工具"><a href="#我理想中的工具" class="headerlink" title="我理想中的工具"></a>我理想中的工具</h3><blockquote><p>1.简单模式使用sql查询直接导出<br>2.复杂模式可以定义一些复杂的bean,然后通过组合代码中自定义实现导出逻辑<br>3.可以自己定义表头,以及对应的数据处理,比如把时间戳转换为yyy-MM-dd hh:MM:ss这样的形式<br>4.支持一个excel中含有多个sheet<br>5.不需要很复杂的配置,因为自用,所以能约定俗成的地方就约定俗成.</p></blockquote><h3 id="语言的选择"><a href="#语言的选择" class="headerlink" title="语言的选择"></a>语言的选择</h3><p>这个很随意了,我是选择自己最熟悉的语言,也就是Java.<br>同事听说我用Java写这种工具,强烈推荐我用py,但天生动态语言无感,可以说是反感,所以放弃.</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>DB连接: DBUtils<br>Excel: POI<br>具体过程很简单,代码逻辑也很清晰,这里只说下主要流程,详细的可以参考源码Github地址,另外由于个人使用,所以没有太多的校验和异常考虑.</p><p><strong>easy-excel</strong>   <a href="[https://github.com/mrdear/easy-excel](https://github.com/mrdear/easy-excel"><a href="https://github.com/mrdear/easy-excel" target="_blank" rel="noopener">https://github.com/mrdear/easy-excel</a></a>)</p><p>另外分享一个IDEA从数据库表生成对应Bean的脚本,使用方法自定义自己的<code>extensions script</code>即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets</span><br><span class="line"><span class="keyword">import</span> com.intellij.database.model.DasTable</span><br><span class="line"><span class="keyword">import</span> com.intellij.database.model.ObjectKind</span><br><span class="line"><span class="keyword">import</span> com.intellij.database.util.Case</span><br><span class="line"><span class="keyword">import</span> com.intellij.database.util.DasUtil</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Available context bindings:</span></span><br><span class="line"><span class="comment"> *   SELECTION   Iterable&lt;DasObject&gt;</span></span><br><span class="line"><span class="comment"> *   PROJECT     project</span></span><br><span class="line"><span class="comment"> *   FILES       files helper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">typeMapping = [</span><br><span class="line">        (~/(?i)tinyint/)                  : <span class="string">"Integer"</span>,</span><br><span class="line">        (~/(?i)<span class="keyword">int</span>/)                      : <span class="string">"Long"</span>,</span><br><span class="line">        (~/(?i)<span class="keyword">float</span>|<span class="keyword">double</span>|decimal|real/): <span class="string">"Double"</span>,</span><br><span class="line">        (~/(?i)date|datetime|timestamp/)  : <span class="string">"java.util.Date"</span>,</span><br><span class="line">        (~/(?i)time/)                     : <span class="string">"java.sql.Time"</span>,</span><br><span class="line">        (~/(?i)/)                         : <span class="string">"String"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">colTypeMapping = [</span><br><span class="line">        (~/(?i)tinyint/)                  : <span class="string">"TINYINT"</span>,</span><br><span class="line">        (~/(?i)<span class="keyword">int</span>/)                      : <span class="string">"BIGINT"</span>,</span><br><span class="line">        (~/(?i)<span class="keyword">float</span>|<span class="keyword">double</span>|decimal|real/): <span class="string">"DECIMAL"</span>,</span><br><span class="line">        (~/(?i)datetime|timestamp/)       : <span class="string">"TIMESTAMP"</span>,</span><br><span class="line">        (~/(?i)date/)                     : <span class="string">"TIMESTAMP"</span>,</span><br><span class="line">        (~/(?i)time/)                     : <span class="string">"TIMESTAMP"</span>,</span><br><span class="line">        (~/(?i)text/)                     : <span class="string">"LONGVARCHAR"</span>,</span><br><span class="line">        (~/(?i)/)                         : <span class="string">"VARCHAR"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">FILES.chooseDirectoryAndSave(<span class="string">"Choose directory"</span>, <span class="string">"Choose where to store generated files"</span>) &#123; dir -&gt;</span><br><span class="line">    SELECTION.filter &#123; it <span class="keyword">instanceof</span> DasTable &amp;&amp; it.getKind() == ObjectKind.TABLE &#125;.each &#123;</span><br><span class="line">        generate(it, dir)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generate</span><span class="params">(table, dir)</span> </span>&#123;</span><br><span class="line">    def packageName = getPackageName(dir)</span><br><span class="line">    def className = javaName(table.getName(), <span class="keyword">true</span>)</span><br><span class="line">    def fields = calcFields(table)</span><br><span class="line">    <span class="comment">//创建相关目录 repository目录下的</span></span><br><span class="line">    def path = dir.toString()</span><br><span class="line">        <span class="comment">//创建pojo与xml</span></span><br><span class="line">    <span class="keyword">new</span> File(path + File.separator + className + <span class="string">".java"</span>).withPrintWriter &#123; out -&gt; generatePojo(out,</span><br><span class="line">                packageName, className, fields) &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成POJO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fields</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">generatePojo</span><span class="params">(out, packageName, className, fields)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    out.println <span class="string">"package $&#123;packageName&#125;;"</span></span><br><span class="line">    out.println <span class="string">""</span></span><br><span class="line">    out.println <span class="string">"@Data"</span></span><br><span class="line">    out.println <span class="string">"public class $&#123;className&#125; &#123;"</span></span><br><span class="line">    out.println <span class="string">""</span></span><br><span class="line">    fields.each() &#123;</span><br><span class="line">        <span class="comment">// 输出注释</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNoneEmpty(it.comment)) &#123;</span><br><span class="line">            out.println <span class="string">"  /**"</span></span><br><span class="line">            out.println <span class="string">"   * $&#123;it.comment&#125;"</span></span><br><span class="line">            out.println <span class="string">"   */"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it.annos != <span class="string">""</span>) out.println <span class="string">"  $&#123;it.annos&#125;"</span></span><br><span class="line">        out.println <span class="string">"  private $&#123;it.type&#125; $&#123;it.name&#125;;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    out.println <span class="string">""</span></span><br><span class="line">    out.println <span class="string">"&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------方法 ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿到所有的字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> table 数据库表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字段Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">calcFields</span><span class="params">(table)</span> </span>&#123;</span><br><span class="line">    DasUtil.getColumns(table).reduce([]) &#123; fields, col -&gt;</span><br><span class="line">        def spec = Case.LOWER.apply(col.getDataType().getSpecification())</span><br><span class="line">        def typeStr = typeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value</span><br><span class="line">        def colTypeStr = colTypeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value</span><br><span class="line">        fields += [[</span><br><span class="line">                           colName: col.getName(),</span><br><span class="line">                           name   : javaName(col.getName(), <span class="keyword">false</span>),</span><br><span class="line">                           type   : typeStr,</span><br><span class="line">                           colType: colTypeStr,</span><br><span class="line">                           comment: col.getComment(),</span><br><span class="line">                           annos  : <span class="string">""</span>]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字段对应的Java类名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">javaName</span><span class="params">(str, capitalize)</span> </span>&#123;</span><br><span class="line">    def s = str.split(/(?&lt;=[^\p&#123;IsLetter&#125;])/).collect &#123; Case.LOWER.apply(it).capitalize() &#125;</span><br><span class="line">            .join(<span class="string">""</span>).replaceAll(<span class="string">"_"</span>, <span class="string">""</span>)</span><br><span class="line">    capitalize || s.length() == <span class="number">1</span> ? s : Case.LOWER.apply(s[<span class="number">0</span>]) + s[<span class="number">1</span>..-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 实体类所在目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">getPackageName</span><span class="params">(dir)</span> </span>&#123;</span><br><span class="line">    def target = dir.toString().replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>).replaceAll(<span class="string">"^.*src(\\.main\\.java\\.)?"</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target.charAt(<span class="number">0</span>) == <span class="string">'.'</span> ? target.substring(<span class="number">1</span>) : target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文的主要目的是表达迷茫的时候不知道自己该做什么,那么就从自己身边的需求开始,分析自己所遇到的痛点,然后用你喜欢的方式去解决这个痛点,那么这个过程就是你的进步.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序员最大的毛病可能就是懒,因为懒所以做出了许许多多提高自己工作效率的工具.&lt;br&gt;起因于我是商业开发,既然是商业项目避免不了各种数据统计,虽然公司有专门的数据平台,但是应对一些临时性需求还是免不了开发人员去导出一些数据.每一次有需求来我都是写一个复杂的sql,然后放到&lt;c
      
    
    </summary>
    
      <category term="工具" scheme="http://mrdear.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="excel" scheme="http://mrdear.cn/tags/excel/"/>
    
      <category term="工具" scheme="http://mrdear.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>git的回滚操作</title>
    <link href="http://mrdear.cn/2017/11/20/%E5%B7%A5%E5%85%B7/git%E7%9A%84%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://mrdear.cn/2017/11/20/工具/git的回滚操作/</id>
    <published>2017-11-20T14:39:59.000Z</published>
    <updated>2017-11-20T14:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直在使用git作为版本管理器,但是有一次线上出问题,但是又有未通过完整测试的代码在mater分支上,那么所需要的操作就是 <code>回滚代码到上一个已通过测试的master版本</code> -&gt; <code>修复bug</code> -&gt; <code>发布</code> -&gt; <code>还原master</code> -&gt; <code>合并修改了bug的分支</code> -&gt; <code>重新上预发布</code>,那么下面开始演练.</p><p>为了简单描述,我们把定义几个分支.<br>init-master //最初的master<br>untest-master  //未完全通过测试的master,其是远程仓库上最新的master<br>bugfix/fix_some_bug  //修改的bug分支</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>拉取untest-master</strong><br>首先是切换并更新master,注意此时的master是<code>untest-master</code>,也就是我们要对其进行回滚操作<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p><strong>回滚到init-master</strong><br>回滚操作首先需要定义到要回滚到的提交记录,然后强制回滚到该记录上,注意这里的操作只是对本地分支的操作并不会影响到远程分支<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//使用git <span class="built_in">log</span>查看其提交记录,确定要回滚到的`commit id`</span><br><span class="line">git <span class="built_in">log</span> </span><br><span class="line">g reset --hard [commit id]</span><br></pre></td></tr></table></figure></p><p><strong>回滚远程master</strong><br>回滚操作是把你当前的分支强制提交到master上也就是加<code>-f</code>参数指明<strong>强制覆盖</strong>,该命令需要你有相应的master权限.这样的话master上就是之前的版本了.那么接下来就是一般的修改bug了.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure></p><p><strong>修复bug,并发布</strong><br>bug的修复是在当前<code>init-master</code>分支的基础上,切出一个新的分支,然后像平常一样修改提交,最后合到<code>init-master</code>上.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b bugfix/fix_some_bug</span><br><span class="line">// 修复bug</span><br><span class="line">// 发布</span><br></pre></td></tr></table></figure></p><p><strong>取消回滚</strong><br>取消回滚则是重新强制恢复到修改过的版本,然后就可以强制回滚到任意版本了<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog  查看该分支的变动,可以确定其commit id</span><br><span class="line">git reset --hard [commit id]</span><br></pre></td></tr></table></figure></p><p><strong>合并修改了bug的分支</strong><br>这次回滚后你处在<code>untest-master</code>分支上,该分支上是没有<code>bugfix/fix_some_bug</code>修复bug的代码的,那么把他合并过来.然后推送上去,那么master就是当前最新的版本了<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge bugfix/fix_some_bug</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是操作是必须需要有master权限的,否则无法回滚,另外如果担心代码丢失那么在<code>untest-master</code>分支上再次checkout一个分支,这样即使master再怎么变,这个分支仍然是<code>untest-master</code>的副本.<br>最后git是一款强大的版本工具,其可能有更加简单的方法,欢迎分享.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直在使用git作为版本管理器,但是有一次线上出问题,但是又有未通过完整测试的代码在mater分支上,那么所需要的操作就是 &lt;code&gt;回滚代码到上一个已通过测试的master版本&lt;/code&gt; -&amp;gt; &lt;code&gt;修复bug&lt;/code&gt; -&amp;gt; &lt;code&gt;发布
      
    
    </summary>
    
      <category term="git" scheme="http://mrdear.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://mrdear.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>委派模型与类加载器</title>
    <link href="http://mrdear.cn/2017/11/13/java/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://mrdear.cn/2017/11/13/java/委派模型与类加载器/</id>
    <published>2017-11-13T14:44:03.000Z</published>
    <updated>2017-11-13T14:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读许令波的<code>深入分析Java Web技术内幕</code>一书,对于学习Java以来一直有的几个疑惑得到了解答,遂记录下来.</p><h3 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h3><ol><li>双亲委派模型(实际上是一个翻译错误,英文为parent delegation,只是一个父委托模型)是什么?如何实现?为什么这样实现?</li><li>热加载的技术原理是什么?</li><li>ClassLoader如何实现动态加载jar,实现插件模式系统?<br>下面跟着教程来寻找这些答案.</li></ol><h3 id="ClassLoader与委派模型"><a href="#ClassLoader与委派模型" class="headerlink" title="ClassLoader与委派模型"></a>ClassLoader与委派模型</h3><p>ClassLoader顾名思义是类加载器,负责将Class加载到JVM中,其所使用的加载策略叫做双亲委派模型.<br>JVM平台提供三个ClassLoader:</p><ul><li>Bootstrap ClassLoader,由C++实现的类加载器,其主要负责加载JVM自身工作所需要的类,该Loader由JVM自身控制,别人是无法访问的,其也不再双亲委派模型中承担角色.</li><li>ExtClassLoader,该类加载器主要加载<code>System.getProperty(&quot;java.ext.dirs&quot;)</code>所对应的目录下class文件.一般为JVM平台扩展工具.</li><li>AppClassLoader,该类加载器主要加载 <code>System.getProperty(&quot;java.class.path&quot;)</code>所对应的目录下的class文件,其委托父类为<code>ExtClassLoader</code>(后面会解释)</li></ul><p>对于<code>ExtClassLoader</code>和<code>AppClassLoader</code>有着一个统一的父类<code>ClassLoader</code>,该类的结构如下,其拥有一个委托父类对象,同样的设计在Mybatis的Exector中也有体现,感兴趣的同学可以看我之前关于Mybatis分析的文章.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来重点看<code>loadClass()</code>方法,该方法为加载class二进制文件的核心方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//当父加载器不存在的时候会尝试使用BootStrapClassLoader作为父类</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//c为null则证明父加载器没有加载到,进而使用子类本身的加载策略`findClass()`方法</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>那么开始回答问题<br><strong>1. 双亲委派模型是什么?</strong><br>上述加载流程是 <code>使用parent加载器加载类</code> -&gt; <code>parent不存在使用BootStrapClassLoader加载</code> -&gt; <code>加载不到则使用子类的加载策略</code>,这里要注意<code>BootStrapClassLoader</code>是由C++实现的JVM内部的加载工具,其没有对应的Java对象,因此不在这个委派体系中,只是相当于名义上的加载器父类. 那么所谓的双亲我认为是parent委托对象与<code>BootStrapClassLoader</code>最顶端的加载器,两者都是属于被委托的对象,那么这就是所谓的<code>双亲委派模型</code>.</p><p>那么双亲是什么?  <strong>看ClassLoader的注释就能发现这只是个翻译错误,害得我脑补半天</strong>,明明是单亲委派,更通俗来说就是一个委托模式,当parent为null的时候,其parent为名义上的BootStrapClassLoader<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each instance of &lt;tt&gt;ClassLoader&lt;/tt&gt; has an associated parent class loader</span><br></pre></td></tr></table></figure></p><p><strong>2. 委派模型如何实现?</strong><br>实现如上述代码所示,其类本身有<code>private final ClassLoader parent;</code>这一委托父对象,另外其还有虚拟机实现的<code>BootStrapClassLoader</code>这个名义上的父加载器,在方法上优先执行委托类的策略.<br><strong>3. 为什么使用委派模型?</strong><br>回答这个问题要先了解Java中是如何判定两个类是同一个类状况,如下段官方所说,也就是类名(包括包名)相同并且他们的类加载器相同,那么两个对象才是等价的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">At run time, several reference types with the same binary name may be loaded simultaneously by different <span class="class"><span class="keyword">class</span> <span class="title">loaders</span>. </span></span><br><span class="line"><span class="class"><span class="title">These</span> <span class="title">types</span> <span class="title">may</span> <span class="title">or</span> <span class="title">may</span> <span class="title">not</span> <span class="title">represent</span> <span class="title">the</span> <span class="title">same</span> <span class="title">type</span> <span class="title">declaration</span>. </span></span><br><span class="line"><span class="class"><span class="title">Even</span> <span class="title">if</span> <span class="title">two</span> <span class="title">such</span> <span class="title">types</span> <span class="title">do</span> <span class="title">represent</span> <span class="title">the</span> <span class="title">same</span> <span class="title">type</span> <span class="title">declaration</span>, <span class="title">they</span> <span class="title">are</span> <span class="title">considered</span> <span class="title">distinct</span>.</span></span><br></pre></td></tr></table></figure></p><p>对于Object类因为父加载器先加载所以能保证对于所有Object的子类其所对应的Object都是由同一个ClassLoader所加载,也就保证了对象相等. 简单来说委托类优先模式保证了加载器的优先级问题,让优先级高的ClassLoader先加载,然后轮到优先级低的.</p><h3 id="热加载的技术原理"><a href="#热加载的技术原理" class="headerlink" title="热加载的技术原理"></a>热加载的技术原理</h3><p>热部署对于开发阶段的实用性极高,利用Jrebel等工具可以极大的节省应用调试时间.关于热加载技术可以参考文章<a href="http://www.hollischuang.com/archives/606" target="_blank" rel="noopener">http://www.hollischuang.com/archives/606</a>,<br>对于一个被ClassLoader加载到内存的类来说,再次加载的时候就会被<code>findLoadedClass()</code>方法所拦截,其判断该类已加载,则不会再次加载,那么热加载的技术本质是要替换到已加载的类.</p><p>对于Spring Boot devtools的restart技术,其是使用了两个ClassLoader,对于开发者所写的类使用自定义的ClassLoader,对于第三方包则使用默认加载器,那么每当代码有改动需要热加载时,丢弃自定义的ClassLoader所加载的类,然后重新使用其加载,如此做到了热部署.</p><p>对于Jrebel使用的貌似是修改类的字节码方式,具体不是很懂也就不讨论了.</p><p>对于Tomcat,其热部署技术是每次清理之前的引用,然后创建一个新的ClassLoader<code>WebClassLoader</code>来重新加载应用,这个加载使得永久代中对象增多,那么清理要求是full GC,这个是不可控的,所以也就导致了Tomcat热部署频繁会触发<code>java.lang.OutOfMemoryErrorPermGen space</code>这个bug.</p><h3 id="ClassLoader如何实现动态加载jar-实现插件模式系统"><a href="#ClassLoader如何实现动态加载jar-实现插件模式系统" class="headerlink" title="ClassLoader如何实现动态加载jar,实现插件模式系统?"></a>ClassLoader如何实现动态加载jar,实现插件模式系统?</h3><p>ClassLoader的委派模型使得很容易扩展自定义的类加载器,那么基本步骤 <code>定义自己的类加载器</code> -&gt; <code>加载指定jar</code> -&gt; <code>创建所需要的应用实例</code>,大概代码如下.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String jarPath = <span class="string">"/Users/niuli/workspace/quding-git/quding-study/helloworld/target/hello-world-1.0-SNAPSHOT.jar"</span>;</span><br><span class="line">    URL jarUrl = <span class="keyword">new</span> File(jarPath).toURI().toURL();</span><br><span class="line">    <span class="comment">//加载该jar</span></span><br><span class="line">    URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;jarUrl&#125;,Thread.currentThread().getContextClassLoader());</span><br><span class="line">    <span class="comment">//获取插件Class对象</span></span><br><span class="line">    Class helloClass = loader.loadClass(<span class="string">"com.itoolshub.hello.HelloWorld"</span>);</span><br><span class="line">    <span class="comment">//创建该对象</span></span><br><span class="line">    IHelloWorldService helloWorldService = (IHelloWorldService) helloClass.newInstance();</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    helloWorldService.sayHello();</span><br></pre></td></tr></table></figure></p><p>另外插件模式的话一般还会有一些配置文件plugin.xml,告诉系统主要对外提供服务的类是什么以及一些默认配置等.不过大概思路都是大同小异.</p><p>另外既然有装载也就有卸载,卸载的必要条件是以下三个外,另外类是装载在永久代,那么卸载的触发也就是full GC才会去清理永久代中没有被强引用指向的类.</p><ol><li>该类所有的实例都已经被GC。</li><li>加载该类的ClassLoader实例已经被GC。</li><li>该类的java.lang.Class对象没有在任何地方被引用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在读许令波的&lt;code&gt;深入分析Java Web技术内幕&lt;/code&gt;一书,对于学习Java以来一直有的几个疑惑得到了解答,遂记录下来.&lt;/p&gt;
&lt;h3 id=&quot;我的疑问&quot;&gt;&lt;a href=&quot;#我的疑问&quot; class=&quot;headerlink&quot; title=&quot;我的疑问&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://mrdear.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的四种引用</title>
    <link href="http://mrdear.cn/2017/10/30/java/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>http://mrdear.cn/2017/10/30/java/Java中的四种引用/</id>
    <published>2017-10-30T14:51:00.000Z</published>
    <updated>2017-10-30T14:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中存在四种引用,StrongReference(强引用) 、SoftReferenc(软引用) 、WeakReferenc(弱引用)、PhantomReference(虚引用).虽然不常用,但是对于理解Java的回收等级还是很有帮助的,一句话来说这些引用只是不同回收等级的一种表现形式.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1509454563.png" alt=""></p><hr><h3 id="StrongReference-强引用"><a href="#StrongReference-强引用" class="headerlink" title="StrongReference(强引用)"></a>StrongReference(强引用)</h3><p>强引用是最经常使用的一种引用,如new操作创建的对象就属于强引用.如下代码,对于强引用要记住<strong>无论如何JVM都不会去回收其内存</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p><h3 id="SoftReferenc-软引用"><a href="#SoftReferenc-软引用" class="headerlink" title="SoftReferenc(软引用)"></a>SoftReferenc(软引用)</h3><p>软引用是由<code>java.lang.ref.SoftReference</code>所提供的功能,被其所关联的对象不存在强引用并且此时JVM内存不足才会去回收该对象.<br>个人不知道其用处,做缓存的话,现在的企业项目基本不是单体架构所以用处不大,倒是可以做内存警告,当对象被回收时则说明系统所需要的内存不足,那么就可以发邮件通知相关人员.</p><h3 id="WeakReferenc-弱引用"><a href="#WeakReferenc-弱引用" class="headerlink" title="WeakReferenc(弱引用)"></a>WeakReferenc(弱引用)</h3><p>弱引用是java.lang.ref包下的WeakReferenc类所提供的包装功能,对于弱引用<strong>JVM会回收仅被弱引用所关联的对象</strong>.也就是说弱引用对象会在一次gc之后被回收,如下代码,其中<code>obj1</code>没被回收,因为其的引用是强引用,但是<code>weakObj1</code>与其关联是弱引用,因此不属于被收回对象.<code>weakObj2</code>所关联的<code>new Object()</code>只有一个弱引用关联,因此会被回收.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; weakObj1 = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj1);</span><br><span class="line">WeakReference&lt;Object&gt; weakObj2 = <span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">//主动回收</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(weakObj1.get()); <span class="comment">// 非null</span></span><br><span class="line">System.out.println(weakObj2.get()); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>Java中提供了一个很棒的工具类<code>WeakHashMap</code>,按照注释所说,该类是一个键为弱引用类型的Map,与传统Map不同的是其键会自动删除释放掉,因为gc()时会自动释放,因此很适合做缓存这一类的需求,下面代码是Tomcat所实现的LRU(最少使用策略)缓存算法的实现,关键点在注释中给出.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//LRU所允许的最大缓存量    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; eden;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; longterm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//eden是主要缓存</span></span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="comment">//longterm是实现LRU算法的关键点.</span></span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get是先从eden中取出缓存,当不存在时则去longterm中获取缓存,并且此时获取到的缓存说明还在使用,因此会put到eden中(LRU算法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (longterm) &#123;</span><br><span class="line">                v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put操作当size大于LRU最大容量时,则把缓存都放入到longterm,当this.eden.clear()后使其成为弱引用,那么LRU的实现则在get方法中体现了出来.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (longterm) &#123;</span><br><span class="line">                <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法如果操作时刚好遇到了一次gc,那么longterm的引用就会丢失,那么缓存就gg了.</p><h3 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference(虚引用)"></a>PhantomReference(虚引用)</h3><p>虚引用是由<code>java.lang.ref.PhantomReference</code>所提供的关联功能,<strong>虚引用对其原对象的生命周期毫无影响</strong>,其可以算是一种标记,当其所引用对象被回收时其会自动加入到引用队列中.也就是说你可以通过虚引用得到哪些对象已被回收.具体用法可以分析<code>common.io</code>中的<code>org.apache.commons.io.FileCleaningTracker</code><br>该类中有一内部类<code>class Tracker extends PhantomReference&lt;Object&gt;</code>,也就是其包裹着虚引用对象,分析其构造函数,<code>marker</code>参数是该具体的虚引用,当marker被回收时,该对应的Track会被加入到引用队列<code>queue</code>中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tracker(String path, FileDeleteStrategy deleteStrategy, Object marker, ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; queue) &#123;</span><br><span class="line">    <span class="comment">//marker是具体的虚引用对象</span></span><br><span class="line">    <span class="keyword">super</span>(marker, queue);</span><br><span class="line">    <span class="keyword">this</span>.path = path;</span><br><span class="line">    <span class="keyword">this</span>.deleteStrategy = deleteStrategy == <span class="keyword">null</span> ? FileDeleteStrategy.NORMAL : deleteStrategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文件删除则是该类维护的一个线程来进行的操作,既然对象回收后会加入到引用队列<code>queue</code>,那么该线程要做的功能自然是从引用队列中获取到对应的<code>Track</code>,然后执行其删除策略.<br>在这个流程中虚引用起到的是跟踪所包裹对象作用,当包裹的的对象被回收时,这边会得到一个通知(将其加入到引用队列).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// thread exits when exitWhenFinished is true and there are no more tracked objects</span></span><br><span class="line">            <span class="keyword">while</span> (exitWhenFinished == <span class="keyword">false</span> || trackers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Wait for a tracker to remove.</span></span><br><span class="line">                    Tracker tracker = (Tracker) q.remove(); <span class="comment">// cannot return null</span></span><br><span class="line">                    trackers.remove(tracker);</span><br><span class="line">                    <span class="keyword">if</span> (!tracker.delete()) &#123;</span><br><span class="line">                        deleteFailures.add(tracker.getPath());</span><br><span class="line">                    &#125;</span><br><span class="line">                    tracker.clear();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/index.html" target="_blank" rel="noopener">理解Java中的弱引用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中存在四种引用,StrongReference(强引用) 、SoftReferenc(软引用) 、WeakReferenc(弱引用)、PhantomReference(虚引用).虽然不常用,但是对于理解Java的回收等级还是很有帮助的,一句话来说这些引用只是不同回收
      
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://mrdear.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>网站升级HTTPS与HTTP2记录</title>
    <link href="http://mrdear.cn/2017/10/18/%E8%BF%90%E7%BB%B4/%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7HTTPS%E4%B8%8EHTTP2%E8%AE%B0%E5%BD%95/"/>
    <id>http://mrdear.cn/2017/10/18/运维/网站升级HTTPS与HTTP2记录/</id>
    <published>2017-10-18T14:15:37.000Z</published>
    <updated>2017-10-18T14:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到两篇文章对于HTTPS与HTTP2两者讲解的很详细,分享并实践一下,正好近期捣鼓了一个工具类站点<a href="https://www.itoolshub.com/" target="_blank" rel="noopener">https://www.itoolshub.com/</a>,可以用来实验.<br><strong>文章地址</strong><br><a href="https://fed.renren.com/2017/09/03/upgrade-to-https/" target="_blank" rel="noopener">为什么要把网站升级到HTTPS</a><br><a href="https://fed.renren.com/2017/09/23/http2/" target="_blank" rel="noopener">怎样把网站升级到http/2</a></p><h3 id="升级HTTPS"><a href="#升级HTTPS" class="headerlink" title="升级HTTPS"></a>升级HTTPS</h3><p>升级的好处如文章所说,另外这里主要是按照文章中的教程来处理,不过我的服务器是Centos7,大体步骤相同,选择操作系统与服务器后会到该页面<a href="https://certbot.eff.org/#centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/#centosrhel7-nginx</a>.<br>要注意<code>sudo certbot --nginx</code>命令,该命令默认会去<code>usr/bin/nginx</code>与<code>/etc/nginx</code>下寻找nginx启动文件与配置文件,因此如果你的nginx位置不对就会报<code>not install</code>错误,导致无法进行,解决方案为使用软链接形式创建链接.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/bin/nginx</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/nginx/conf/ /etc/nginx</span><br></pre></td></tr></table></figure></p><p>命令都执行完后,nginx的server节点下会多出如下配置,第一部分为监听443端口.即https默认端口,使用该证书.第二部分是对非https请求重定向到https.这样也就学到了nginx是怎么配置https请求.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/itoolshub.com/fullchain.pem; # managed by Certbot</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/itoolshub.com/privkey.pem; # managed by Certbot</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    if ($scheme != &quot;https&quot;) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br></pre></td></tr></table></figure></p><h3 id="升级HTTP2"><a href="#升级HTTP2" class="headerlink" title="升级HTTP2"></a>升级HTTP2</h3><p>正如原作者所说HTTP2具有太多的优势,比如多路复用，对同一个域的服务器只建立一次TCP连接，加载多个资源，使用二进制帧传输，同时会对http头部进行压缩,大大提高了传输的效率.<br><strong>要注意的是</strong><br>Nginx启用http2则需要安装<code>http_v2_module</code>模块,并且需要openssl版本大于1.0.2,由于Chrome改变了验证http2的方式,详情可以参考此文章<a href="https://news.cnblogs.com/n/545972/" target="_blank" rel="noopener">https://news.cnblogs.com/n/545972/</a>.</p><p><strong>推荐做法</strong><br>nginx的模块是支持静态编译的,因此自己下载所需要的软件版本,然后编译时指定配置相应的版本是最佳解决方案.如下脚本,我配置了<code>http_v2_module</code>和<code>/opt/openssl-OpenSSL_1_0_2k</code>的版本,这样nginx编译时则不会去使用系统自带的openssl.注意不要<code>make install</code>,该命令是会执行安装操作,也就是会把你之前安装的nginx覆盖掉.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">  --prefix=/usr/<span class="built_in">local</span>/nginx \</span><br><span class="line">  --conf-path=/etc/nginx/nginx.conf \</span><br><span class="line">  --pid-path=/var/<span class="built_in">local</span>/nginx/nginx.pid \</span><br><span class="line">  --lock-path=/var/lock/nginx/nginx.lock \</span><br><span class="line">  --error-log-path=/quding/logs/nginx/error.log \</span><br><span class="line">  --http-log-path=/quding/logs/nginx/access.log \</span><br><span class="line">  --with-http_gzip_static_module \</span><br><span class="line">  --http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">  --http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">  --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">  --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">  --with-http_ssl_module \</span><br><span class="line">  --http-scgi-temp-path=/var/temp/nginx/scgi \</span><br><span class="line">  --with-http_v2_module \</span><br><span class="line">  --with-openssl=/opt/openssl-OpenSSL_1_0_2k</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'make start...'</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>脚本执行完毕后,手动copy nginx替换原nginx,使用<code>nginx -V</code>查看所使用的openssl版本信息,如下所示则不会有大问题.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1508370655.png?imageMogr2/thumbnail/!100p" alt=""></p><p>最后在https监听那里加上http2,nginx reload下即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen 443 ssl http2;</span><br></pre></td></tr></table></figure></p><p>对于chrome最可信的调试方式是访问<code>chrome://net-internals/#http2</code>,如果显示你的网站使用的协议为h2,那么恭喜你开启了http2</p><p>目前<a href="https://www.itoolshub.com/" target="_blank" rel="noopener">https://www.itoolshub.com/</a>已经开启了HTTPS与HTTP2.但是图片是放在七牛云的,七牛的HTTPS收费,所以目前没解决,由于图片并不是很多后期迁到自己的服务器上,或者使用base64形式.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到两篇文章对于HTTPS与HTTP2两者讲解的很详细,分享并实践一下,正好近期捣鼓了一个工具类站点&lt;a href=&quot;https://www.itoolshub.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.itool
      
    
    </summary>
    
      <category term="运维" scheme="http://mrdear.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="https" scheme="http://mrdear.cn/tags/https/"/>
    
      <category term="http2" scheme="http://mrdear.cn/tags/http2/"/>
    
  </entry>
  
  <entry>
    <title>Angular中引入第三方JS库</title>
    <link href="http://mrdear.cn/2017/10/09/web/Angular%E4%B8%AD%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9Js%E5%BA%93/"/>
    <id>http://mrdear.cn/2017/10/09/web/Angular中引入第三方Js库/</id>
    <published>2017-10-09T15:34:43.000Z</published>
    <updated>2017-10-09T15:34:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写<a href="http://www.itoolshub.com/" target="_blank" rel="noopener">http://www.itoolshub.com/</a>的时候用到了日期时间选择器,Angular本身material2只有日期选择器,也不知道为什么官方不提供日期时间选择器,也可能是Angular2以及如今的4有些年轻,很多库都不是很成熟,于是乎搜索到的解决方案就是借助第三方的库来使用一些优秀的组件.本文以<a href="https://github.com/sentsin/laydate" target="_blank" rel="noopener">https://github.com/sentsin/laydate</a>组件为例.</p><h3 id="引入js与css"><a href="#引入js与css" class="headerlink" title="引入js与css"></a>引入js与css</h3><p><a href="https://github.com/sentsin/laydate" target="_blank" rel="noopener">https://github.com/sentsin/laydate</a>是采用原生js实现的组件,因此不需要考虑相关依赖,直接入手.<br>1.使用npm下载该组件<code>npm install layui-laydate -save</code><br>2.在<code>.angular-cli.json</code>文件中配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"styles": [</span><br><span class="line">     "styles.scss",</span><br><span class="line">     <span class="string">"../node_modules/layui-laydate/dist/theme/default/laydate.css"</span></span><br><span class="line">   ],</span><br><span class="line">   "scripts": [</span><br><span class="line">     <span class="string">"../node_modules/layui-laydate/dist/laydate.js"</span></span><br><span class="line">   ],</span><br></pre></td></tr></table></figure></p><p>Angular在编译的时候会把上述的js引用都打包到<code>scripts.bundle.js</code>文件中</p><h3 id="ts编译识别laydate"><a href="#ts编译识别laydate" class="headerlink" title="ts编译识别laydate"></a>ts编译识别laydate</h3><p>第一步完成后如果在TS中使用laydate变量,编译器是会直接报错的,因为其找不到这个变量,因此这一步要做的就是让ts识别该变量.做法很简单,在<code>typings.d.ts</code>中加入声明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SystemJS module definition */</span></span><br><span class="line">declare <span class="keyword">var</span> <span class="built_in">module</span>: NodeModule;</span><br><span class="line">interface NodeModule &#123;</span><br><span class="line">  id: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// laydate声明</span></span><br><span class="line">declare <span class="keyword">var</span> laydate: any;</span><br></pre></td></tr></table></figure></p><h3 id="使用laydate功能"><a href="#使用laydate功能" class="headerlink" title="使用laydate功能"></a>使用laydate功能</h3><p><code>laydate</code>是需要更改Dom节点的,因此该步骤必须放到Angular对视图渲染之后,也就是生命周期中的<code>AfterViewInit</code>函数中执行.另外该渲染会使得双向绑定失效,需要处理结果则可以在<code>laydate</code>的回调函数中处理.<br>另外使用的时候就可以按照ts的语法来使用了,最终都会解析成原生js.比如下方的箭头函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ngAfterViewInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="function">(<span class="params">value, date, endDate</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> selectTime = <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    <span class="keyword">this</span>.timeStampOut = selectTime.getTime() / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">this</span>.timeStampWeek = TimestampComponent.WEEKS[selectTime.getDay()] == <span class="literal">null</span> ? <span class="string">"Invalid Week"</span>: TimestampComponent.WEEKS[selectTime.getDay()]</span><br><span class="line">  &#125;;</span><br><span class="line">  laydate.render(&#123;</span><br><span class="line">    elem: <span class="string">'#layerdate'</span>,</span><br><span class="line">    type: <span class="string">'datetime'</span>,</span><br><span class="line">    change: done,</span><br><span class="line">    done: done</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>很多库都是直接对DOM进行操作,这对于Angular这种虚拟Dom操作会导致绑定失效等各种异常问题,一般情况下不建议混编,尤其是大项目,到后期会出现各种折磨人的小问题.</p><p>更多Angular实战代码可以参考我的开源项目:</p><blockquote><p>github: <a href="https://github.com/nl101531/IToolsHub" target="_blank" rel="noopener">https://github.com/nl101531/IToolsHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写&lt;a href=&quot;http://www.itoolshub.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.itoolshub.com/&lt;/a&gt;的时候用到了日期时间选择器,Angular本身material2只有日期选择
      
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>博客的好搭档七牛云</title>
    <link href="http://mrdear.cn/2017/09/24/%E8%BF%90%E7%BB%B4/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A5%BD%E6%90%AD%E6%A1%A3%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>http://mrdear.cn/2017/09/24/运维/博客的好搭档七牛云/</id>
    <published>2017-09-24T01:58:10.000Z</published>
    <updated>2017-09-24T01:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客也搭建有一段时间了,期间一些同学来询问如何搭建博客,找了几篇文章让其搭建好了后我却发现大量图片也没他上传到github了,图片本身大,再加上github国内访问并不是很流畅,那么结果就是博客速度的下降,所以分享七牛云就是解决这个问题.</p><hr><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h3><p>七牛云是一个云存储平台,对于个人博客而言他就是一个图床,我们可以把图片等静态资源放在上面,甚至可以把整个博客都放在上面.比如<code>http://oobu4m7ko.bkt.clouddn.com/1506220469.png</code>这张图片就是我上传到七牛云上的,嵌入到markdown中的话展示效果如下:<br><img src="http://oobu4m7ko.bkt.clouddn.com/1506220469.png?imageMogr2/thumbnail/!100p" alt=""></p><p>七牛云允许你对链接加参数来对图片进行一些处理,比如下面这些操作<br><code>http://oobu4m7ko.bkt.clouddn.com/1506220469.png?imageMogr2/thumbnail/!70p</code>,这参数以为等比缩放为70%,对于mac等高分辨屏来说很实用.<br>当然还有缩略,转换,裁剪等功能.详细的可以参考该文档<a href="https://developer.qiniu.com/dora/manual/1279/basic-processing-images-imageview2" target="_blank" rel="noopener">七牛图片处理基本文档</a></p><p>七牛给免费用户提供了每月10GB的流量,足够个人网站的使用了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1506223925.png?imageMogr2/thumbnail/!70p" alt=""></p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用?"></a>怎么用?</h3><p>七牛虽好,但是上传是个麻烦的事情,写作的时候不能还开个浏览器窗口专门上传图片,这个肯定不合理.这样的不合理肯定有好的解决方案,我理想中的方案时复制图片到剪贴板,软件从剪贴板读取,上传,返回指定形式链接到粘贴板.下面推荐一些比较好的开源方案.</p><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>首先注册七牛账号,不介意的话可以走我的邀请链接.</p><blockquote><p><a href="https://portal.qiniu.com/signup?code=3lea5e6tnitsi" target="_blank" rel="noopener">注册七牛云</a></p></blockquote><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><p>对于mac下图床的客户端选择是非常多的,这里首推alfred的workflow,简洁实用.<br><a href="https://github.com/kaito-kidd/markdown-image-alfred" target="_blank" rel="noopener">https://github.com/kaito-kidd/markdown-image-alfred</a></p><blockquote><p>支持复制本地图片获取图片链接<br>支持截图获取图片图片链接<br>支持gif格式<br>操作结果会在通知栏显示</p></blockquote><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>windows下首推mpic这款软件,操作简单,文档清晰,下载后配置下即可使用.<br><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">http://mpic.lzhaofu.cn/</a></p><p>如果你有更好的方案,欢迎分享.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客也搭建有一段时间了,期间一些同学来询问如何搭建博客,找了几篇文章让其搭建好了后我却发现大量图片也没他上传到github了,图片本身大,再加上github国内访问并不是很流畅,那么结果就是博客速度的下降,所以分享七牛云就是解决这个问题.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="运维" scheme="http://mrdear.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="七牛" scheme="http://mrdear.cn/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="图片存储" scheme="http://mrdear.cn/tags/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(三)-强大的collect操作</title>
    <link href="http://mrdear.cn/2017/09/20/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-%E5%BC%BA%E5%A4%A7%E7%9A%84collect%E6%93%8D%E4%BD%9C/"/>
    <id>http://mrdear.cn/2017/09/20/java/Java8学习记录(三)-强大的collect操作/</id>
    <published>2017-09-20T14:59:38.000Z</published>
    <updated>2017-09-20T14:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>collect</code>应该说是<code>Stream</code>中最强大的终端操作了,使用其几乎能得到你想要的任意数据的聚合,下面好好分析该工具的用法.</p><hr><p>在Stream接口中有如下两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line">                 </span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure></p><p>很明显第一种相当于简易实现版本,第二种为高级用法.更多更复杂的操作都封装到Collector接口中,并提供一些静态方法供使用者调用.下面逐一分析.</p><h3 id="简易调用形式"><a href="#简易调用形式" class="headerlink" title="简易调用形式"></a>简易调用形式</h3><p>简易调用形式就是第一种接口,接口如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure></p><p>调用方式如下,很明显第一个参数<code>supplier</code>为结果存放容器,第二个参数<code>accumulator</code>为结果如何添加到容器的操作,第三个参数<code>combiner</code>则为多个容器的聚合策略.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String concat = stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append,StringBuilder::append).toString();</span><br><span class="line"><span class="comment">//等价于上面,这样看起来应该更加清晰</span></span><br><span class="line">String concat = stringStream.collect(() -&gt; <span class="keyword">new</span> StringBuilder(),(l, x) -&gt; l.append(x), (r1, r2) -&gt; r1.append(r2)).toString();</span><br></pre></td></tr></table></figure></p><p>那么换一种,我想对一个List<integer>收集结果总和,按照Collect的要求,首先需要容器sum,然后添加操作 sum+x,聚合操作,sum1+sum2,那么就很容易写出来了,看完下面代码后好好体会下,然后再看高级用法.当然用sum方法收集是最佳解决方案,这里只是提供一种示例应用.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于基本类型都是不可变类型,所以这里用数组当做容器</span></span><br><span class="line"><span class="keyword">final</span> Integer[] integers = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(() -&gt; <span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>&#125;, (a, x) -&gt; a[<span class="number">0</span>] += x, (a1, a2) -&gt; a1[<span class="number">0</span>] += a2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></integer></p><p>那么再换一种,有一个<code>Person</code>类,其拥有type与name两个属性,那么使用<code>collect</code>把他收集到Map集合中,其中键为type,值为person的集合.如下代码所示,看明白了相信就掌握了该方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lists.&lt;Person&gt;newArrayList().stream()</span><br><span class="line">     .collect(() -&gt; <span class="keyword">new</span> HashMap&lt;Integer,List&lt;Person&gt;&gt;(),</span><br><span class="line">         (h, x) -&gt; &#123;</span><br><span class="line">           List&lt;Person&gt; value = h.getOrDefault(x.getType(), Lists.newArrayList());</span><br><span class="line">           value.add(x);</span><br><span class="line">           h.put(x.getType(), value);</span><br><span class="line">         &#125;,</span><br><span class="line">         HashMap::putAll</span><br><span class="line">     );</span><br></pre></td></tr></table></figure></p><h3 id="Collector高级调用"><a href="#Collector高级调用" class="headerlink" title="Collector高级调用"></a>Collector高级调用</h3><p><code>Collector</code>接口是使得<code>collect</code>操作强大的终极武器,对于绝大部分操作可以分解为旗下主要步骤,<strong>提供初始容器-&gt;加入元素到容器-&gt;并发下多容器聚合-&gt;对聚合后结果进行操作</strong>,同时<code>Collector</code>接口又提供了<code>of</code>静态方法帮助你最大化的定制自己的操作,官方也提供了<code>Collectors</code>这个类封装了大部分的常用收集操作.<br>另外<code>CollectorImpl</code>为<code>Collector</code>的实现类,因为接口不可实例化,这里主要完成实例化操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容器</span></span><br><span class="line"> <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//加入到容器操作</span></span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//多容器聚合操作</span></span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//聚合后的结果操作</span></span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//操作中便于优化的状态字段</span></span><br><span class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="Collectors的方法封装"><a href="#Collectors的方法封装" class="headerlink" title="Collectors的方法封装"></a>Collectors的方法封装</h3><p><code>Collectors</code>作为官方提供的收集工具类,那么其很多操作都具有参考性质,能帮助我们更加理解<code>Collector</code>接口,万变不离其宗,最终只是上面五个函数接口的混合操作,下面来分析下官方是如何使用这几个接口的.</p><h4 id="toList"><a href="#toList" class="headerlink" title="toList()"></a>toList()</h4><p>容器: <code>ArrayList::new</code><br>加入容器操作: <code>List::add</code><br>多容器合并: <code>left.addAll(right); return left;</code><br>聚合后的结果操作: 这里直接返回,因此无该操作,默认为<code>castingIdentity()</code><br>优化操作状态字段: <code>CH_ID</code><br>这样看起来很简单,那么对于Map,Set等操作都是类似的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"> Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                CH_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="joining"><a href="#joining" class="headerlink" title="joining()"></a>joining()</h4><p>容器: <code>StringBuilder::new</code><br>加入容器操作: <code>StringBuilder::append</code><br>多容器合并: <code>r1.append(r2); return r1;</code><br>聚合后的结果操作: <code>StringBuilder::toString</code><br>优化操作状态字段: <code>CH_NOID</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来个复杂的</p><h4 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy()"></a>groupingBy()</h4><p><code>groupingBy</code>是<code>toMap</code>的一种高级方式,弥补了<code>toMap</code>对值无法提供多元化的收集操作,比如对于返回<code>Map&lt;T,List&lt;E&gt;&gt;</code>这样的形式<code>toMap</code>就不是那么顺手,那么<code>groupingBy</code>的重点就是对Key和Value值的处理封装.分析如下代码,其中<code>classifier</code>是对key值的处理,<code>mapFactory</code>则是指定Map的容器具体类型,<code>downstream</code>为对Value的收集操作,具体代码这里不做分析,无非是把值一个一个的put进指定容器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</span><br><span class="line"> Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                               Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                               Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    .......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>对于之前用原生<code>collect</code>方法做的收集操作那么就可以很容易改写为groupBy形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生形式</span></span><br><span class="line">   Lists.&lt;Person&gt;newArrayList().stream()</span><br><span class="line">        .collect(() -&gt; <span class="keyword">new</span> HashMap&lt;Integer,List&lt;Person&gt;&gt;(),</span><br><span class="line">            (h, x) -&gt; &#123;</span><br><span class="line">              List&lt;Person&gt; value = h.getOrDefault(x.getType(), Lists.newArrayList());</span><br><span class="line">              value.add(x);</span><br><span class="line">              h.put(x.getType(), value);</span><br><span class="line">            &#125;,</span><br><span class="line">            HashMap::putAll</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//groupBy形式</span></span><br><span class="line">Lists.&lt;Person&gt;newArrayList().stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Person::getType, HashMap::<span class="keyword">new</span>, Collectors.toList()));</span><br><span class="line"><span class="comment">//因为对值有了操作,因此我可以更加灵活的对值进行转换</span></span><br><span class="line">Lists.&lt;Person&gt;newArrayList().stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Person::getType, HashMap::<span class="keyword">new</span>, Collectors.mapping(Person::getName,Collectors.toSet())));</span><br></pre></td></tr></table></figure></p><h4 id="reducing"><a href="#reducing" class="headerlink" title="reducing()"></a>reducing()</h4><p><code>reducing</code>是针对单个值的收集,其返回结果不是集合家族的类型,而是单一的实体类T<br>容器: <code>boxSupplier(identity)</code>,这里包裹用的是一个长度为1的Object[]数组,至于原因自然是不可变类型的锅<br>加入容器操作: <code>a[0] = op.apply(a[0], t)</code><br>多容器合并: <code>a[0] = op.apply(a[0], b[0]); return a;</code><br>聚合后的结果操作: 结果自然是Object[0]所包裹的数据<code>a -&gt; a[0]</code><br>优化操作状态字段: <code>CH_NOID</code><br>那么看到这里困惑是不是有一种恍然大悟的感觉,反正我是有的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, T&gt;</span><br><span class="line">  reducing(T identity, BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">              boxSupplier(identity),</span><br><span class="line">              (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], t); &#125;,</span><br><span class="line">              (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">              a -&gt; a[<span class="number">0</span>],</span><br><span class="line">              CH_NOID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>那么接下来就是对之前Collect的一些操作的改造<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生操作</span></span><br><span class="line"><span class="keyword">final</span> Integer[] integers = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(() -&gt; <span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>&#125;, (a, x) -&gt; a[<span class="number">0</span>] += x, (a1, a2) -&gt; a1[<span class="number">0</span>] += a2[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//reducing操作</span></span><br><span class="line"><span class="keyword">final</span> Integer collect = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.reducing(<span class="number">0</span>, Integer::sum));    </span><br><span class="line"><span class="comment">//当然Stream也提供了reduce操作</span></span><br><span class="line"><span class="keyword">final</span> Integer collect = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .stream().reduce(<span class="number">0</span>, Integer::sum)</span><br></pre></td></tr></table></figure></p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>记录下生产中使用该工具遇到的一些小错误</p><h4 id="toMap所产生的异常"><a href="#toMap所产生的异常" class="headerlink" title="toMap所产生的异常"></a>toMap所产生的异常</h4><p>toMap的操作主要如下代码,异常来自两个方面</p><ol><li>操作调用的是<code>map.merge</code>方法,该方法遇到value为null的情况会报npe,即使你使用的是hashMap可以接受null值,也照样报.搞不懂这里为什么这样设计.</li><li>未指定冲突合并策略,也就是第三个参数<code>BinaryOperator&lt;U&gt; mergeFunction</code>时遇到重复的key会直接抛<code>IllegalStateException</code>,因此需要注意.</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此对于<code>collect</code>的操作应该就很清晰了,希望通过这些例子能掌握核心,也就是<code>Collector</code>接口中那几个函数的作用,希望对你有帮助.</p><blockquote><p>个人博客 <a href="mrdear.cn">mrdear.cn</a> ,欢迎交流</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;collect&lt;/code&gt;应该说是&lt;code&gt;Stream&lt;/code&gt;中最强大的终端操作了,使用其几乎能得到你想要的任意数据的聚合,下面好好分析该工具的用法.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在Stream接口中有如下两个方法&lt;br&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(三)--动态Sql中的参数解析</title>
    <link href="http://mrdear.cn/2017/09/10/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)--%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>http://mrdear.cn/2017/09/10/mybatis/Mybatis源码分析(三)--参数解析/</id>
    <published>2017-09-10T03:45:04.000Z</published>
    <updated>2017-09-10T03:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis中参数解析对于开发人员来说是至关重要的,不然很容易出小问题,举个例子,假设现在方法为,当然这个是很糟糕的写法,这里只是想要搞清楚参数如何解析,项目中万万不可这样写.</p><h3 id="参数输入解析"><a href="#参数输入解析" class="headerlink" title="参数输入解析"></a>参数输入解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//方法</span></span><br><span class="line">   <span class="function">User <span class="title">findUser</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name,<span class="keyword">int</span> age,String email)</span></span><br><span class="line"><span class="function">   <span class="comment">//对应xml</span></span></span><br><span class="line"><span class="function">&lt;select id</span>=<span class="string">"findUser"</span> resultType=<span class="string">"cn.mrdear.users.dao.User"</span>&gt;</span><br><span class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;age&#125; AND email = #&#123;email&#125; </span><br><span class="line">&lt;/select&gt;</span><br><span class="line"><span class="comment">//调用参数</span></span><br><span class="line">   <span class="keyword">final</span> User user = userMapper.findUser(<span class="string">"quding"</span>, <span class="number">18</span>, <span class="string">"qq@mail.com"</span>);</span><br></pre></td></tr></table></figure><p>那么这里Mybatis会怎么解析参数呢?这个xml会构造失败不?首先是<code>MapperMethod</code>中使用<code>ParamNameResolver</code>对输入参数解析,针对上述输入参数会得到下面的结果.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<span class="comment">//获取参数类型,对于上述例子则是String,int,String</span></span><br><span class="line">   <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();<span class="comment">//这里获取到的则是@Param,getParameterAnnotations方法也用到了动态代理.</span></span><br><span class="line">   <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">   <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">   <span class="comment">// get names from @Param annotations</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123; <span class="comment">//过滤其内部一些特殊类型</span></span><br><span class="line">       <span class="comment">// skip special parameters</span></span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     String name = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">       <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">         hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">         name = ((Param) annotation).value();<span class="comment">//获取到'name'值</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// @Param was not specified.</span></span><br><span class="line">       <span class="keyword">if</span> (config.isUseActualParamName()) &#123;<span class="comment">//默认为true,因此编译后参数都是args0,args1之类,因此这里获取的也是args0...</span></span><br><span class="line">         name = getActualParamName(method, paramIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当上面配置为false的时候这里才会使用0,1代替,因此如果未开启则会报错</span></span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// use the parameter index as the name ("0", "1", ...)</span></span><br><span class="line">         <span class="comment">// gcode issue #71</span></span><br><span class="line">         name = String.valueOf(map.size());<span class="comment">//上述都没的话则世界使用map的index.</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     map.put(paramIndex, name);</span><br><span class="line">   &#125;</span><br><span class="line">   names = Collections.unmodifiableSortedMap(map);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>那么执行完毕后对于上述例子,names里面如下图所示,由于<code>config.isUseActualParamName()</code>为true,所以#{0}这种写法这里并不支持,而且也不建议这种写法,无可读性.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504965737.png?imageMogr2/thumbnail/!120p" alt=""><br>接下来执行<code>method.convertArgsToSqlCommandParam(args)</code>获取到实际输入的参数,对于上面例子我获取到的是个Map集合,如下图所示,对于单一实体例如User那么获取到的就是该实体.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505017418.png?imageMogr2/thumbnail/!120p" alt=""><br>再看我所用的sql写法,那么这里只能获取到name的值,sql处理时就会报错.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;age&#125; AND email = #&#123;email&#125;</span><br></pre></td></tr></table></figure></p><p><strong>由此可见针对多参数的输入</strong>,最佳解决方案是用<code>@Param</code>注解,其次为使用Map集合包裹参数,这样的话<code>method.convertArgsToSqlCommandParam(args)</code>得到的则是该Map集合.</p><h3 id="动态sql渲染解析"><a href="#动态sql渲染解析" class="headerlink" title="动态sql渲染解析"></a>动态sql渲染解析</h3><p>上述流程能得到所有的输入参数,那么接下来就是对sql的解析,下面把我们的sql变得复杂一些.(不要讨论sql的意义…这里只是分析参数如何解析)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mapper接口</span></span><br><span class="line">  <span class="function">User <span class="title">findUser</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, @<span class="title">Param</span><span class="params">(<span class="string">"user"</span>)</span> User user,@<span class="title">Param</span><span class="params">(<span class="string">"ids"</span>)</span> List&lt;Long&gt; ids)</span>;</span><br><span class="line"><span class="comment">//xml</span></span><br><span class="line">    &lt;select id=<span class="string">"findUser"</span> resultType=<span class="string">"cn.mrdear.users.dao.User"</span>&gt;</span><br><span class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;user.age&#125; AND email = #&#123;user.email&#125;</span><br><span class="line">OR id in</span><br><span class="line">&lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"item"</span> open=<span class="string">"("</span> close=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">#&#123;item&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>按照上述流程Mybatis解析出来的输入参数如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505020777.png?imageMogr2/thumbnail/!100p" alt=""></p><p>接下进入<code>DefaultSqlSession</code>的处理中,在其中有如下方法会多参数进一步判断,可以看出对于单一参数为<code>Collection</code>或者<code>Array</code>时Mybatis都会给默认命名方案.(这里是在3.3.0之前的版本只会处理List)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</span><br><span class="line">    map.put(<span class="string">"collection"</span>, object);</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">      map.put(<span class="string">"list"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</span><br><span class="line">    map.put(<span class="string">"array"</span>, object);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到了接下来转到执行器,使用<code>DynamicContext</code>构造动态sql所需要的上下文,对其构造函数分析<br>执行到这里的话参数只有三种情况</p><ol><li>null,无任何参数传入</li><li>Map类型，对于多参数,或者参数本身就是map再或者输入单一参数集合类型,数组类型都会转换为map</li><li>单一POJO类型.<br>Mybatis这里要做的就是把参数的各种形式尽可能都放在<code>ContextMap</code>中,该<code>ContextMap</code>是绑定了Ognl的,方便Ognl直接从其中获取到值.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="comment">//对于单个输入数据直接保存在ContentMap中</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//输入参数形式为 _parameter  : parameterObject</span></span><br><span class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://oobu4m7ko.bkt.clouddn.com/1505023031.png?imageMogr2/thumbnail/!70p" alt=""></p><h4 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h4><p>SqlNode是动态Sql解析和完善<code>ContextMap</code>的地方,对于我上述sql会转换为其三个子类,相关解析方法都在其内部.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505027107.png?imageMogr2/thumbnail/!70p" alt=""><br>解析后的sql如下图<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = ? <span class="keyword">AND</span> age = ? <span class="keyword">AND</span> email = ?</span><br><span class="line"><span class="keyword">OR</span> <span class="keyword">id</span> <span class="keyword">in</span> (  ?, ?, ?)</span><br></pre></td></tr></table></figure></p><p>此时<code>ContextMap</code>如下,其中有<code>_frch_item_2</code>这种形式的参数,这是Mybatis对foreach解析后所生成的键,便于填充数据,具体可以看<code>ForeachSqlNode</code><br><img src="http://oobu4m7ko.bkt.clouddn.com/1505027407.png?imageMogr2/thumbnail/!100p" alt=""><br>那么接下来要做的事情就是一一设置进去这些值.</p><h4 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h4><p>顾名思义,其提供<code>void setParameters(PreparedStatement ps)</code>对于sql参数设置的处理.分析下<code>DefaultParameterHandler</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">   ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">   List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">   <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//parameterMappings存储着要设置进去的值类型等信息</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">       ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">       <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">         Object value;</span><br><span class="line">         String propertyName = parameterMapping.getProperty();</span><br><span class="line">         <span class="comment">//AdditionalParameter是从ContextMap中copy到的,其没有的话说明是_parameter里面的值.</span></span><br><span class="line">         <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">           value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">           value = <span class="keyword">null</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">           value = parameterObject;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//获取_parameter里面的值.</span></span><br><span class="line">           MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">           <span class="comment">//其内部是一个递归实现获取.</span></span><br><span class="line">           value = metaObject.getValue(propertyName);</span><br><span class="line">         &#125;</span><br><span class="line">           <span class="comment">//typeHandle的处理</span></span><br><span class="line">         TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">         JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">         <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">           jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>那么看<code>MetaObject</code>的递归获取,递归是针对参数为<code>user.username</code>这样的话会先从<code>_parameter</code>中找到user,然后再调用user 的getUsername()方法获取到结果.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">  <span class="comment">//hasNext判断user.username这种类型</span></span><br><span class="line">  <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">    MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">    <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">      <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么针对上面的例子,这里先是去boundSql中的addtionParameters中获取参数,该参数一般是sql解析时动态生成的,比如foreach生成的_frch_xx,获取不到的话再去原始的ParamsObject中获取,该处的解析为递归形式了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505526788.png?imageMogr2/thumbnail/!70p" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mybatis的SQL解析总体流程如下:</p><ol><li>构造ParamtersMap,保存输入参数.</li><li>构造ContextMap,为OGNL解析提供数据.</li><li>读取xml.使用SqlSource与SqlNode解析xml中的sql,设置参数值到boundSql的addtionParameters中,其为ContextMap的一个副本.</li><li>根据<code>boundSql.parameterMappings</code>获取到参数,从<code>addtionParameters</code>与<code>ParamtersMap</code>中读取参数设置到<code>PreparedStatement</code>中</li><li>执行sql<br>本文只分析了总体流程,其中有很多细节都忽略了,如遇到问题再看也不迟.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mybatis中参数解析对于开发人员来说是至关重要的,不然很容易出小问题,举个例子,假设现在方法为,当然这个是很糟糕的写法,这里只是想要搞清楚参数如何解析,项目中万万不可这样写.&lt;/p&gt;
&lt;h3 id=&quot;参数输入解析&quot;&gt;&lt;a href=&quot;#参数输入解析&quot; class=&quot;he
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(二)--Sqlsession的执行流程</title>
    <link href="http://mrdear.cn/2017/09/09/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)--Sqlsession%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://mrdear.cn/2017/09/09/mybatis/Mybatis源码分析(二)--Sqlsession的执行流程/</id>
    <published>2017-09-09T11:49:52.000Z</published>
    <updated>2017-09-09T11:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇Mapper动态代理中发现Mybatis会对Mapper接口的方法转向<code>mapperMethod.execute(sqlSession, args)</code>,那么该篇就学习Mybatis对于sql的执行总体流程,文章不会涉及很多细节点,重点学习其设计以及这样做的理由.</p><hr><h3 id="SqlCommand"><a href="#SqlCommand" class="headerlink" title="SqlCommand"></a>SqlCommand</h3><p><code>SqlCommand</code>是<code>MapperMethod</code>的一个内部类,其封装着要执行sql的id(xml的namespace+方法名)与类型(select,insert等),这些都是从<code>MappedStatement</code>中获取到,<code>MappedStatement</code>是mybatis初始化读取xml时所构造的对象,具体可以参考之前的文章.对于一个确定的Mapper接口中方法来说这个是确定的值.还有这里有些人认为是命令模式,我认为不是,这里只是该方法对应sql的唯一标识的体现,从下面代码Mybatis对其的使用来看,也不是命令模式具有的行为,而对于命令的执行实际上是<code>sqlSession</code>来执行的,而命令模式的要求是命令中封装委托对象,调用其excute()把任务交给委托执行的对象.<br><strong>Mybatis对sqlCommand的使用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...............</span><br></pre></td></tr></table></figure></p><h3 id="MethodSignature与ParamNameResolver"><a href="#MethodSignature与ParamNameResolver" class="headerlink" title="MethodSignature与ParamNameResolver"></a>MethodSignature与ParamNameResolver</h3><p><code>MethodSignature</code>也是<code>MapperMethod</code>中的一个内部类对象,其封装着该方法的详细信息,比如返回值类型,参数值类型等,分析该类可以得到Mybatis支持的返回类型有集合,Map,游标等各式各样,还支持自定义结果映射器.<br><code>ParamNameResolver</code>是用于方法参数名称解析并重命名的一个类,在Mybatis的xml中使用<code>#{0},#{id}</code>或者注解<code>@Param()</code>等写法都是合法的,为什么合法这个类就是解释,具体的分析过程因为跨度比较长,后面专用一篇文章来分析.</p><h3 id="INSERT-UPDATE-DELETE的结果处理"><a href="#INSERT-UPDATE-DELETE的结果处理" class="headerlink" title="INSERT,UPDATE,DELETE的结果处理"></a>INSERT,UPDATE,DELETE的结果处理</h3><p>对于这三种方法的执行,Mybatis会用<code>rowCountResult()</code>方法包裹结果,从源码中可以很清楚的看出来Mybatis只支持返回void,Integer,Long,Boolean类型的值,<strong>默认是int类型,这里建议数量查询使用int</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object result;</span><br><span class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = (<span class="keyword">long</span>)rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = rowCount &gt; <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() + <span class="string">"' has an unsupported return type: "</span> + method.getReturnType());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Select的处理"><a href="#Select的处理" class="headerlink" title="Select的处理"></a>Select的处理</h3><p>Select是最复杂的处理,其拥有多样的返回值类型,从源码中可以发现Mybatis支持自定义结果映射器,集合返回,Map返回,游标返回以及单条返回.具体该方法是属于哪一种类型在<code>MethodSignature</code>中都有定义,这里不多叙述.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SELECT:</span><br><span class="line">       <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">         executeWithResultHandler(sqlSession, args);</span><br><span class="line">         result = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">         result = executeForMany(sqlSession, args);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">         result = executeForMap(sqlSession, args);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">         result = executeForCursor(sqlSession, args);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">         result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>上述流程之后,SQL的执行就转交给<code>SqlSession</code>,这里会设置参数,去数据库查询,映射结果,可谓是Mybatis的核心.<code>SqlSession</code>下有如下四大对象.</p><ol><li>ParameterHandler: 处理参数设置问题</li><li>ResultHandler: 结果处理</li><li>StatementHandler: 负责连接数据库,执行sql</li><li>Executor: 对上述过程的调度组织.</li></ol><h3 id="Executor的桥接设计模式"><a href="#Executor的桥接设计模式" class="headerlink" title="Executor的桥接设计模式"></a>Executor的桥接设计模式</h3><p><code>Exexutor</code>是一种一对多的模式,所谓的一是对于调用方Client,其任务就是调度执行sql,获取结果返回,所谓的多是其实现可以有多种,比如Mybatis的<code>SimpleExecutor</code>,<code>ReuseExecutor</code>,<code>BatchExecutor</code>其实现这个功能的方式都有些差异,Mybatis在这里的实现就是采用了桥接设计模式,具体结构如下图.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504971925.png?imageMogr2/thumbnail/!100p" alt=""><br><strong>关于桥接模式或者其他设计模式可以参考此链接</strong><a href="https://github.com/me115/design_patterns/blob/master/structural_patterns/bridge.rst" target="_blank" rel="noopener">design_patterns</a><br>因为对于调用方来说只关心接口,因此这里提供<code>Exexutor</code>接口,对于内部多种实现把公共的部分比如缓存处理提取出来作为抽象类<code>BaseExecutor</code>,抽象类具有抽象方法与具体方法,那么最适合作为执行模板.其不同的内容定义为抽象方法,由其子类<code>SimpleExecutor</code>,<code>ReuseExecutor</code>等来实现.这一分支可以视作模板设计模式.<br>另外是一个<code>CachingExecutor</code>,Mybatis会在xml中根据配置<code>cacheEnabled</code>来初始化该类,默认为true,那么该类的作用也就是二级缓存.作为桥接类,其对其他的Executor进行调度,并缓存其结果,解耦接口与实现类之间的联系.</p><p>那么问题就来了</p><ul><li>桥接模式是怎么体现的?<blockquote><p>桥接模式主要是针对接口与实现类的桥接,按理说接口与实现类是属于强耦合的关系,那么使用桥接模式的话就可以去除这种耦合,桥接类中随时可以更换该接口的实现类,比如这里的<code>CacheingExecutor</code>其本身目的是二级缓存,但是二级缓存是针对<code>Executor</code>下的多个实现类,那么这里做下桥接则是一种很优雅的解决方式.</p></blockquote></li><li>二级缓存为什么不用插件形式来实现,反而用桥接模式来实现呢?<blockquote><p>这个问题估计需要我分析完插件设计后才能回答,也可能是其本身设计的问题.占坑.</p></blockquote></li><li><code>BaseExecutor</code>是一种怎样的设计?<blockquote><p>这里是很明显的模板设计,那么这里就要谈对抽象类以及接口的理解,个人认为抽象类与接口的不同之处在于接口定义的是协议,一般对外使用,抽象类定义的是过程,也就是模板,这也是抽象类中非抽象方法与抽象方法共存的优势.</p></blockquote></li></ul><p>除去上述问题,接下来的执行流程是很清晰的<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505400024.png?imageMogr2/thumbnail/!100p" alt=""></p><h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);<span class="comment">//获取sql,此时还都是?占位符状态的sql    </span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); <span class="comment">//获取缓存key,根据id,sql,分页参数计算</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);<span class="comment">//跳到下面方法执行</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//queryStack用于延时加载,暂时未研究,若配置不用缓存,则每次查询前清空一级缓存.</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;</span><br><span class="line">      <span class="comment">//缓存中取出数据,具体会在缓存详解中分析,这里只需要了解具体执行过程</span></span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//针对存储过程更新参数缓存</span></span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//缓存未中则去查数据库</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这边是延迟加载的实现,不在本次分析内容中</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来是DB的查询,DB的查询主要由其子类来实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">//这里先放入缓存中占位符,一级缓存的实现</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用子类的方法处理,模板方法的体现</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放入查询结果缓存,一级缓存的实现</span></span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="comment">//存储过程还需要缓存参数</span></span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p>按照上述模板的执行,<code>SimpleExecutor</code>是真正从数据库查询的地方,这里也能看出来模板设计模式的好处,将缓存处理与实际数据查询分离解耦,各司其职.<br>查询是要经过<code>StatementHandler</code>组织<code>ParameterHandler</code>,<code>ResultHandler</code>的处理过程,那么<code>StatementHandler</code>承担了什么样的角色?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">//创建statement</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">//获取连接,设置参数等预处理</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">//执行查询并映射结果</span></span><br><span class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>…<br>篇幅已经过长了,剩下的<code>StatementHandler</code>等也是类似的设计,不打算再继续分析了,有兴趣的同学可以自己研究一下.接下来会对一些关键点的实现分析,比如sql的解析,延迟加载的实现等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇Mapper动态代理中发现Mybatis会对Mapper接口的方法转向&lt;code&gt;mapperMethod.execute(sqlSession, args)&lt;/code&gt;,那么该篇就学习Mybatis对于sql的执行总体流程,文章不会涉及很多细节点,重点学习其设计以
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(一)--Mapper的动态代理</title>
    <link href="http://mrdear.cn/2017/09/07/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)--Mapper%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://mrdear.cn/2017/09/07/mybatis/Mybatis源码分析(一)--Mapper的动态代理/</id>
    <published>2017-09-07T14:04:05.000Z</published>
    <updated>2017-09-07T14:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中用的最多的就是Mybatis这款半自动ORM框架,用的久却对其了解不是很深,因此打算开一系列文章对其进行解析,顺便对知识进行查漏补缺.本篇是对Mapper动态代理原理的详解.</p><hr><h3 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h3><p>为另一个对象提供一个替身或者占位符以控制对这个对象的访问.也就是说目的是控制对象形式其职责.当然也可以增强其职责,比如Spring AOP.</p><h3 id="代理模式类图"><a href="#代理模式类图" class="headerlink" title="代理模式类图"></a>代理模式类图</h3><p>由下图分析,代理模式所需要的角色为:</p><ol><li>对外的行为接口Subject,对于调用方Client可见</li><li>RealSubject真实的Subject,其包含具体的接口行为,对于Client不可见</li><li>代理类Proxy,其是RealSubject的替身,也可以当成对RealSubject的一层包装,对于Client不可见.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504793889.png?imageMogr2/thumbnail/!150p" alt=""></li></ol><h3 id="JDK动态代理Example"><a href="#JDK动态代理Example" class="headerlink" title="JDK动态代理Example"></a>JDK动态代理Example</h3><p>案例采取Java的动态代理形式开发,按照上述类图定义角色<br><strong>Subject</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反转输入的input字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> input 要反转的串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 反转后的串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">reversalInput</span><span class="params">(String input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>RealSubject</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">reversalInput</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是RealSubject: "</span>+input);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(input).reverse().toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>SubjectProxy</strong><br>该类实现了InvocationHandler,实际上是对调用的拦截,拦截后转向真实对象的调用,从而拿到正确的结果.是不是很像装饰者模式?其实也可以这样理解,设计模式之前本身就有很多关联性,不需要认定某一个行为就是单一的某个模式,从产生效果来看这里的SubjectProxy实际上就是对RealSubject的装饰,只不过这个装饰并没有添加新功能.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"proxy subject is "</span>+proxy.getClass());</span><br><span class="line">    System.out.println(<span class="string">"real subject : "</span>+ToStringBuilder.reflectionToString(target));</span><br><span class="line">    System.out.println(<span class="string">"method: "</span>+method);</span><br><span class="line">    System.out.println(<span class="string">"args: "</span>+ ToStringBuilder.reflectionToString(args));</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RealSubject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">    Subject proxyInstance = (Subject) Proxy.newProxyInstance(</span><br><span class="line">        Subject.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> SubjectProxy(subject));</span><br><span class="line"></span><br><span class="line">    System.out.println(proxyInstance.reversalInput(<span class="string">"hello world"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>输出</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy is class com.sun.proxy.$Proxy0</span><br><span class="line">target proxy: cn.mrdear.proxy.RealSubject@51016012[]</span><br><span class="line">method: public abstract java.lang.String cn.mrdear.proxy.Subject.reversalInput(java.lang.String)</span><br><span class="line">args: [Ljava.lang.Object;@29444d75[&#123;hello world&#125;]</span><br><span class="line">我是RealSubject: hello world</span><br><span class="line">dlrow olleh</span><br></pre></td></tr></table></figure></p><p><strong>分析</strong><br>1.动态代理哪里体现了动态?</p><blockquote><p>对于常规Java类变量创建要求有.java文件,然后编译成.class文件,然后虚拟机加载该.class文件,最后才能生成对象.但是对于<code>Subject proxyInstance</code>该代理类其是不存在.java文件的,也就是该对象的.class文件是动态生成的,然后虚拟机加载该class文件,创建对象.在Proxy.java中有如下代码动态生成class文件,感兴趣的话可以研究研究,这里不多深入.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure></p></blockquote><p>2.JDK动态代理的要求</p><blockquote><p>JDK动态代理只能针对接口,如果要针对普通类则可以考虑CGLib的实现,这里不多分析.其次动态代理的要求有接口类<code>Subject</code>,<code>InvocationHandler</code>代理方法类存在,才能创建出代理对象,代理对象的执行方法都被<code>InvocationHandler</code>接口所拦截,转向真实类的执行或者你想要的操作.</p></blockquote><h3 id="Mybatis的动态Mapper"><a href="#Mybatis的动态Mapper" class="headerlink" title="Mybatis的动态Mapper"></a>Mybatis的动态Mapper</h3><p>由上面内容可以看出JDK动态代理需要接口,真实实现类,Clinet调用方,在常规的Mybatis的Mapper代理中接口就是Mapper,Client是service,那么真实的实现类是什么?显而易见这里就是Mapper代理的关键点.</p><h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><p>顾名思义该类是产生Mapper接口的工厂类,其内部有如下方法,由此可以看出<code>MapperProxy</code>是方法拦截的地方,那么到此动态代理所需要的必须角色都以凑齐,那么接下来分析最重要的<code>MapperProxy</code>方法拦截.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><p>该类是Mapper接口的Proxy角色,继承了<code>InvocationHandler</code>,所以具有方法拦截功能,看代码注释.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123; <span class="comment">//判断是否为Object,是的话则不是mapper接口代理方式</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123; <span class="comment">//判断是否为接口中的默认方法,jdk8允许接口中声明默认方法.</span></span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对正常Mapper请求的处理</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于正常的Mapper接口中的方法调用,mybatis都会转向到<code>MapperMethod</code>的execute方法中执行,拿到结果返回给调用方Client,整个代理过程结束.对于正常调用是有缓存的,并且该代理类是项目启动时就生成好的,对于性能影响并不是很大实用性还是很高的.</p><p>这里要注意下对于默认接口方法的处理<code>invokeDefaultMethod(proxy, method, args)</code>,该方法中每次都直接生成代理类,对性能是一种损耗应该不小,所以<strong>不建议在Mapper接口中写默认方法</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UsesJava</span>7</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class</span><br><span class="line">      .getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</span><br><span class="line">  <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  <span class="keyword">return</span> constructor</span><br><span class="line">      .newInstance(declaringClass,</span><br><span class="line">          MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">              | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</span><br><span class="line">      .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面来看动态代理的最大的好处就是接口(不单指Java的interface,也包括CGLib的动态代理实现)与其实现类的解耦,原本接口和动态类之间是强关联状态,接口不能实例化,实现类必须实现接口的所有方法,有了动态代理之后,接口与实现类的关系并不是很大,甚至不需要实现类就可以完成调用,比如Mybatis这种形式,其并没有创建该接口的实现类,而是用一个方法拦截器转向到自己的通用处理逻辑.<br>另外就是Spring AOP的动态代理,解耦后自然可以实现对原有方法增强的同时又对其代码的零侵入性.<br>最后Mybatis的Mapper动态代理实现原理还是很清晰的,下一篇具体分析<code>MapperMethod</code>,顺便学习Mybatis的各种设计模式.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中用的最多的就是Mybatis这款半自动ORM框架,用的久却对其了解不是很深,因此打算开一系列文章对其进行解析,顺便对知识进行查漏补缺.本篇是对Mapper动态代理原理的详解.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;代理模式定义&quot;&gt;&lt;a href=&quot;#代理模式定义&quot; cla
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
      <category term="设计模式" scheme="http://mrdear.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>cnpm导致IDEA对于Angular项目提示失效</title>
    <link href="http://mrdear.cn/2017/08/26/web/Cnpm%E5%AF%BC%E8%87%B4IDEA%E5%AF%B9%E4%BA%8EAngular%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BA%E5%A4%B1%E6%95%88/"/>
    <id>http://mrdear.cn/2017/08/26/web/Cnpm导致IDEA对于Angular项目提示失效/</id>
    <published>2017-08-26T03:17:15.000Z</published>
    <updated>2017-08-26T03:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写Angular项目的时候,IDEA的提示时而有时而没有,找了好久的原因才发现是cnpm的锅.<br>对于<code>cnpm install</code>,安装的angular依赖时链接方式引入,如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717543.png?imageMogr2/thumbnail/!70p" alt=""></p><p>对于<code>npm install</code>,安装后的依赖时实在的文件,如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717577.png?imageMogr2/thumbnail/!70p" alt=""></p><p>解决方案老老实实的用npm命令,觉得慢的话可以使用http代理,mac下的shadowsocks支持直接导出http代理,复制命令后粘贴到终端,即可实现终端翻墙.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717675.png?imageMogr2/thumbnail/!70p" alt=""></p><p>如果你不会翻墙,可以参考我之前写的教程  <a href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/">如何搭建属于自己的shadowsocks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写Angular项目的时候,IDEA的提示时而有时而没有,找了好久的原因才发现是cnpm的锅.&lt;br&gt;对于&lt;code&gt;cnpm install&lt;/code&gt;,安装的angular依赖时链接方式引入,如下图&lt;br&gt;&lt;img src=&quot;http://oobu4m7ko.bk
      
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
      <category term="idea" scheme="http://mrdear.cn/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>动漫推荐</title>
    <link href="http://mrdear.cn/2017/08/25/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"/>
    <id>http://mrdear.cn/2017/08/25/动漫/动漫推荐/</id>
    <published>2017-08-25T03:26:23.000Z</published>
    <updated>2017-12-24T14:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动漫推荐"><a href="#动漫推荐" class="headerlink" title="动漫推荐"></a>动漫推荐</h1><p>标签（空格分隔）： 动漫</p><hr><p>从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典动漫剧场版.我也不知道自己是什么风格的动漫迷,只是觉得好看,有共鸣就认为是好作品.人们总是把自己喜爱的东西推荐给``别人,我也不例外,下面推荐我认为很不错的片子.(排名不分先后)</p><h2 id="2017-12-24-更新"><a href="#2017-12-24-更新" class="headerlink" title="2017-12-24 更新"></a>2017-12-24 更新</h2><h3 id="我的英雄学院"><a href="#我的英雄学院" class="headerlink" title="我的英雄学院"></a>我的英雄学院</h3><p>补番时发现,不同于一般的热血番,我的英雄学院是一部很纯粹的少年追寻成为一名真正的英雄这一梦想的历程,人物个性很鲜明,故事很带感,配上这突变的画风一不小心就看入了神.<code>所谓英雄就是·····能打破逆境的人啊！</code>这是里面的经典台词,男主虽然表面上懦弱,但是其内心相当强大,为了成为英雄,付出超过别人百倍的努力,不断打破逆境的过程是其向着梦想前进的证明.</p><h2 id="2017-11-26-更新"><a href="#2017-11-26-更新" class="headerlink" title="2017-11-26 更新"></a>2017-11-26 更新</h2><h3 id="剑风传奇三部曲"><a href="#剑风传奇三部曲" class="headerlink" title="剑风传奇三部曲"></a>剑风传奇三部曲</h3><p>剑风传奇三部曲是指其三个剧场版<code>剑风传奇 黄金时代篇1：霸王之卵</code>,<code>剑风传奇 黄金时代篇2：多尔多雷攻略</code>,<code>剑风传奇 黄金时代篇3：降临</code>,三部曲之后是TV版的故事,如果要观看要切记先看未删减的剧场版再看TV版.  剑风传奇是暗黑风格的战争与神话史诗,主角的不屈和坚毅,奋力的对命运进行抗争,坚信自己的道路能让你看的热血沸腾.</p><h3 id="你的名字。"><a href="#你的名字。" class="headerlink" title="你的名字。"></a>你的名字。</h3><p>作为新海诚的粉丝对于其作品无脑推.从星之声中空间的距离到秒速五厘米心灵上的距离再到言叶之庭年龄中的距离,新海诚一直在讲述看似美好但最终无法在一起的爱情.你的名字,讲述了时空上的距离,但是让人感到美好的是有情人终成眷属.另外音乐是真的不错,推荐英文版原声带,网易不给外链我这就只能作罢了.</p><h2 id="2017-08-25-更新"><a href="#2017-08-25-更新" class="headerlink" title="2017-08-25 更新"></a>2017-08-25 更新</h2><h3 id="异邦人-无皇刃谭"><a href="#异邦人-无皇刃谭" class="headerlink" title="异邦人 无皇刃谭"></a>异邦人 无皇刃谭</h3><p>2017年初来在上海实习时看的,故事很温情,对于刚到一个陌生城市打拼的青年来说很容易引起共鸣,也因此我感触颇深,异邦人都是孤独的存在,内心是挣扎的,想要找到自己的归属,然而哪里才是归属?背景音乐很赞,听起来内心有点温暖,但是又会觉得很伤感,充满了无奈</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=508793&auto=0&height=66"></iframe><h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>大概高一的时候第一次看了这个作品,唯美的画面,伤感的故事,再加上年少懵懂的恋爱经历,从此新海诚一生粉.回想以前是不是很多事情都可以 <code>One more time,One more chance</code></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=540978&auto=0&height=66"></iframe><h3 id="你看起来很好吃"><a href="#你看起来很好吃" class="headerlink" title="你看起来很好吃"></a>你看起来很好吃</h3><p>相当有趣的一部动漫,看起来完全没有负重感,从母爱,父爱,独立,自强等方面诠释了一个龙的成长.电影版是温情的结局,萌萌的画面,治愈的故事,给心情带来不一样的体验.<br>记住:哭闹的孩子 不管在哪里都会被霸王龙叼走</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=795251922&auto=0&height=66"></iframe><h3 id="萤火之森"><a href="#萤火之森" class="headerlink" title="萤火之森"></a>萤火之森</h3><p>无法触碰的爱情,只是梦中的憧憬,这样的动漫是提醒你,在你年轻的时候曾经心里也住着一个无法触碰的他/她.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=541381&auto=0&height=66"></iframe><h3 id="fate-stay-night"><a href="#fate-stay-night" class="headerlink" title="fate stay night"></a>fate stay night</h3><p>作为番剧来说最喜欢的一个系列,fate stay night也是最早出来的一部,配乐,战斗,剧情都那么引人入胜,虽然fate zero也非常不错,但是让我来选择的话还是该部更让我难忘.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=448119&auto=0&height=66"></iframe><h3 id="怪物之子"><a href="#怪物之子" class="headerlink" title="怪物之子"></a>怪物之子</h3><p>细田守家族系列电影,复杂成长的环境会造成我们内心的空洞,然而填补这些空洞的方式就是父母的爱,即使在你眼中认为一无是处,半吊子的父亲,在最关键的时候也会奋不顾身的化身为剑去填补你内心的黑暗,细细回想小时候学习父亲的一举一动或许是每个人都无法忘记的时刻.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26315750&auto=0&height=66"></iframe><h3 id="斩·赤红之瞳"><a href="#斩·赤红之瞳" class="headerlink" title="斩·赤红之瞳"></a>斩·赤红之瞳</h3><p>有点虐的番剧,几乎每个角色都是主角的设定,所以每个人角色的个性都很鲜明,也导致了每一个人物死去所带来的感染力.尤其看到结局,最初的一群角色就剩一个赤瞳了,其帮助革命军成立了新国家,然而其还要背负革命军为了革命所做的恶.该番剧有点杀红了眼,所以看的话就要做好心理准备.</p><h3 id="亚人"><a href="#亚人" class="headerlink" title="亚人"></a>亚人</h3><p>这两周把亚人的电影版和TV版都看了一遍,首先电影版绝对是圈钱的作品,还是直接看TV版本吧,剧情一样.整个看下来感觉亚人一部很理性的动漫,无论是主角的处事风格,还是亚人和搜查官的联合,都是利益组建了一个关系网,截止到第二季来说目前还是这样的理性,不知道后期有没有变化.能把不死这一老套的技能演绎出这么多惊心动魄的故事场景的估计也只有亚人了吧.另外这动漫也透漏出政府只是比较大的土匪头子而已.</p><h3 id="犬夜叉剧场版"><a href="#犬夜叉剧场版" class="headerlink" title="犬夜叉剧场版"></a>犬夜叉剧场版</h3><p>犬夜叉是儿时的回忆,尤其是其四个剧场版,小时候最喜欢看<code>天下霸道之剑</code>这一部,犬夜叉相比火影之类动漫的优点是其有一条纠缠的爱情线,犬夜叉与阿离(我喜欢台版的这个翻译),犬夜叉与桔梗这之间复杂但却互相信任的关系.最喜欢的人物莫过于桔梗,其只是想过上普通的生活,然而命运却让其至死也无法得到想要的生活,悲情人物总能引起观看者的同情.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=541131&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动漫推荐&quot;&gt;&lt;a href=&quot;#动漫推荐&quot; class=&quot;headerlink&quot; title=&quot;动漫推荐&quot;&gt;&lt;/a&gt;动漫推荐&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 动漫&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典
      
    
    </summary>
    
      <category term="动漫" scheme="http://mrdear.cn/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://mrdear.cn/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>OpenVZ的VPS加速指南</title>
    <link href="http://mrdear.cn/2017/08/13/%E5%B7%A5%E5%85%B7/OpenVZ%E7%9A%84VPS%E5%8A%A0%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    <id>http://mrdear.cn/2017/08/13/工具/OpenVZ的VPS加速指南/</id>
    <published>2017-08-13T14:39:05.000Z</published>
    <updated>2017-08-13T14:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h3><p>OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较好的方案是Google BBR加速,为了在OpenVZ架构上使用必须借助UML这一子linux系统.</p><p>所谓的UML全称为User Mode Linux,允许用户在Linux中以一个进程的方式再运行一个lInux,那么就很容易实现我们所需要的加速架构,原理是在UML中启动Shadowsocks,然后访问该Shadowsocks实现加速.</p><h3 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h3><p>拿来主义原则,给出原博主链接<a href="https://www.91yun.co/archives/5345" target="_blank" rel="noopener">OpenVZ的UML+BBR加速一键包</a>,按照文章描述步骤配置即可,在这里做一些额外的补充.</p><p><strong>宿主机请求转发</strong><br>一键脚本配置完毕后其是运行在UML主机里面的程序,其内网相对宿主机ip为<code>10.0.0.2</code>,但我们只能访问到宿主机,需要如下命令转发,其中端口<code>8888</code>改成你的ss配置的端口即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i venet0 -p tcp --dport 8888 -j DNAT --to-destination 10.0.0.2</span><br><span class="line">iptables -t nat -A PREROUTING -i venet0 -p udp --dport 8888 -j DNAT --to-destination 10.0.0.2</span><br></pre></td></tr></table></figure><p>接下来像以往一样访问即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现理论&quot;&gt;&lt;a href=&quot;#实现理论&quot; class=&quot;headerlink&quot; title=&quot;实现理论&quot;&gt;&lt;/a&gt;实现理论&lt;/h3&gt;&lt;p&gt;OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较
      
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建属于自己的shadowsocks</title>
    <link href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/"/>
    <id>http://mrdear.cn/2017/08/07/工具/如何搭建属于自己的shadowsocks/</id>
    <published>2017-08-07T15:19:01.000Z</published>
    <updated>2017-08-07T15:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shadowsocks是什么"><a href="#shadowsocks是什么" class="headerlink" title="shadowsocks是什么?"></a>shadowsocks是什么?</h3><p>能看到这篇文章的人大概对这个都有些了解,可以理解为一个代理隧道,通过其可以代理到指定的vps服务器,然后服务器去获取到你所访问的内容再返回给你.<br>如果你把服务器当做跳板机的话,那么shadowsocks就是你与跳板机之间的关联.</p><h3 id="vps服务器的选择"><a href="#vps服务器的选择" class="headerlink" title="vps服务器的选择"></a>vps服务器的选择</h3><p>vps服务器有很多,这里推荐下搬瓦工KVM架构的机器,推荐理由便宜,可靠,支持支付宝.</p><blockquote><p>不介意可以使用我的邀请链接: <a href="https://bandwagonhost.com/aff.php?aff=17639" target="_blank" rel="noopener">https://bandwagonhost.com/aff.php?aff=17639</a></p></blockquote><p>注册后选择最便宜款的KVM架构,重要的事情说三遍,KVM架构,KVM架构,KVM架构.至于好处是可以使用锐速,能让你的shadowsocks更加快.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120173.png?imageMogr2/thumbnail/!70p" alt=""><br>接下来是选择付款方案,一般选择$19.9的年付,三四个小伙伴一起用,平摊这个费用的话,就相当划算了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120257.png?imageMogr2/thumbnail/!70p" alt=""><br>买完后会进去类似的管理后台,选择一键安装即可.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120362.png?imageMogr2/thumbnail/!70p" alt=""><br>到这里,vps服务端的shadowsocks就部署完毕了.接下来是客户端连接.</p><h3 id="shadowsocks客户端"><a href="#shadowsocks客户端" class="headerlink" title="shadowsocks客户端"></a>shadowsocks客户端</h3><p>在github上有各个平台的客户端<a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a>,windows一般用<code>shadowsocks-windows</code>,mac用<code>ShadowsocksX-NG</code>,linux则用<code>shadowsocks-qt5</code>,下载对应客户端,配置好vps生成的shadowsocks端口和密码,启用即可,其主要作为一个本地服务器,其他应用软件通过其余vps服务器通信.</p><p><strong>如何访问?</strong><br>浏览器安装插件<a href="https://switchyomega.com/" target="_blank" rel="noopener">switchyomega</a>,该插件会代理浏览器的请求链接,根据规则列表决定该链接是否要使用shadowsocks代理.<br>首先新建一个代理模式,该模式下所有请求都会走shadowsocks.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120910.png?imageMogr2/thumbnail/!70p" alt=""><br>其次建立一个自动情景切换模式,该模式会根据配置的规则自动选择对应的情景模式来处理.该模式主要分为三部分,第一部分是用户自定义,比如图片中我指定匹配<code>*.github.com</code>的连接走的是ss情景模式.<br>第二部分是规则列表,我配置的为<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>,该文件中是被墙的一些地址,这些地址都走ss情景模式,其余的都是直接连接.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502121104.png?imageMogr2/thumbnail/!70p" alt=""></p><p>接下来就可以访问google了.</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p>锐速安装教程: <a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder</a><br>Google BBR : <a href="https://teddysun.com/489.html" target="_blank" rel="noopener">https://teddysun.com/489.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;shadowsocks是什么&quot;&gt;&lt;a href=&quot;#shadowsocks是什么&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks是什么?&quot;&gt;&lt;/a&gt;shadowsocks是什么?&lt;/h3&gt;&lt;p&gt;能看到这篇文章的人大概对这个都有些了解,
      
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Maven仓库清理脚本</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://mrdear.cn/2017/07/29/工具/maven仓库清理脚本/</id>
    <published>2017-07-29T14:40:15.000Z</published>
    <updated>2017-07-29T14:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.<br>没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.</p><p>附上清理脚本,实际上就是递归遍历文件夹然后判断文件更新时间,对比后决定是否要删除.首次清理后仓库从1.5G变为650M,清爽了不少.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># maven仓库地址</span></span><br><span class="line">mvnHome = <span class="string">"/Users/niuli/.m2/repository"</span></span><br><span class="line"><span class="comment"># 删除该日期前的文件以及文件夹</span></span><br><span class="line">deleteDateBefore = datetime(<span class="number">2017</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listPathAndClean</span><span class="params">(pathContext)</span>:</span></span><br><span class="line">    pathDir = os.listdir(pathContext)</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> pathDir:</span><br><span class="line">        filepath = os.path.join(pathContext, filename)</span><br><span class="line">        currentTimeFile = datetime.fromtimestamp(os.path.getmtime(filepath))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对比时间</span></span><br><span class="line">        <span class="keyword">if</span> deleteDateBefore &gt; currentTimeFile:</span><br><span class="line">            print(<span class="string">"filePath:"</span>+filepath+<span class="string">"-----updatetime:"</span>+str(currentTimeFile))</span><br><span class="line">            print(<span class="string">'delete this'</span>)</span><br><span class="line">            <span class="keyword">if</span> (os.path.isdir(filepath)):</span><br><span class="line">                shutil.rmtree(filepath)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.remove(filepath)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 不到期的则深入遍历</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</span><br><span class="line">            listPathAndClean(filepath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(deleteDateBefore)</span><br><span class="line">    print(<span class="string">'start list should delete path'</span>)</span><br><span class="line">    listPathAndClean(mvnHome)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.&lt;br&gt;没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.&lt;/p&gt;
&lt;p&gt;附上清理脚本,实际上就是递归遍历文件
      
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven子模块打包后拷贝目标文件到父模块</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/Maven%E5%AD%90%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%90%8E%E6%8B%B7%E8%B4%9D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%B0%E7%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>http://mrdear.cn/2017/07/29/工具/Maven子模块打包后拷贝目标文件到父模块/</id>
    <published>2017-07-29T07:15:56.000Z</published>
    <updated>2017-07-29T07:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>看着这个标题一定想怎么会有这么奇怪的需求….<br>嗯,我也认为这个是很奇怪的需求,但实际上确实存在.</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近对公司一个大项目进行整改,该项目是写在一个模块下,也就是一个Maven项目,因此打算把其更改为Maven多模块项目.目录结构的变化如下:<br>原目录结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buy</span><br><span class="line">   ---src</span><br><span class="line">       ---main</span><br><span class="line">       ---test</span><br><span class="line">   ---conf</span><br></pre></td></tr></table></figure></p><p>更改后的为,也就是按照业务分为三个部分,其中gateway是打包的入口,不含有业务逻辑,其引用其他两个模块.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buy</span><br><span class="line">   ---buy-shop</span><br><span class="line">        ---src</span><br><span class="line">        ---main</span><br><span class="line">        ---test</span><br><span class="line">   ---buy-course</span><br><span class="line">        ---src</span><br><span class="line">        ---main</span><br><span class="line">        ---test</span><br><span class="line">   ---buy-gateway</span><br><span class="line">        ---src</span><br><span class="line">        ---main</span><br><span class="line">        ---test</span><br><span class="line">   ---conf</span><br></pre></td></tr></table></figure></p><p>那么自然而然打包后生成的buy.war就到了<code>buy-gateway/target</code>这个目录下,对于<code>master</code>分支的代码是生成在<code>buy/target</code>目录下,这样就倒是线上的自动化打包失效,首先保证master能打包成功就不能更改线上的配置,因此需要把<code>buy-gateway/target/buy.war</code>打包成功后拷贝到<code>buy/target/buy.war</code>,保证线上打包脚本的运行.</p><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案是<code>maven-dependency-plugin</code>这款插件,该插件有copy功能,可以自由选择target目录下的任意文件拷贝(要注意该插件不同版本配置是有差异的,如果一直不成功就要检查下配置)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactItems</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--把target目录下的war拷贝到buy/target下--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactItem</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">type</span>&gt;</span>$&#123;project.packaging&#125;<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">overWrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWrite</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.parent.build.directory&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">destFileName</span>&gt;</span>buy.war<span class="tag">&lt;/<span class="name">destFileName</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">artifactItem</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">artifactItems</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>该模块可以用于各种资源的拷贝,因此不要局限于war包</p><p><strong>备注</strong>:<br>maven中常见的变量 <a href="http://qiaolevip.iteye.com/blog/1816652" target="_blank" rel="noopener">maven常用配置的变量</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看着这个标题一定想怎么会有这么奇怪的需求….&lt;br&gt;嗯,我也认为这个是很奇怪的需求,但实际上确实存在.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近对公司一
      
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>病态的开发模式</title>
    <link href="http://mrdear.cn/2017/07/28/%E9%9A%8F%E8%B0%88/%E7%97%85%E6%80%81%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://mrdear.cn/2017/07/28/随谈/病态的面向对象开发/</id>
    <published>2017-07-28T04:51:50.000Z</published>
    <updated>2017-07-28T04:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对象吗?</p><p>我苦恼于这个问题,不清楚自己做的事情有什么意义,每次需求最重要的部分就是建立表了,然后”重复性”的写各个层次,顶多用点设计模式在service,strategy,factory等之上,这种开发使我产生了厌烦的情绪,我想这个应该不是所谓的面向对象.</p><p>查询一些资料,发现疑惑的不止我一个,我得知<code>贫血模型</code>这一关键词,所谓的贫血模型指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。也就是目前大多数Java项目使用的结构,这样的结构决定了实现之前必须要先设计表结构.那么这和面向对象就没什么关联了.</p><p>与<code>贫血模型</code>相对应,充血模型也就是所谓的面向对象形式,我还没有去用过,不敢枉加主观看法,随着搜索我发现了DDD即领域驱动设计这一充血模型的实现,打算好好看看.</p><p>无论怎么样,我认为Java WEB目前的开发形式是有点小问题的</p><p>希望后续的学习能够解决我的疑问.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对
      
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="面向对象" scheme="http://mrdear.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
