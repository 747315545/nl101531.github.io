<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  <subtitle>change from today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrdear.cn/"/>
  <updated>2017-08-13T15:25:55.000Z</updated>
  <id>http://mrdear.cn/</id>
  
  <author>
    <name>Niu li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenVZ的VPS加速指南</title>
    <link href="http://mrdear.cn/2017/08/13/%E5%B7%A5%E5%85%B7/OpenVZ%E7%9A%84VPS%E5%8A%A0%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    <id>http://mrdear.cn/2017/08/13/工具/OpenVZ的VPS加速指南/</id>
    <published>2017-08-13T14:39:05.000Z</published>
    <updated>2017-08-13T15:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h3><p>OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较好的方案是Google BBR加速,为了在OpenVZ架构上使用必须借助UML这一子linux系统.</p>
<p>所谓的UML全称为User Mode Linux,允许用户在Linux中以一个进程的方式再运行一个lInux,那么就很容易实现我们所需要的加速架构,原理是在UML中启动Shadowsocks,然后访问该Shadowsocks实现加速.</p>
<h3 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h3><p>拿来主义原则,给出原博主链接<a href="https://www.91yun.co/archives/5345" target="_blank" rel="external">OpenVZ的UML+BBR加速一键包</a>,按照文章描述步骤配置即可,在这里做一些额外的补充.</p>
<p><strong>宿主机请求转发</strong><br>一键脚本配置完毕后其是运行在UML主机里面的程序,其内网相对宿主机ip为<code>10.0.0.2</code>,但我们只能访问到宿主机,需要如下命令转发,其中端口<code>8888</code>改成你的ss配置的端口即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -i venet0 -p tcp --dport 8888 -j DNAT --to-destination 10.0.0.2</div><div class="line">iptables -t nat -A PREROUTING -i venet0 -p udp --dport 8888 -j DNAT --to-destination 10.0.0.2</div></pre></td></tr></table></figure>
<p>接下来像以往一样访问即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现理论&quot;&gt;&lt;a href=&quot;#实现理论&quot; class=&quot;headerlink&quot; title=&quot;实现理论&quot;&gt;&lt;/a&gt;实现理论&lt;/h3&gt;&lt;p&gt;OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建属于自己的shadowsocks</title>
    <link href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/"/>
    <id>http://mrdear.cn/2017/08/07/工具/如何搭建属于自己的shadowsocks/</id>
    <published>2017-08-07T15:19:01.000Z</published>
    <updated>2017-08-07T16:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shadowsocks是什么"><a href="#shadowsocks是什么" class="headerlink" title="shadowsocks是什么?"></a>shadowsocks是什么?</h3><p>能看到这篇文章的人大概对这个都有些了解,可以理解为一个代理隧道,通过其可以代理到指定的vps服务器,然后服务器去获取到你所访问的内容再返回给你.<br>如果你把服务器当做跳板机的话,那么shadowsocks就是你与跳板机之间的关联.</p>
<h3 id="vps服务器的选择"><a href="#vps服务器的选择" class="headerlink" title="vps服务器的选择"></a>vps服务器的选择</h3><p>vps服务器有很多,这里推荐下搬瓦工KVM架构的机器,推荐理由便宜,可靠,支持支付宝.</p>
<blockquote>
<p>不介意可以使用我的邀请链接: <a href="https://bandwagonhost.com/aff.php?aff=17639" target="_blank" rel="external">https://bandwagonhost.com/aff.php?aff=17639</a></p>
</blockquote>
<p>注册后选择最便宜款的KVM架构,重要的事情说三遍,KVM架构,KVM架构,KVM架构.至于好处是可以使用锐速,能让你的shadowsocks更加快.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120173.png?imageMogr2/thumbnail/!70p" alt=""><br>接下来是选择付款方案,一般选择$19.9的年付,三四个小伙伴一起用,平摊这个费用的话,就相当划算了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120257.png?imageMogr2/thumbnail/!70p" alt=""><br>买完后会进去类似的管理后台,选择一键安装即可.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120362.png?imageMogr2/thumbnail/!70p" alt=""><br>到这里,vps服务端的shadowsocks就部署完毕了.接下来是客户端连接.</p>
<h3 id="shadowsocks客户端"><a href="#shadowsocks客户端" class="headerlink" title="shadowsocks客户端"></a>shadowsocks客户端</h3><p>在github上有各个平台的客户端<a href="https://github.com/shadowsocks" target="_blank" rel="external">https://github.com/shadowsocks</a>,windows一般用<code>shadowsocks-windows</code>,mac用<code>ShadowsocksX-NG</code>,linux则用<code>shadowsocks-qt5</code>,下载对应客户端,配置好vps生成的shadowsocks端口和密码,启用即可,其主要作为一个本地服务器,其他应用软件通过其余vps服务器通信.</p>
<p><strong>如何访问?</strong><br>浏览器安装插件<a href="https://switchyomega.com/" target="_blank" rel="external">switchyomega</a>,该插件会代理浏览器的请求链接,根据规则列表决定该链接是否要使用shadowsocks代理.<br>首先新建一个代理模式,该模式下所有请求都会走shadowsocks.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120910.png?imageMogr2/thumbnail/!70p" alt=""><br>其次建立一个自动情景切换模式,该模式会根据配置的规则自动选择对应的情景模式来处理.该模式主要分为三部分,第一部分是用户自定义,比如图片中我指定匹配<code>*.github.com</code>的连接走的是ss情景模式.<br>第二部分是规则列表,我配置的为<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>,该文件中是被墙的一些地址,这些地址都走ss情景模式,其余的都是直接连接.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502121104.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>接下来就可以访问google了.</p>
<h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p>锐速安装教程: <a href="https://github.com/91yun/serverspeeder" target="_blank" rel="external">https://github.com/91yun/serverspeeder</a><br>Google BBR : <a href="https://teddysun.com/489.html" target="_blank" rel="external">https://teddysun.com/489.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;shadowsocks是什么&quot;&gt;&lt;a href=&quot;#shadowsocks是什么&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks是什么?&quot;&gt;&lt;/a&gt;shadowsocks是什么?&lt;/h3&gt;&lt;p&gt;能看到这篇文章的人大概对这个都有些了解,
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>maven仓库清理脚本</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://mrdear.cn/2017/07/29/工具/maven仓库清理脚本/</id>
    <published>2017-07-29T14:40:15.000Z</published>
    <updated>2017-07-29T14:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.<br>没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.</p>
<p>附上清理脚本,实际上就是递归遍历文件夹然后判断文件更新时间,对比后决定是否要删除.首次清理后仓库从1.5G变为650M,清爽了不少.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> shutil</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="comment"># maven仓库地址</span></div><div class="line">mvnHome = <span class="string">"/Users/niuli/.m2/repository"</span></div><div class="line"><span class="comment"># 删除该日期前的文件以及文件夹</span></div><div class="line">deleteDateBefore = datetime(<span class="number">2017</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listPathAndClean</span><span class="params">(pathContext)</span>:</span></div><div class="line">    pathDir = os.listdir(pathContext)</div><div class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> pathDir:</div><div class="line">        filepath = os.path.join(pathContext, filename)</div><div class="line">        currentTimeFile = datetime.fromtimestamp(os.path.getmtime(filepath))</div><div class="line"></div><div class="line">        <span class="comment"># 对比时间</span></div><div class="line">        <span class="keyword">if</span> deleteDateBefore &gt; currentTimeFile:</div><div class="line">            print(<span class="string">"filePath:"</span>+filepath+<span class="string">"-----updatetime:"</span>+str(currentTimeFile))</div><div class="line">            print(<span class="string">'delete this'</span>)</div><div class="line">            <span class="keyword">if</span> (os.path.isdir(filepath)):</div><div class="line">                shutil.rmtree(filepath)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                os.remove(filepath)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">            </div><div class="line">        <span class="comment"># 不到期的则深入遍历</span></div><div class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</div><div class="line">            listPathAndClean(filepath)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(deleteDateBefore)</div><div class="line">    print(<span class="string">'start list should delete path'</span>)</div><div class="line">    listPathAndClean(mvnHome)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.&lt;br&gt;没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.&lt;/p&gt;
&lt;p&gt;附上清理脚本,实际上就是递归遍历文件
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven子模块打包后拷贝目标文件到父模块</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/Maven%E5%AD%90%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%90%8E%E6%8B%B7%E8%B4%9D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%B0%E7%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>http://mrdear.cn/2017/07/29/工具/Maven子模块打包后拷贝目标文件到父模块/</id>
    <published>2017-07-29T07:15:56.000Z</published>
    <updated>2017-07-29T07:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>看着这个标题一定想怎么会有这么奇怪的需求….<br>嗯,我也认为这个是很奇怪的需求,但实际上确实存在.</p>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近对公司一个大项目进行整改,该项目是写在一个模块下,也就是一个Maven项目,因此打算把其更改为Maven多模块项目.目录结构的变化如下:<br>原目录结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buy</div><div class="line">   ---src</div><div class="line">       ---main</div><div class="line">       ---test</div><div class="line">   ---conf</div></pre></td></tr></table></figure></p>
<p>更改后的为,也就是按照业务分为三个部分,其中gateway是打包的入口,不含有业务逻辑,其引用其他两个模块.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">buy</div><div class="line">   ---buy-shop</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---buy-course</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---buy-gateway</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---conf</div></pre></td></tr></table></figure></p>
<p>那么自然而然打包后生成的buy.war就到了<code>buy-gateway/target</code>这个目录下,对于<code>master</code>分支的代码是生成在<code>buy/target</code>目录下,这样就倒是线上的自动化打包失效,首先保证master能打包成功就不能更改线上的配置,因此需要把<code>buy-gateway/target/buy.war</code>打包成功后拷贝到<code>buy/target/buy.war</code>,保证线上打包脚本的运行.</p>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案是<code>maven-dependency-plugin</code>这款插件,该插件有copy功能,可以自由选择target目录下的任意文件拷贝(要注意该插件不同版本配置是有差异的,如果一直不成功就要检查下配置)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">artifactItems</span>&gt;</span></div><div class="line">                        <span class="comment">&lt;!--把target目录下的war拷贝到buy/target下--&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">artifactItem</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">type</span>&gt;</span>$&#123;project.packaging&#125;<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">overWrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWrite</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.parent.build.directory&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">destFileName</span>&gt;</span>buy.war<span class="tag">&lt;/<span class="name">destFileName</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">artifactItem</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">artifactItems</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>该模块可以用于各种资源的拷贝,因此不要局限于war包</p>
<p><strong>备注</strong>:<br>maven中常见的变量 <a href="http://qiaolevip.iteye.com/blog/1816652" target="_blank" rel="external">maven常用配置的变量</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看着这个标题一定想怎么会有这么奇怪的需求….&lt;br&gt;嗯,我也认为这个是很奇怪的需求,但实际上确实存在.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近对公司一
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>病态的开发模式</title>
    <link href="http://mrdear.cn/2017/07/28/%E9%9A%8F%E8%B0%88/%E7%97%85%E6%80%81%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://mrdear.cn/2017/07/28/随谈/病态的面向对象开发/</id>
    <published>2017-07-28T04:51:50.000Z</published>
    <updated>2017-07-28T06:06:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对象吗?</p>
<p>我苦恼于这个问题,不清楚自己做的事情有什么意义,每次需求最重要的部分就是建立表了,然后”重复性”的写各个层次,顶多用点设计模式在service,strategy,factory等之上,这种开发使我产生了厌烦的情绪,我想这个应该不是所谓的面向对象.</p>
<p>查询一些资料,发现疑惑的不止我一个,我得知<code>贫血模型</code>这一关键词,所谓的贫血模型指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。也就是目前大多数Java项目使用的结构,这样的结构决定了实现之前必须要先设计表结构.那么这和面向对象就没什么关联了.</p>
<p>与<code>贫血模型</code>相对应,充血模型也就是所谓的面向对象形式,我还没有去用过,不敢枉加主观看法,随着搜索我发现了DDD即领域驱动设计这一充血模型的实现,打算好好看看.</p>
<p>无论怎么样,我认为Java WEB目前的开发形式是有点小问题的</p>
<p>希望后续的学习能够解决我的疑问.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="面向对象" scheme="http://mrdear.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于老项目替换dubbo的一点经验</title>
    <link href="http://mrdear.cn/2017/07/23/dubbo/%E5%85%B3%E4%BA%8E%E8%80%81%E9%A1%B9%E7%9B%AE%E6%9B%BF%E6%8D%A2dubbo%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%8F%E9%AA%8C/"/>
    <id>http://mrdear.cn/2017/07/23/dubbo/关于老项目替换dubbo的一点经验/</id>
    <published>2017-07-23T01:07:41.000Z</published>
    <updated>2017-07-23T01:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司一直以来使用内部编写的一个rpc框架,简称old_rpc这套RPC框架,由于历史原因,old_rpc存在如下缺点.</p>
<ol>
<li>old_rpc已经很久没人维护了,因此出了错误很难定位到具体的原因.</li>
<li>old_rpc本身只是RPC框架,随着项目的增多各个项目之间的依赖关系已经很复杂了,需要一套支持服务治理的解决方案.</li>
<li>old_rpc缺乏监控平台,对于动态部署,增加机器或者减少机器都比较麻烦.</li>
<li>…<br>这些缺点已经严重影响到线上稳定性,本文就dubbox替换掉old_rpc方案做的一个调研,对工作量,替换后的稳定性做一个评估,以供大家参考.</li>
</ol>
<h3 id="替换要求"><a href="#替换要求" class="headerlink" title="替换要求"></a>替换要求</h3><ol>
<li>支持平滑上线,也就是说替换后依然支持现有的测试系统,发布系统.</li>
<li>替换必须尽可能小的缩小对业务的影响,代码层面上来看就是业务处理代码中不应该有替换的代码</li>
<li>短期内需要支持dubbox与old_rpc两套方案,并且两套方案可以快速切换,防止替换后线上出现不可预料的问题.</li>
</ol>
<h3 id="替换思路"><a href="#替换思路" class="headerlink" title="替换思路"></a>替换思路</h3><ol>
<li>saturn作为服务提供者,替换比较简单,只需要在原有基础上,增加dubbo协议的Service.</li>
<li>vienna作为消费者,使用dubbo协议引入dubbo的service</li>
<li>vienna增加断路器配置,对于repo层引入的service,dubbox作为主service,old_rpc作为备份service,当主service调用失败则自动切换到备份service进行重试,此过程需要有监控.</li>
</ol>
<h3 id="dubbox"><a href="#dubbox" class="headerlink" title="dubbox"></a>dubbox</h3><ul>
<li>github: <a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a><br>clone下来后使用<code>mvn package -DskipTests</code>,会打包该项目,生成主要的<strong>dubbo.jar</strong>,以及管理平台<strong>dubbo-admin.war</strong>,监控平台<strong>dubbo-simple-monitor.tar.gz</strong>.我已经把相关jar,deploy到公司的nexus上了.mvn的pom中直接引入如下依赖,这里需要去除Spring依赖,dubbox是基于Spring3开发的,强制引入会与现有项目产生冲突.<br>另外dubbox添加了kryo和FST序列化支持,以及多种新特性,使用的话均需要引入相应的jar,具体参考项目的github.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</div><div class="line">           &lt;version&gt;2.8.4&lt;/version&gt;</div><div class="line">           &lt;exclusions&gt;</div><div class="line">               &lt;exclusion&gt;</div><div class="line">                   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">                   &lt;artifactId&gt;*&lt;/artifactId&gt;</div><div class="line">               &lt;/exclusion&gt;</div><div class="line">           &lt;/exclusions&gt;</div><div class="line">       &lt;/dependency&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="zk注册中心"><a href="#zk注册中心" class="headerlink" title="zk注册中心"></a>zk注册中心</h4><p>dubbo的注册如下所示:<br><img src="http://oobu4m7ko.bkt.clouddn.com/1500736706.png?imageMogr2/thumbnail/!100p" alt=""><br>实际操作下来,第三层还会有<code>routers</code>,<code>configurators</code>节点,当在dubbo-admin平台操作该service时,比如倍权,该操作会存在在这些节点中.</p>
<h4 id="服务提供者saturn"><a href="#服务提供者saturn" class="headerlink" title="服务提供者saturn"></a>服务提供者saturn</h4><p>saturn作为服务提供者,其任务是抛出新的dubbo服务RPC接口.在引入上述pom后,需要做少量的配置.</p>
<h5 id="dubbo基本配置"><a href="#dubbo基本配置" class="headerlink" title="dubbo基本配置"></a>dubbo基本配置</h5><p>因此demo只测试能否实现,每一个配置的详细内容并未研究,详细可以参考官方文档配置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注册中心配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">    registryConfig.setAddress(<span class="string">"115.159.185.14:2181"</span>);</div><div class="line">    registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">    <span class="keyword">return</span> registryConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 当前应用配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">application</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</div><div class="line">    applicationConfig.setName(<span class="string">"saturn"</span>);</div><div class="line">    <span class="keyword">return</span> applicationConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 监控配置,监控需要dubbo-monitor</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MonitorConfig <span class="title">monitorConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    MonitorConfig mc = <span class="keyword">new</span> MonitorConfig();</div><div class="line">    mc.setProtocol(<span class="string">"registry"</span>);</div><div class="line">    <span class="keyword">return</span> mc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 提供者监控服务</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</div><div class="line">    providerConfig.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> providerConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 消费者监控</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReferenceConfig <span class="title">referenceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    ReferenceConfig rc = <span class="keyword">new</span> ReferenceConfig();</div><div class="line">    rc.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * RPC协议配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocol</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</div><div class="line">    protocolConfig.setPort(<span class="number">20880</span>);</div><div class="line">    <span class="keyword">return</span> protocolConfig;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h5><p>服务的提供利用的是<code>ServiceBean</code>包裹,形成该bean的代理类,可以写一个通用的配置函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通用service配置类</div><div class="line"> * <span class="doctag">@param</span> saturnService 对应服务</div><div class="line"> * <span class="doctag">@return</span> dubbo服务</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ServiceBean&lt;T&gt; <span class="title">configService</span><span class="params">(T saturnService)</span> </span>&#123;</div><div class="line">  ServiceBean&lt;T&gt; serviceBean = <span class="keyword">new</span> ServiceBean&lt;&gt;();</div><div class="line">  serviceBean.setProxy(<span class="string">"javassist"</span>);</div><div class="line">  serviceBean.setVersion(<span class="string">"1.0"</span>);</div><div class="line">  serviceBean.setInterface(saturnService.getClass().getInterfaces()[<span class="number">0</span>].getName());</div><div class="line">  serviceBean.setRef(saturnService);</div><div class="line">  serviceBean.setTimeout(<span class="number">2000</span>);</div><div class="line">  serviceBean.setRetries(<span class="number">3</span>);</div><div class="line">  <span class="keyword">return</span> serviceBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我想要抛出IUserService这个服务,只需要如下几行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServiceBean&lt;IUserService&gt; <span class="title">userServiceExport</span><span class="params">(IUserService userService)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> configService(userService);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此提供者配置完毕.</p>
<h4 id="服务消费者vienna-无断路器版本"><a href="#服务消费者vienna-无断路器版本" class="headerlink" title="服务消费者vienna(无断路器版本)"></a>服务消费者vienna(无断路器版本)</h4><p>vienna作为服务消费者与提供者一样也需要基本的dubbo配置,两者配置几乎一模一样.</p>
<h5 id="dubbo基本配置-1"><a href="#dubbo基本配置-1" class="headerlink" title="dubbo基本配置"></a>dubbo基本配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfig</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注册中心</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">    registryConfig.setAddress(<span class="string">"115.159.185.14:2181"</span>);</div><div class="line">    registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">    registryConfig.setTimeout(<span class="number">60000</span>);<span class="comment">// vienna不知道为什么链接zk很慢</span></div><div class="line">    <span class="keyword">return</span> registryConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 应用信息,计算依赖关系</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">application</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</div><div class="line">    applicationConfig.setName(<span class="string">"vienna"</span>);</div><div class="line">    <span class="keyword">return</span> applicationConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 监控中心地址</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MonitorConfig <span class="title">monitorConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    MonitorConfig mc = <span class="keyword">new</span> MonitorConfig();</div><div class="line">    mc.setProtocol(<span class="string">"registry"</span>);</div><div class="line">    <span class="keyword">return</span> mc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 提供者监控服务</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</div><div class="line">    providerConfig.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> providerConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 消费者监控</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReferenceConfig <span class="title">referenceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    ReferenceConfig rc = <span class="keyword">new</span> ReferenceConfig();</div><div class="line">    rc.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 协议配置,自身无提供者的话可以不配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocol</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</div><div class="line">    protocolConfig.setPort(<span class="number">20880</span>);</div><div class="line">    <span class="keyword">return</span> protocolConfig;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="配置消费者"><a href="#配置消费者" class="headerlink" title="配置消费者"></a>配置消费者</h5><p>消费者是用<code>ReferenceBean</code>类来代理的,可以像提供者那样写一个通用的处理方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基本配置类</div><div class="line"> * <span class="doctag">@param</span> serviceReference 接口</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ReferenceBean&lt;T&gt; <span class="title">configReference</span><span class="params">(Class&lt;T&gt; serviceReference)</span> </span>&#123;</div><div class="line">  ReferenceBean&lt;T&gt; ref = <span class="keyword">new</span> ReferenceBean&lt;&gt;();</div><div class="line">  ref.setVersion(<span class="string">"1.0"</span>);</div><div class="line">  ref.setInterface(serviceReference);</div><div class="line">  ref.setTimeout(<span class="number">2000</span>);</div><div class="line">  ref.setRetries(<span class="number">3</span>);</div><div class="line">  ref.setCheck(<span class="keyword">false</span>);</div><div class="line">  ref.setLoadbalance(<span class="string">"roundrobin"</span>);</div><div class="line">  <span class="keyword">return</span> ref;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么引用服务也就只需要几行代码即可,为了更好的与old_rpc服务区分对于dubbo引入的服务都加上dubbo前缀命名.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = <span class="string">"dubboUserService"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ReferenceBean&lt;IUserService&gt; <span class="title">userService</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> configReference(IUserService.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="替换old-rpc"><a href="#替换old-rpc" class="headerlink" title="替换old_rpc"></a>替换old_rpc</h5><p>无断路器版本替换就很简单了,找到引用该服务的地方,在Spring注入时为其选择注入dubbo服务即可.问题是一旦该服务出现了问题,那么需要手动切换回old_rpc服务.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Resource</span></div><div class="line"> <span class="keyword">private</span> IUserService dubboUserService;</div></pre></td></tr></table></figure></p>
<h4 id="服务消费者vienna-断路器版本"><a href="#服务消费者vienna-断路器版本" class="headerlink" title="服务消费者vienna(断路器版本)"></a>服务消费者vienna(断路器版本)</h4><p>断路器本身是做服务降级,防止系统因一个服务出问题而产生雪崩效应,对于当前系统的两套RPC方案可以利用这一点把要替换掉的old_rpc作为降级服务,当dubboService出现异常时可以立即去调取old_rpc的服务,从而保证系统的健壮性.</p>
<h5 id="断路器要求"><a href="#断路器要求" class="headerlink" title="断路器要求"></a>断路器要求</h5><ol>
<li>业务代码无侵入,可以使用方法级别的注解控制该方法是否走断路器.稳定后可以直接删除,不留痕迹.</li>
<li>支持自动熔断,自动恢复</li>
<li>有支持集群的监控服务,方便排查出现问题的服务.</li>
</ol>
<h5 id="断路器依赖"><a href="#断路器依赖" class="headerlink" title="断路器依赖"></a>断路器依赖</h5><p>对于上述要求,符合条件,又经得起生产考验的大概只有hystrix了,github地址为 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a>,pom依赖如下,主要是核心服务包,注解包,监控包.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.12&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.12&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>实现思路与feign对hystrix的包装很相像,以UserRepo为例,UserRepo中引入了userService服务,那么要自动切换则需要两个UserRepo,一个是引用了dubbox的dubboUserService,一个是引用了old_rpc的old_rpcUserService.断路器是方法级别的监控,使用AOP可以轻松地拦截UserRepo中每一个方法的执行,在执行时使用hystrix包装,执行失败时再使用另一个UserRepo重新执行该方法.<br>上述流程有几个要点:</p>
<ol>
<li>需要通过引用dubbo服务的UserRepo获取到引入old_rpc的UserRepo</li>
<li>需要获取到UserRepo中全部的public方法,方便二次调用.</li>
<li>可以从UserRepo中得到断路器的配置,比如分组,线程池等信息.</li>
</ol>
<h5 id="增强Repo功能"><a href="#增强Repo功能" class="headerlink" title="增强Repo功能"></a>增强Repo功能</h5><p>上述的几个要点需要在UserRepo中附加的功能使用一个接口来抽象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDubboRepoProxy</span> <span class="keyword">extends</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取使用dubbo服务调用的Repo</div><div class="line">   */</div><div class="line">  <span class="function">IDubboRepoProxy <span class="title">getDubboRepo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取当前类所有的public方法</div><div class="line">   * <span class="doctag">@return</span> 键与值都是该方法</div><div class="line">   */</div><div class="line">  <span class="function">Map&lt;Method, Method&gt; <span class="title">getAllPublicMethods</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 得到断路器的配置</div><div class="line">   */</div><div class="line">  HystrixCommand.<span class="function">Setter <span class="title">getHystrixSetter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了让实现类更少的写代码,再为其定义一个抽象类,该抽象类主要负责接口功能的实现,其中<code>initOtherRepo</code>作为抽象方法,需要子类来实现,也就是初始化备份的Repo.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRepoProxyImpl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDubboRepoProxy</span>&gt; <span class="keyword">implements</span> <span class="title">IDubboRepoProxy</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Getter</span></div><div class="line">  <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">  <span class="meta">@Setter</span></div><div class="line">  <span class="keyword">private</span> T otherRepo;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Map&lt;Method, Method&gt; publicMethodMap = Maps.newHashMap();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> HystrixCommand.Setter setter;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> IDubboRepoProxy <span class="title">getDubboRepo</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> otherRepo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, Method&gt; <span class="title">getAllPublicMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> publicMethodMap;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">getHystrixSetter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> setter;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//init repo</span></div><div class="line">    initOtherRepo();</div><div class="line">    <span class="comment">//init method</span></div><div class="line">    Class&lt;? extends IDubboRepoProxy&gt; old_rpcClass = <span class="keyword">this</span>.otherRepo.getClass();</div><div class="line">    <span class="keyword">for</span> (Method method : old_rpcClass.getDeclaredMethods()) &#123;</div><div class="line">      publicMethodMap.put(method, method);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//init setter</span></div><div class="line">    setter = HystrixCommand.Setter</div><div class="line">        .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="keyword">this</span>.getClass().getName()))</div><div class="line">        .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="keyword">this</span>.getClass().getSimpleName()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initOtherRepo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = applicationContext;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="使用AOP动态切换"><a href="#使用AOP动态切换" class="headerlink" title="使用AOP动态切换"></a>使用AOP动态切换</h5><p>上述接口与抽象类会赋予UserRepo我们想要的功能.接下来就是AOP拦截.因为断路器是方法级别的操作,因此该AOP只拦截方法,为了更好的配置增加一个AOP专用注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该注解修饰的方法会被AOP拦截</span></div><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoDubboAspect &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>然后写具体的拦截器.该拦截器责任就是按部就班的执行之前的思路.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoDubboAspectImpl</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AutoDubboAspectImpl.class);</div><div class="line"></div><div class="line">  <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.duitang.context.dubbo.AutoDubboAspect)"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoDubboAspect</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//环绕通知</span></div><div class="line">  <span class="meta">@Around</span>(<span class="string">"autoDubboAspect()"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">autoCheck</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">//要执行的主repo</span></div><div class="line">    IDubboRepoProxy target = (IDubboRepoProxy) pjp.getTarget();</div><div class="line">    <span class="comment">//备用repo</span></div><div class="line">    IDubboRepoProxy otherRepo = target.getDubboRepo();</div><div class="line">    <span class="comment">//该repo中所有方法</span></div><div class="line">    Map&lt;Method, Method&gt; methods = target.getAllPublicMethods();</div><div class="line">    <span class="comment">//断路器执行</span></div><div class="line">    HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(</div><div class="line">        target.getHystrixSetter()) &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">return</span> pjp.proceed();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</div><div class="line">          <span class="comment">//异常直接抛出</span></div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 备用降级方案</div><div class="line">       */</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</div><div class="line">        logger.error(<span class="string">"start getFallback,this exception is &#123;&#125;"</span>, <span class="keyword">this</span>.getFailedExecutionException());</div><div class="line">        logger.error(<span class="string">"start getFallback"</span>, pjp.getSignature().toLongString());</div><div class="line">        MethodSignature signature = (MethodSignature) pjp.getSignature();</div><div class="line">        <span class="comment">//获取执行方法</span></div><div class="line">        Method method = methods.get(signature.getMethod());</div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//使用备用repo执行该方法</span></div><div class="line">          <span class="keyword">return</span> method.invoke(otherRepo, pjp.getArgs());</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</div><div class="line">          logger.error(<span class="string">"getFallback error,&#123;&#125;"</span>,e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> hystrixCommand.execute();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此准备工作算是结束,下面是真正的替换.</p>
<h5 id="开始替换old-rpc服务"><a href="#开始替换old-rpc服务" class="headerlink" title="开始替换old_rpc服务"></a>开始替换old_rpc服务</h5><p>因为准备的充分,那么替换就变得相当简单了.首先为UserRepo增强功能,也就是继承抽象类<code>DubboRepoProxyImpl</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class UserRepo extends DubboRepoProxyImpl&lt;UserRepo&gt;</div></pre></td></tr></table></figure></p>
<p>然后实现<code>initOtherRepo</code>方法,该方法主要是从Spring容器中获取到old_rpc的服务,然后再初始化一个UserRepo.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initOtherRepo</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != getContext()) &#123;</div><div class="line">     IUserService userService = getContext().getBean(<span class="string">"userService"</span>, IUserService.class);</div><div class="line">     IRelationshipService relationshipService = getContext().getBean(<span class="string">"relationshipService"</span>,</div><div class="line">         IRelationshipService.class);</div><div class="line">     IUserInterestsService userInterestsService = getContext().getBean(<span class="string">"userInterestsService"</span>,</div><div class="line">         IUserInterestsService.class);</div><div class="line">     IFriendRecomendService friendRecomendService = getContext().getBean(<span class="string">"friendRecomendService"</span>,</div><div class="line">         IFriendRecomendService.class);</div><div class="line">     <span class="comment">//备用old_rpc服务</span></div><div class="line">     UserRepo userRepo = <span class="keyword">new</span> UserRepo(userService, <span class="keyword">this</span>.appealAccountService, <span class="keyword">this</span>.datasourceService,</div><div class="line">         relationshipService, <span class="keyword">this</span>.lifeArtistService, userInterestsService, <span class="keyword">this</span>.jedisPersist, friendRecomendService);</div><div class="line">     <span class="keyword">this</span>.setOtherRepo(userRepo);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>最后为想要实现短路功能的方法加上注解.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoDubboAspect</span></div><div class="line"><span class="function"><span class="keyword">public</span> BaseUser <span class="title">findBasicInfo</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="消费者无法从zk中获取提供者信息"><a href="#消费者无法从zk中获取提供者信息" class="headerlink" title="消费者无法从zk中获取提供者信息?"></a>消费者无法从zk中获取提供者信息?</h4><p>这种情况大多数都是因为配置时两方信息不一致导致,可以去dubbo-admin平台检查提供者完整的url,再与日志中消费者引用的url做个比较,定位到问题.</p>
<h4 id="zk连接超时"><a href="#zk连接超时" class="headerlink" title="zk连接超时"></a>zk连接超时</h4><p>zk是我在自己服务器上部署的,在vienna项目中配置了外网地址,在prism环境中启动后总是出现zk连接超时,后来测试要连上zk大概需要20秒左右,索性把超时时间配置为60秒,解决,具体原因未知.</p>
<h4 id="saturn中配置zk注册服务后测试案例无法跑通"><a href="#saturn中配置zk注册服务后测试案例无法跑通" class="headerlink" title="saturn中配置zk注册服务后测试案例无法跑通"></a>saturn中配置zk注册服务后测试案例无法跑通</h4><p>这个问题是我在saturn配置了测试环境的zk,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">  RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">  registryConfig.setAddress(<span class="string">"10.1.4.10:2181"</span>);</div><div class="line">  registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">  <span class="keyword">return</span> registryConfig;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是jenkins打包时,测试案例一直失败,大概要打包10多分钟,问题有点莫名其妙,在测试时避免Spring引入该bean即可解决.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体过程是比较顺利的,下篇再记录dubbo-admin与dubbo-monitor,以及hystrix-dashborad的搭建.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;公司一直以来使用内部编写的一个rpc框架,简称old_rpc这套RPC框架,由于历史原因,old_rpc存在如下缺点.&lt;/p&gt;
&lt;ol&gt;
&lt;
    
    </summary>
    
      <category term="服务治理" scheme="http://mrdear.cn/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
      <category term="dubbo" scheme="http://mrdear.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(四) -- JSON Web Token实践(下)</title>
    <link href="http://mrdear.cn/2017/06/30/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E5%9B%9B)%20--%20JSON%20Web%20Token%E5%AE%9E%E8%B7%B5(%E4%B8%8B)/"/>
    <id>http://mrdear.cn/2017/06/30/spring/Spring Security学习记录(四) -- JSON Web Token实践(下)/</id>
    <published>2017-06-30T10:19:22.000Z</published>
    <updated>2017-07-08T02:20:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>接着上篇的内容,了解了JWT Token后,发现这东西就是一个可信的用户信息存储方式,那么可信的话就可以省去验证这个步骤,只有当需要用户的详细信息时候才会去DB中查询用户的详细信息.那么现在的流程就是<br><code>用户请求 -&gt; Spring Security通过token把tokenUser设置到上下文中 -&gt; Spring Security Token以及权限验证 -&gt; 具体的业务接口 -&gt; 需要详细信息则根据用户id去DB中获取</code><br>那么就会有以下几个问题.</p>
<h4 id="token在什么时候生成"><a href="#token在什么时候生成" class="headerlink" title="token在什么时候生成?"></a>token在什么时候生成?</h4><p>这个在登录接口中生成,登录后token放入用户id,用户权限等基础信息,以供验证使用.</p>
<h4 id="token签名的密钥该使用什么"><a href="#token签名的密钥该使用什么" class="headerlink" title="token签名的密钥该使用什么?"></a>token签名的密钥该使用什么?</h4><p>这个我也不太清楚,写死一个密钥感觉很不安全,我的想法是使用用户的密码的密文作为签名密钥,这样当用户更改密码的时候原token都是失效.<br>这样做有个缺点,用户密码的密文每次获取需要查询DB,势必会造成DB的压力,可以考虑加缓存,但要考虑缓存挂掉的情况下对DB的压力.</p>
<h4 id="token该怎么较少被盗后的损失"><a href="#token该怎么较少被盗后的损失" class="headerlink" title="token该怎么较少被盗后的损失?"></a>token该怎么较少被盗后的损失?</h4><p>token既然被系统认为是可信的信息集合,那么就需要有相应的超时机制,超时机制是为了防止token被盗用后的损失也只能在一段时间内,就和session超时机制是一样的用处.</p>
<h4 id="如何解决SSO"><a href="#如何解决SSO" class="headerlink" title="如何解决SSO?"></a>如何解决SSO?</h4><p>SSO需要借助cookie或者localStorge,把token放在顶级域名中,这样的话子系统都能使用到,也就完成的SSO机制.<br>对于多域名,那要解决的问题就是如何跨域设置cookie了</p>
<h4 id="如何解决CSRF"><a href="#如何解决CSRF" class="headerlink" title="如何解决CSRF?"></a>如何解决CSRF?</h4><p>CSRF产生的原因是对方使用了你的Cookie也就是使用了你的认证信息,那么的话获取token这一步就不能依赖token,所以把cookie存在cookie中,然后请求时放入header中,解析时从header中获取token信息.</p>
<hr>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="JWT签名与验签"><a href="#JWT签名与验签" class="headerlink" title="JWT签名与验签"></a>JWT签名与验签</h4><p>首先POM引入依赖包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接着定义一个简单的用户,用作存储在上下文中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUserDTO</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Long id;</div><div class="line">  <span class="keyword">private</span> String username;</div><div class="line">  <span class="keyword">private</span> String email;</div><div class="line">  <span class="keyword">private</span> String avatar;</div><div class="line">  <span class="keyword">private</span> List&lt;String&gt; roles;</div><div class="line">  <span class="comment">//省略get set</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着实现jwt<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 从用户中创建一个jwt Token</div><div class="line">   * <span class="doctag">@param</span> userDTO 用户</div><div class="line">   * <span class="doctag">@return</span> token</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(TokenUserDTO userDTO)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Jwts.builder()</div><div class="line">        .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + VALIDITY_TIME_MS))</div><div class="line">        .setSubject(userDTO.getUsername())</div><div class="line">        .claim(<span class="string">"id"</span>, userDTO.getId())</div><div class="line">        .claim(<span class="string">"avatar"</span>, userDTO.getAvatar())</div><div class="line">        .claim(<span class="string">"email"</span>, userDTO.getEmail())</div><div class="line">        .claim(<span class="string">"roles"</span>, userDTO.getRoles())</div><div class="line">        .signWith(SignatureAlgorithm.HS256, secret)</div><div class="line">        .compact();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 从token中取出用户</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> TokenUserDTO <span class="title">parse</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">    Claims claims = Jwts.parser()</div><div class="line">        .setSigningKey(secret)</div><div class="line">        .parseClaimsJws(token)</div><div class="line">        .getBody();</div><div class="line">    TokenUserDTO userDTO = <span class="keyword">new</span> TokenUserDTO();</div><div class="line">    userDTO.setId(NumberUtils.toLong(claims.getId()));</div><div class="line">    userDTO.setAvatar(claims.get(<span class="string">"avatar"</span>,String.class));</div><div class="line">    userDTO.setUsername(claims.get(<span class="string">"username"</span>,String.class));</div><div class="line">    userDTO.setEmail(claims.get(<span class="string">"email"</span>,String.class));</div><div class="line">    userDTO.setRoles((List&lt;String&gt;) claims.get(<span class="string">"roles"</span>));</div><div class="line">    <span class="keyword">return</span> userDTO;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Spring-Security过滤"><a href="#Spring-Security过滤" class="headerlink" title="Spring Security过滤"></a>Spring Security过滤</h4><p>上述流程中Spring Security所承担的角色是验证token+保存token解析出来的用户到<code>SecurityContextHolder</code>中,弄清楚角色那么实现就很简单了.看之前的过滤器链,<br>蓝色框内包含跨站攻击检测与用户信息获取校验,因为用的是jwt所以这些都可以省略掉,替换为解析并验证token,然后设置解析后的用户到上下文中.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1499046528.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>首先<code>SecurityContextHolder</code>中存储的是<code>Authentication</code>对象,所以需要在TokenUser基础封装一层认证用户.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Spring Security中存放的认证用户</div><div class="line"> * <span class="doctag">@author</span> Niu Li</div><div class="line"> * <span class="doctag">@since</span> 2017/6/28</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUserAuthentication</span> <span class="keyword">implements</span> <span class="title">Authentication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3730332217518791533L</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> TokenUserDTO userDTO;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Boolean authentication = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TokenUserAuthentication</span><span class="params">(TokenUserDTO userDTO, Boolean authentication)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.userDTO = userDTO;</div><div class="line">    <span class="keyword">this</span>.authentication = authentication;</div><div class="line">  &#125;</div><div class="line">    <span class="comment">//这里的权限是FilterSecurityInterceptor做权限验证使用</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getRoles().stream()</div><div class="line">        .map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getDetails</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getUsername();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> authentication;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.authentication = isAuthenticated;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getUsername();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后实现验签方法,验签是从header中取出相应的token,验签成功后返回一个<code>Authentication</code>的对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 验签</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Authentication&gt; <span class="title">verifyToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String token = request.getHeader(AUTH_HEADER_NAME);</div><div class="line">  <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; !token.isEmpty())&#123;</div><div class="line">    <span class="keyword">final</span> TokenUserDTO user = parse(token.trim());</div><div class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> TokenUserAuthentication(user, <span class="keyword">true</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Optional.empty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后实现验证Token的过滤器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  jwt token验证类,验证成功后设置进去SecurityContext中</div><div class="line"> * <span class="doctag">@author</span> Niu Li</div><div class="line"> * <span class="doctag">@since</span> 2017/6/28</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VerifyTokenFilter</span><span class="params">(JwtTokenUtil jwtTokenUtil)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.jwtTokenUtil = jwtTokenUtil;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Optional&lt;Authentication&gt; authentication = jwtTokenUtil.verifyToken(request);</div><div class="line">      log.debug(<span class="string">"VerifyTokenFilter result: &#123;&#125;"</span>,authentication.orElse(<span class="keyword">null</span>));</div><div class="line">      SecurityContextHolder.getContext().setAuthentication(authentication.orElse(<span class="keyword">null</span>));</div><div class="line">      filterChain.doFilter(request,response);</div><div class="line">    &#125; <span class="keyword">catch</span> (JwtException e) &#123;</div><div class="line">      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</div><div class="line">      <span class="comment">//可以在这里指定重定向还是返回错误接口示例</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置下Spring Security,主要就是关闭一些不用的过滤器,实现自己的验证过滤器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">  <span class="meta">@Resource</span></div><div class="line">  <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 在此配置不过滤的请求</div><div class="line">   */</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//每一个请求对应一个空的filter链,这里一般不要配置过多,</span></div><div class="line">    <span class="comment">// 因为查找处是一个for循环,过多就导致每个请求都需要循环一遍直到找到</span></div><div class="line">    web.ignoring().antMatchers(<span class="string">"/"</span>,<span class="string">"/login"</span>,<span class="string">"/favicon.ico"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 在此配置过滤链</div><div class="line">   */</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    http</div><div class="line">        .authorizeRequests()</div><div class="line">        <span class="comment">//角色定义,Spring Security会在其前面自动加上ROLE_,因此存储权限的时候也要加上ROLE_ADMIN</span></div><div class="line">        .antMatchers(<span class="string">"/detail"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</div><div class="line">        .anyRequest().permitAll().and()</div><div class="line">        <span class="comment">//异常处理,可以再此使用entrypoint来定义错误输出</span></div><div class="line">        .exceptionHandling().and()</div><div class="line">        <span class="comment">//不需要session来控制,所以这里可以去掉</span></div><div class="line">        .securityContext().securityContextRepository(<span class="keyword">new</span> NullSecurityContextRepository()).and()</div><div class="line">        <span class="comment">//开启匿名访问</span></div><div class="line">        .anonymous().and()</div><div class="line">        <span class="comment">//退出登录自己来控制</span></div><div class="line">        .logout().disable()</div><div class="line">        <span class="comment">//因为没用到cookies,所以关闭cookies</span></div><div class="line">        .csrf().disable()</div><div class="line">        <span class="comment">//验证token</span></div><div class="line">        .addFilterBefore(<span class="keyword">new</span> VerifyTokenFilter(jwtTokenUtil),</div><div class="line">            UsernamePasswordAuthenticationFilter.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做的话,验证就需要在相应的代码中,或者对指定链接使用Spring Security的权限验证.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该链接尝试获取登录用户,返回该认证用户的信息,请求该链接需要在header中放入x-authorization: token</div><div class="line"> */</div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/detail"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> TokenUserDTO <span class="title">userDetail</span><span class="params">()</span> </span>&#123;</div><div class="line">  Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</div><div class="line">  <span class="keyword">if</span> (Objects.isNull(authentication)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (TokenUserDTO) authentication.getDetails();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">.antMatchers(<span class="string">"/detail"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>这样的话就实现了jwt验证,SSO问题也就是token传输的问题,使用cookie就可以了,客户端去请求时从cookie中加载token,然后放入到header中,对这里的代码没影响.</p>
<hr>
<blockquote>
<p>github地址: <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;接着上篇的内容,了解了JWT Token后,发现这东西就是一个可信的用户信息存储方式,那么可信的话就可以省去验证这个步骤,只有当需要用户的详
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(三) -- JSON Web Token实践(上)</title>
    <link href="http://mrdear.cn/2017/06/26/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)%20--%20JSON%20Web%20Token%E5%AE%9E%E8%B7%B5(%E4%B8%8A)/"/>
    <id>http://mrdear.cn/2017/06/26/spring/Spring Security学习记录(三) -- JSON Web Token实践(上)/</id>
    <published>2017-06-26T08:36:33.000Z</published>
    <updated>2017-08-08T14:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>JWT实际上与Spring Security没多大关系,本文打算使用Spring Security配合JWT这种方式完成用户的认证和授权.</p>
<hr>
<p>JSON Web Token(JWT),是一个开放安全的行业标准,用于多个系统之间传递安全可靠的信息.关于其解释可以参考博文:<br><a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="external">JSON Web Token - 在Web应用间安全地传递信息</a><br>因为原作者写的很详细,这里就只说下个人认为比较重要的问题.</p>
<h3 id="JWT是什么样子的结构"><a href="#JWT是什么样子的结构" class="headerlink" title="JWT是什么样子的结构?"></a>JWT是什么样子的结构?</h3><p>JSON Web Token说到底也是一串token,其形式分三段,看下图,<strong>红色</strong>的为Header,指定token类型与签名类型,<strong>紫色</strong>的为请求体,存储用户id等关键信息,最后<strong>蓝色</strong>的为签名,保证整个信息的完整性,可靠性.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498469217.png?imageMogr2/thumbnail/!70p" alt=""><br>其中playload中可以</p>
<ul>
<li>iss: 该JWT的签发者</li>
<li>sub: 该JWT所面向的用户</li>
<li>aud: 接收该JWT的一方</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li>iat(issued at): 在什么时候签发的</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
<h3 id="JWT是一个怎样的流程"><a href="#JWT是一个怎样的流程" class="headerlink" title="JWT是一个怎样的流程?"></a>JWT是一个怎样的流程?</h3><ol>
<li>客户端使用账户密码请求登录接口</li>
<li>登录成功后返回JWT</li>
<li>客户端再次请求其他接口时带上JWT</li>
<li>服务端接收到JWT后验证签名的有效性.</li>
</ol>
<h3 id="JWT解决了什么问题"><a href="#JWT解决了什么问题" class="headerlink" title="JWT解决了什么问题?"></a>JWT解决了什么问题?</h3><p><strong>token被劫持</strong><br>一开始理解很容易陷入一个误区,比如有人会问对于JWT来说,jwt被劫持了的话,那么对方就可以伪造请求,这东西怎么能保证安全呢?<br>这里问题是没理解好JWT,JWT解决的是认证与授权的问题,上述劫持或者类似的中间人攻击是JWT不可避免的,也是其他认证与授权方式不可避免的,想避免可以使用HTTPS,或者签发jwt的时候记录下Client的ip地址,这些就和JWT没关系了.</p>
<p><strong>与Session的区别</strong><br>session实际上是基于cookie来传输的,最重要的session信息是存储在服务器的,所以服务器每次可以通过cookie中的sessionId获取到当前会话的用户,对于单台服务器这样做没问题,但是对于多台就涉及到共享session的问题了,而且认证用户的增多,session会占用大量的服务器内存.<br>那么jwt是存储在客户端的,服务器不需要存储jwt,jwt里面有用户id,服务器拿到jwt验证后可以获得用户信息.也就实现了session的功能,但是相比session,jwt是无状态的,其不与任何机器绑定,只要签名秘钥足够的安全就能保证jwt的可靠性.</p>
<h3 id="JWT下服务端认为什么样子的请求是可信的"><a href="#JWT下服务端认为什么样子的请求是可信的" class="headerlink" title="JWT下服务端认为什么样子的请求是可信的?"></a>JWT下服务端认为什么样子的请求是可信的?</h3><p>对于服务端来说,无法确定下一个请求是哪一个用户,哪一个终端发出,所以其需要一些信息定位到该用户或者该机器,对于JWT来说其Playload里面存储着UserId,那么服务端接收到Token后对其进行签名验证,验证成功,则认为其是<strong>可信的</strong>,然后通过UserId从DB或者Cache中查询出来用户信息.</p>
<h3 id="为什么JWT能保证信息传输的安全可靠"><a href="#为什么JWT能保证信息传输的安全可靠" class="headerlink" title="为什么JWT能保证信息传输的安全可靠?"></a>为什么JWT能保证信息传输的安全可靠?</h3><p>比如现在有token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eyJhbGciOiJIUzI1NiJ9.</div><div class="line">eyJleHAiOjE0OTg0ODIxNTQsInN1YiI6InF1ZGluZyIsInVzZXJJZCI6IjEwMzc5NDAxIiwicm9sZSI6ImFkbWluIn0.</div><div class="line">-YFTYJ6FLlIQqD4G3hYcWvYlYE8H9eAA2369WEcJFVY</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Header</div><div class="line">&#123;</div><div class="line">  "alg": "HS256"</div><div class="line">&#125;</div><div class="line">Playload</div><div class="line">&#123;</div><div class="line">  "exp": 1498482154,</div><div class="line">  "sub": "quding",</div><div class="line">  "userId": "10379401",</div><div class="line">  "role": "admin"</div><div class="line">&#125;</div><div class="line">Sign</div><div class="line">YFTYJ6FLlIQqD4G3hYcWvYlYE8H9eAA2369WEcJFVY</div></pre></td></tr></table></figure>
<p>假设我的playload被其他人劫持了,其他人把userId修改为他自己的,比如123456,但是其没有签名的秘钥,所以他就没法生成签名.<br>服务端收到该Token后,会用先Base64解码出来相应的信息,然后重新生成sign,使用该sign与客户端传来的Sign进行对比,一样则证明没被修改,也就是可信的请求,否则拒绝该请求.</p>
<p>下一篇开始实战.</p>
<blockquote>
<p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JWT实际上与Spring Security没多大关系,本文打算使用Spring Security配合JWT这种方式完成用户的认证和授权.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JSON Web Token(JWT),是一个开放安全的行业标准,用于多个系统之间传递安全可靠的信息.关于其解
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(二) -- Spring Security的Filter</title>
    <link href="http://mrdear.cn/2017/06/22/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%20--%20Spring%20Security%E7%9A%84Filter/"/>
    <id>http://mrdear.cn/2017/06/22/spring/Spring Security学习记录(二) -- Spring Security的Filter/</id>
    <published>2017-06-22T14:03:37.000Z</published>
    <updated>2017-08-08T14:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇学习了Spring Security是如何拦截请求,并把请求转向到Filter链的,该篇就主要学习下这些Filter链的节点的作用.</p>
<hr>
<p>下面是之前配置的内容,本文也是对这些内容 的执行分析.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:http-basic</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="1-Filter链的由来"><a href="#1-Filter链的由来" class="headerlink" title="1.Filter链的由来"></a>1.Filter链的由来</h3><p>由上文可知每一个<code>security:http</code>标签实际上对应的是一个<code>SecurityFilterChain</code>的类,也就是一条Filter链,可以通过其http属性指明其作用的URL,否则作用域全部的URL,如下配置,该security:http会产生一个对/login下的所有请求Filter链.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/login/**"</span>&gt;</span></div><div class="line">    ******</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>打个断点可以很清楚的看到该Filter链<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498283386.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h3 id="2-SecurityContextPersistenceFilter"><a href="#2-SecurityContextPersistenceFilter" class="headerlink" title="2.SecurityContextPersistenceFilter"></a>2.SecurityContextPersistenceFilter</h3><p>该类在所有的Filter之前,是从<code>SecurityContextRepository</code>中取出用户认证信息,默认实现类为<code>HttpSessionSecurityContextRepository</code>,其会从Session中取出已认证用户的信息,提高效率,避免每一次请求都要查询用户认证信息.<br>取出之后会放入<code>SecurityContextHolder</code>中,以便其他filter使用,该类使用ThreadLocal存储用户认证信息,保证了线程之间的信息隔离,最后再finally中清除该信息.<br>可以配置http的<code>security-context-repository-ref</code>属性来自己控制获取到已认证用户信息的方式,比如使用redis存储session等.</p>
<h3 id="3-WebAsyncManagerIntegrationFilter"><a href="#3-WebAsyncManagerIntegrationFilter" class="headerlink" title="3.WebAsyncManagerIntegrationFilter"></a>3.WebAsyncManagerIntegrationFilter</h3><p>提供了对securityContext和WebAsyncManager的集成,其会把SecurityContext设置到异步线程中,使其也能获取到用户上下文认证信息.</p>
<h3 id="4-HeaderWriterFilter"><a href="#4-HeaderWriterFilter" class="headerlink" title="4.HeaderWriterFilter"></a>4.HeaderWriterFilter</h3><p>其会往该请求的Header中添加相应的信息,在http标签内部使用<code>security:headers</code>来控制.</p>
<h3 id="5-CsrfFilter"><a href="#5-CsrfFilter" class="headerlink" title="5.CsrfFilter"></a>5.CsrfFilter</h3><p>Csrf,跨站请求伪造,了解不是很深,只知道B网站使用A网站的可信Cookie发起请求,从而完成认证,伪造出正当请求.<br>验证方式是通过客户端传来的token与服务端存储的token进行对比,来判断是否为伪造请求,有兴趣的可以查看源代码研究下.</p>
<h3 id="6-LogoutFilter"><a href="#6-LogoutFilter" class="headerlink" title="6.LogoutFilter"></a>6.LogoutFilter</h3><p>匹配URL,默认为<code>/logout</code>,匹配成功后则用户退出,清除认证信息.</p>
<h3 id="7-UsernamePasswordAuthenticationFilter"><a href="#7-UsernamePasswordAuthenticationFilter" class="headerlink" title="7.UsernamePasswordAuthenticationFilter"></a>7.UsernamePasswordAuthenticationFilter</h3><p>登录认证过滤器,默认是对<code>/login</code>的POST请求进行认证,首先该方法会先调用<code>attemptAuthentication</code>尝试认证获取一个<code>Authentication</code>的认证对象,然后通过<code>sessionStrategy.onAuthentication</code>执行持久化,也就是保存认证信息,转向下一个Filter,最后调用<code>successfulAuthentication</code>执行认证后事件.</p>
<p><strong>attemptAuthentication</strong><br>该方法是认证的主要方法,认证是委托配置的<code>authentication-manager</code>-&gt;<code>authentication-provider</code>进行.<br>比如对于该Demo配置的为如下,则默认使用的manager为<code>ProviderManager</code>,使用的provider为<code>DaoAuthenticationProvider</code>,userDetailService为<code>InMemoryUserDetailsManager</code>也就是从内存中获取用户认证信息,也就是下面xml配置的user与admin信息.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>认证基本流程为<code>UserDeatilService</code>根据用户名获取到认证用户的信息,然后通过<code>UserDetailsChecker.check</code>对用户进行状态校验,最后通过<code>additionalAuthenticationChecks</code>方法对用户进行密码校验成功后完成认证.返回一个认证对象.</p>
<p>都是面向接口编程,所以用户可以很轻松的扩展自己的验证方式.</p>
<h3 id="8-DefaultLoginPageGeneratingFilter"><a href="#8-DefaultLoginPageGeneratingFilter" class="headerlink" title="8.DefaultLoginPageGeneratingFilter"></a>8.DefaultLoginPageGeneratingFilter</h3><p>当请求为登录请求时,生成简单的登录页面返回</p>
<h3 id="9-BasicAuthenticationFilter"><a href="#9-BasicAuthenticationFilter" class="headerlink" title="9.BasicAuthenticationFilter"></a>9.BasicAuthenticationFilter</h3><p>Http Basci认证的支持,该认证会把用户名密码使用base64编码后放入header中传输,如下所示,认证成功后会把用户信息放入<code>SecurityContextHolder</code>中.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</div></pre></td></tr></table></figure></p>
<h3 id="10-RequestCacheAwareFilter"><a href="#10-RequestCacheAwareFilter" class="headerlink" title="10.RequestCacheAwareFilter"></a>10.RequestCacheAwareFilter</h3><p>恢复被打断的请求,具体未研究</p>
<h3 id="11-SecurityContextHolderAwareRequestFilter"><a href="#11-SecurityContextHolderAwareRequestFilter" class="headerlink" title="11.SecurityContextHolderAwareRequestFilter"></a>11.SecurityContextHolderAwareRequestFilter</h3><p>针对Servlet api不同版本做的一些包装</p>
<h3 id="12-AnonymousAuthenticationFilter"><a href="#12-AnonymousAuthenticationFilter" class="headerlink" title="12.AnonymousAuthenticationFilter"></a>12.AnonymousAuthenticationFilter</h3><p>当<code>SecurityContextHolder</code>中认证信息为空,则会创建一个匿名用户存入到<code>SecurityContextHolder</code>中</p>
<h3 id="13-SessionManagementFilter"><a href="#13-SessionManagementFilter" class="headerlink" title="13.SessionManagementFilter"></a>13.SessionManagementFilter</h3><p>与登录认证拦截时作用一样,持久化用户登录信息,可以保存到session中,也可以保存到cookie或者redis中.</p>
<h3 id="14-ExceptionTranslationFilter"><a href="#14-ExceptionTranslationFilter" class="headerlink" title="14.ExceptionTranslationFilter"></a>14.ExceptionTranslationFilter</h3><p>异常拦截,其处在Filter链后部分,只能拦截其后面的节点并且着重处理<code>AuthenticationException</code>与<code>AccessDeniedException</code>两个异常.</p>
<h3 id="15-FilterSecurityInterceptor"><a href="#15-FilterSecurityInterceptor" class="headerlink" title="15.FilterSecurityInterceptor"></a>15.FilterSecurityInterceptor</h3><p>主要是授权验证,方法为<code>beforeInvocation</code>,在其中调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</div><div class="line">				.getAttributes(object);</div></pre></td></tr></table></figure></p>
<p>获取到所配置资源访问的授权信息,对于上述配置,获取到的则为<code>hasRole(&#39;ROLE_USER&#39;)</code>,然后根据<code>SecurityContextHolder</code>中存储的用户信息来决定其是否有权限,没权限则返回403,具体想了解可以关注<code>HttpConfigurationBuilder.createFilterSecurityInterceptor()</code>方法,分析其创建流程加载了哪些数据,或者分析<code>SecurityExpressionOperations</code>的子类,其是权限鉴定的实现方法.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个认证授权流程如下图所示,图是网上盗的<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498318805.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>因为是学习方面,使用的不是很多,如有错误请指出,以防误人子弟.<br>简单来说,作为用户需要关心的地方是</p>
<ol>
<li>登录验证<code>UsernamePasswordAuthenticationFilter</code></li>
<li>访问验证<code>BasicAuthenticationFilter</code></li>
<li>权限验证<code>FilterSecurityInterceptor</code><br>下一篇则讲述利用这三个验证实现JWT验证.</li>
</ol>
<p>关于这些过滤器更详细的内容可参考博客: <a href="http://www.iteye.com/blogs/subjects/spring_security" target="_blank" rel="external">http://www.iteye.com/blogs/subjects/spring_security</a></p>
<blockquote>
<p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇学习了Spring Security是如何拦截请求,并把请求转向到Filter链的,该篇就主要学习下这些Filter链的节点的作用.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是之前配置的内容,本文也是对这些内容 的执行分析.&lt;br&gt;&lt;figure class=&quot;highlight
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(一) -- 初识Spring Security</title>
    <link href="http://mrdear.cn/2017/06/19/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%20--%20Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%20--%20%E5%88%9D%E8%AF%86Spring%20Security/"/>
    <id>http://mrdear.cn/2017/06/19/spring/Spring Security学习记录(一) -- Spring Security学习记录(一) -- 初识Spring Security/</id>
    <published>2017-06-19T06:08:25.000Z</published>
    <updated>2017-08-08T14:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Security是什么"><a href="#Spring-Security是什么" class="headerlink" title="Spring Security是什么?"></a>Spring Security是什么?</h3><p>Spring Security是一套认证授权框架,支持认证模式如<code>HTTP BASIC 认证头 (基于 IETF RFC-based 标准)</code>,<code>HTTP Digest 认证头 ( IETF RFC-based 标准)</code>,<code>Form-based authentication (用于简单的用户界面)</code>,<code>OpenID 认证</code>等,Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制.</p>
<h3 id="使用Spring-Security"><a href="#使用Spring-Security" class="headerlink" title="使用Spring Security"></a>使用Spring Security</h3><p>Spring Security3之后提供了Java Config的配置方式,但是我觉得xml方式比较容易理解其整体结构,所以本文都是基于xml配置的,在github上该项目会提供Java Config方式作为对比.</p>
<h4 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">     &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</div><div class="line"> &lt;/parent&gt;</div><div class="line"></div><div class="line"> &lt;dependencies&gt;</div><div class="line">     &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</div><div class="line">     &lt;/dependency&gt;</div><div class="line">     &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">     &lt;/dependency&gt;</div><div class="line"> &lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>由于使用了Spring Boot,所以需要使用<code>@EnableWebSecurity</code>注解启用Spring Security,并指明其配置文件为classpath下的<code>spring-security.xml</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="meta">@ImportResource</span>(locations = <span class="string">"classpath:spring-security.xml"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><p>在<code>spring-security.xml</code>中引入官方提供的命名空间,然后简单配置下,该配置大概意思是对所有请求的url拦截,必须有User权限的用户才能访问.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</div><div class="line">		http://www.springframework.org/schema/security</div><div class="line">		http://www.springframework.org/schema/security/spring-security.xsd"&gt;</div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">security:http</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:http-basic</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>该页面为Spring Security自动生成的登录页面,当我们访问任何连接都会被重定向到该登录页面,输入<code>user:123456</code>登录后才能有权限访问.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1497854910.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>上述是一个简单的Demo,分析则是从这个Demo深入浅出.<br><strong>1.Spring Security是如何拦截请求的?</strong><br>传统的xml配置都会在web.xml里面配置如下过滤器.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看出入口点就是该类,该类会从Spring容器中读取名称为<code>springSecurityFilterChain</code>的一个Filter实例,从而获取到对应代理的Filter.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);</div><div class="line">	<span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</div><div class="line">		delegate.init(getFilterConfig());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> delegate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在doFilter方法中调用该委托的filter,也就实现的拦截请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeDelegate</span><span class="params">(</span></span></div><div class="line">		Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</div><div class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">	delegate.doFilter(request, response, filterChain);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2. Spring Security拦截请求后是如何处理的?</strong><br>打断点可以发现<code>DelegatingFilterProxy</code>实际上代理的是<code>FilterChainProxy</code>这个类,该类中有<code>private List&lt;SecurityFilterChain&gt; filterChains;</code>全局变量,那么<code>SecurityFilterChain</code>为何物?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityFilterChain</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(HttpServletRequest request)</span></span>;</div><div class="line"></div><div class="line">	<span class="function">List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以判断SecurityFilterChain是一套规则所对应的Filter链集合.再看源码<code>getFilters</code>,该方法会根据规则(也就是配置中的<code>security:http</code>标签)获取一个SecurityFilterChain中的一套对应规则的filter链.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</div><div class="line">		<span class="keyword">if</span> (chain.matches(request)) &#123;</div><div class="line">			<span class="keyword">return</span> chain.getFilters();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后在<code>doFilterInternal</code>方法中创建一个<code>VirtualFilterChain</code>类,调用其<code>doFilter</code>方法.<code>VirtualFilterChain</code>这个类很有意思,该类继承了<code>FilterChain</code>类,那么其就拥有了转交请求到指定filter的能力,另外其还拥有一套filter链<code>List&lt;Filter&gt; additionalFilters;</code>,那么这个类就控制了整个Spring Security的执行流程,那么它是怎么实现的呢?<br>开始我以为是一个循环,然而看了源码才发现自己太low了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      currentPosition++;</div><div class="line">Filter nextFilter = additionalFilters.get(currentPosition - <span class="number">1</span>);</div><div class="line">nextFilter.doFilter(request, response, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p><code>currentPosition</code>与<code>additionalFilters</code>都是全局变量,其在调用filter链的时候每次都把自己本身在<code>doFilter</code>传值过去,每一个Filter链节点执行完毕后再返回<code>VirtualFilterChain</code>的<code>doFilter</code>方法,开启下一个节点执行.其结构如下面代码所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(IAChain chain)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IAClass</span> <span class="keyword">implements</span> <span class="title">IA</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(IAChain chain)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"i am IAClass"</span>);</div><div class="line">      chain.doSomeThing();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">IAChain</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IAChainClass</span> <span class="keyword">implements</span> <span class="title">IAChain</span></span>&#123;</div><div class="line"></div><div class="line">    List&lt;IA&gt; IAChains = <span class="keyword">new</span> ArrayList&lt;IA&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IAChainClass</span><span class="params">()</span> </span>&#123;</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (position == IAChains.size()) &#123;</div><div class="line">        System.out.println(<span class="string">"end"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      IA ia = IAChains.get(position++);</div><div class="line">      ia.doSomeThing(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>当调用<code>iaChainClass.doSomeThing()</code>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i am IAClass</div><div class="line">i am IAClass</div><div class="line">i am IAClass</div><div class="line">end</div></pre></td></tr></table></figure></p>
<hr>
<p>调用链的实现还可以使用继承来实现,每次执行前先执行super()方法.</p>
<blockquote>
<p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
<p>ok,下一章分析具体的Filter链中的节点,探究下Spring Security是如何进行用户认证与权限控制的.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring-Security是什么&quot;&gt;&lt;a href=&quot;#Spring-Security是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring Security是什么?&quot;&gt;&lt;/a&gt;Spring Security是什么?&lt;/h3&gt;&lt;p&gt;Spri
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习记录(二)--服务治理</title>
    <link href="http://mrdear.cn/2017/06/04/spring/Spring%20Cloud%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <id>http://mrdear.cn/2017/06/04/spring/Spring Cloud学习记录(二)--服务治理/</id>
    <published>2017-06-03T22:44:44.000Z</published>
    <updated>2017-06-04T03:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到了<code>网易乐得团队</code>的一篇服务治理文章,很全面,直接贴地址了</p>
<p><a href="http://tech.lede.com/2017/03/15/rd/server/SpringCloud1/" target="_blank" rel="external">Spring Cloud技术分析（1）——服务治理</a><br><a href="http://tech.lede.com/2017/03/29/rd/server/SpringCloud1C/" target="_blank" rel="external">Spring Cloud技术分析（2）—— 服务治理实践</a></p>
<hr>
<p>下面会更新一些实战中遇到的问题</p>
<h3 id="关于配置"><a href="#关于配置" class="headerlink" title="关于配置"></a>关于配置</h3><p>配置主要是查看官方文档,其次再看代码,而代码大多都是AUTOCONFIG等类似的配置类,其本质大多都是注入为Spring Bean,比如我想配置feign所使用的的Httpclient,那么我会发现<code>FeignRibbonClientAutoConfiguration</code>这个类,在其中有如下的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnClass</span>(ApacheHttpClient.class)</div><div class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"feign.httpclient.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">	<span class="keyword">private</span> HttpClient httpClient;</div><div class="line"></div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="meta">@ConditionalOnMissingBean</span>(Client.class)</div><div class="line">	<span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></div><div class="line">			SpringClientFactory clientFactory) &#123;</div><div class="line">		ApacheHttpClient delegate;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.httpClient != <span class="keyword">null</span>) &#123;</div><div class="line">			delegate = <span class="keyword">new</span> ApacheHttpClient(<span class="keyword">this</span>.httpClient);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			delegate = <span class="keyword">new</span> ApacheHttpClient();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么就可以得知首先我需要引入<code>ApacheHttpClient</code>所在的架包,其次配置文件配置<code>feign.httpclient.enabled=true</code>,另外我还可以对<code>httpClient</code>自定义,然后注入到Spring中,那么就会默认使用我注入的这个HTTPClient了,然后打个断点,debug看下是否自动配置成功.</p>
<h3 id="Feign与Ribbon"><a href="#Feign与Ribbon" class="headerlink" title="Feign与Ribbon"></a>Feign与Ribbon</h3><p>Feign中默认开启的负载均衡,至于算法则使用的是Ribbon轮询算法,在<code>LoadBalancerFeignClient</code>中有<code>CachingSpringLoadBalancerFactory</code>则会缓存每一个server-name对应的负载均衡算法实例,这些实例都来自于<code>SpringClientFactory</code>中,根据server-name从中获取,那么意味着要更改对应服务的负载均衡算法只需要在Spring中注入服务名对应的负载均衡实例即可.<br>最好的方式是在配置文件中声明,如下方式指定负载均衡使用随机规则<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server-name:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.WeightedResponseTimeRule</span></div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>Demo地址:<br>Spring Cloud Demo :  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到了&lt;code&gt;网易乐得团队&lt;/code&gt;的一篇服务治理文章,很全面,直接贴地址了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tech.lede.com/2017/03/15/rd/server/SpringCloud1/&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习记录(一)--为什么需要Spring Cloud?</title>
    <link href="http://mrdear.cn/2017/06/03/spring/Spring%20Cloud%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)--%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://mrdear.cn/2017/06/03/spring/Spring Cloud学习记录(一)--为什么需要微服务/</id>
    <published>2017-06-03T00:30:24.000Z</published>
    <updated>2017-06-09T14:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了周立大大关于Spring Cloud的分享<code>itmuch.com</code>,自己做了一些总结,加深自己的理解.</p>
<p> 理解有误,占坑</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了周立大大关于Spring Cloud的分享&lt;code&gt;itmuch.com&lt;/code&gt;,自己做了一些总结,加深自己的理解.&lt;/p&gt;
&lt;p&gt; 理解有误,占坑&lt;/p&gt;

    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>WEB小知识-HTTP请求对+和&amp;的处理</title>
    <link href="http://mrdear.cn/2017/05/22/web/WEB%E5%B0%8F%E7%9F%A5%E8%AF%86-HTTP%E8%AF%B7%E6%B1%82%E5%AF%B9+%E5%92%8C&amp;%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/22/web/WEB小知识-HTTP请求对+和&amp;的处理/</id>
    <published>2017-05-22T14:18:00.000Z</published>
    <updated>2017-05-22T15:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.</p>
<blockquote>
<p>对于<code>+</code>号会被编码为空格<br>对于<code>&amp;</code>也会被编码成空格</p>
</blockquote>
<p>举个例子,需要向服务端提交如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编码后的内容如下,可以发现<code>a+b</code>被转换成了<code>a b</code>导致服务端接收到后编译失败.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include%20%3Ciostream%3E%0A%0Ausing%20namespace%20std;</div><div class="line">%0A%0Aint%20main()%0A%7B%0A%20%20%20%20int%20a,b;</div><div class="line">%0A%20%20%20%20cin%20%3E%3E%20a%20%3E%3E%20b;</div><div class="line">%0A%20%20%20%20cout%20%3C%3C%20a b%20%3C%3C%20endl;</div><div class="line">%0A%20%20%20%20return%200;%0A%7D</div></pre></td></tr></table></figure></p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>使用函数<code>encodeURIComponent()</code>,该函数会把特殊字符都给转义,转义结果如下面所示,可见<code>a+b</code>转换成了<code>a%2Bb</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%<span class="number">23</span>include%<span class="number">20</span>%<span class="number">3</span>Ciostream%<span class="number">3</span>E%<span class="number">0</span>A%<span class="number">0</span>Ausing%<span class="number">20</span>namespace%<span class="number">20</span>std%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">0</span>Aint%<span class="number">20</span>main()%<span class="number">0</span>A%<span class="number">7</span>B%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span><span class="keyword">int</span>%<span class="number">20</span>a%<span class="number">2</span>Cb%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cin%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>a%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>b%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cout%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>a%<span class="number">2</span>Bb%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>endl%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>return%<span class="number">200</span>%<span class="number">3</span>B%<span class="number">0</span>A%<span class="number">7</span>D</div></pre></td></tr></table></figure></p>
<p>服务端需要使用<code>URLDecoder</code>对其进行反转义,该问题到此解决.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1.问题&quot;&gt;&lt;/a&gt;1.问题&lt;/h3&gt;&lt;p&gt;在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.&lt;/p&gt;
&lt;blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="bug" scheme="http://mrdear.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(二)-Stream原理</title>
    <link href="http://mrdear.cn/2017/05/20/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)-Stream%E5%8E%9F%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/20/java/Java8学习记录(二)-Stream原理/</id>
    <published>2017-05-20T11:06:51.000Z</published>
    <updated>2017-07-04T04:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一篇博文,很好的介绍了Stream的原理.本文对其进行一些补充更加详细的讲解.</p>
<blockquote>
<p>作者: 李豪<br>地址: <a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md" target="_blank" rel="external">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md</a></p>
</blockquote>
<p>需求:</p>
<blockquote>
<p>从<code>&quot;张三&quot;,&quot;李四&quot;,&quot;王二&quot;,&quot;张四五&quot;</code>中选出以<code>张</code>开头的名字,然后从再从中选出名字最长的一个,输出其长度.</p>
</blockquote>
<h3 id="1-一种直白的实现"><a href="#1-一种直白的实现" class="headerlink" title="1.一种直白的实现"></a>1.一种直白的实现</h3><p><img src="http://oobu4m7ko.bkt.clouddn.com/1497141037.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p><strong>缺点</strong>:</p>
<ol>
<li>迭代次数过多</li>
<li>频繁产生中间结果,性能无法接受</li>
</ol>
<p><strong>实际想要的效果</strong>:<br>平常的写法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(String str : strings)&#123;</div><div class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">"张"</span>))&#123;<span class="comment">// 1. filter(), 保留以张开头的字符串</span></div><div class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></div><div class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">System.out.println(longest);</div></pre></td></tr></table></figure></p>
<p>Stream的做法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Stream.of(<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王二"</span>,<span class="string">"张四五"</span>)</div><div class="line">      .filter(x -&gt; x.startsWith(<span class="string">"张"</span>))</div><div class="line">      .mapToInt(String::length)</div><div class="line">      .max()</div><div class="line">      .ifPresent(System.out::println);</div></pre></td></tr></table></figure></p>
<h3 id="2-Stream是怎么做到的"><a href="#2-Stream是怎么做到的" class="headerlink" title="2.Stream是怎么做到的?"></a>2.Stream是怎么做到的?</h3><p><strong>Stream的操作分类</strong>:</p>
<p>中间操作:返回一个新的Stream</p>
<pre><code>- 有状态 sorted(),必须等上一步操作完拿到全部元素后才可操作
- 无状态 filter(),该操作的元素不受上一步操作的影响
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream().filter(x -&gt; x.startWith(<span class="string">"张"</span>).map(x -&gt; x.length())</div><div class="line">list.stream().filter(x -&gt; x.startWith(<span class="string">"张"</span>).sorted().map(x -&gt; x.length())</div></pre></td></tr></table></figure>
<p>终端操作:返回结果</p>
<pre><code>- 短路操作findFirst(),找到一个则返回,也就是break当前的循环
- 非短路操作forEach(),遍历全部元素
</code></pre><p>以上操作决定了Stream一定是先构建完毕再执行的特点,也就是延迟执行,当需要结果(终端操作时)开始执行流水线.<br>Stream做到的是对于多次调用合并到一次迭代中处理完所有的调用方式.换句话说就是解决了上述的两个缺点.大概思路是记录下每一步的操作,然后终端操作时对其迭代依次执行每一步的操作,最后再一次循环中处理.</p>
<p><strong>问题</strong>:</p>
<ol>
<li>操作是如何记录下来的?</li>
<li>操作是如何叠加的?</li>
<li>叠加完如何执行的?</li>
<li>执行完如何收集结果的?</li>
</ol>
<hr>
<p>Stream结构示意图:</p>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1497146463.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>示例代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">data.add(<span class="string">"张三"</span>);</div><div class="line">data.add(<span class="string">"李四"</span>);</div><div class="line">data.add(<span class="string">"王三"</span>);</div><div class="line">data.add(<span class="string">"马六"</span>);</div><div class="line"></div><div class="line">data.stream()</div><div class="line">    .filter(x -&gt; x.length() == <span class="number">2</span>)</div><div class="line">    .map(x -&gt; x.replace(<span class="string">"三"</span>,<span class="string">"五"</span>))</div><div class="line">    .sorted()</div><div class="line">    .filter(x -&gt; x.contains(<span class="string">"五"</span>))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h4 id="1-操作是如何记录下来的"><a href="#1-操作是如何记录下来的" class="headerlink" title="1. 操作是如何记录下来的?"></a>1. 操作是如何记录下来的?</h4><ol>
<li>Head记录Stream起始操作</li>
<li>StatelessOp记录中间操作</li>
<li>StatefulOp记录有状态的中间操作<br>这三个操作实例化会指向其父类<code>AbstractPipeline</code>,也就是在<code>AbstractPipeline</code>中建立了双向链表</li>
</ol>
<p>对于Head<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AbstractPipeline(Spliterator&lt;?&gt; source,</div><div class="line">                 <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</div><div class="line">    <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>; <span class="comment">//首操作上一步为null    </span></div><div class="line">    <span class="keyword">this</span>.sourceSpliterator = source; <span class="comment">//数据</span></div><div class="line">    <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>; <span class="comment">//Head操作</span></div><div class="line">    <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</div><div class="line">    <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</div><div class="line">    <span class="keyword">this</span>.depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.parallel = parallel;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于其他Stage:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</div><div class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</div><div class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//双向链表的建立</span></div><div class="line">    previousStage.nextStage = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>.previousStage = previousStage;</div><div class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;        </div><div class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;        </div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</div><div class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</div><div class="line">    <span class="keyword">if</span> (opIsStateful())</div><div class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1499071580.png?imageMogr2/thumbnail/!60p" height="500" align="right"><br>调用过程如此用双向链表串联起来,每一步都得知其上一步与下一步的操作.<br> data.stream()<br> .filter(x -&gt; x.length() == 2)<br> .map(x -&gt; x.replace(“三”,”五”))<br> .sorted()<br> .filter(x -&gt; x.contains(“五”))<br> .forEach(System.out::println);</p>
<hr>
<h4 id="2-操作是如何叠加的"><a href="#2-操作是如何叠加的" class="headerlink" title="2.操作是如何叠加的?"></a>2.操作是如何叠加的?</h4><p><code>Sink&lt;T&gt;</code>接口:</p>
<ol>
<li>void begin(long size),循环开始前调用,通知每个Stage做好准备</li>
<li>void end(),循环结束时调用,依次调用每个Stage的end方法,处理结果</li>
<li>boolean cancellationRequested(),判断是否可以提前结束循环</li>
<li>void accept(T value),每一步的处理</li>
</ol>
<p>其子类之一ChainedReference:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedReference</span>&lt;<span class="title">T</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">implements</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainedReference</span><span class="params">(Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.downstream = Objects.requireNonNull(downstream);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">        downstream.begin(size);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">        downstream.end();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> downstream.cancellationRequested();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例Filter:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(predicate);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</div><div class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">                    downstream.begin(-<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</div><div class="line">                    <span class="comment">//条件成立则传递给下一个操作,也因为如此所以有状态的操作必须放到</span></div><div class="line">                    <span class="comment">//end方法里面</span></div><div class="line">                    <span class="keyword">if</span> (predicate.test(u))</div><div class="line">                        downstream.accept(u);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再例如sorted():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</div><div class="line">    list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">    list.sort(comparator);</div><div class="line">    downstream.begin(list.size());</div><div class="line">    <span class="keyword">if</span> (!cancellationWasRequested) &#123;</div><div class="line">        list.forEach(downstream::accept);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (T t : list) &#123;</div><div class="line">            <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</div><div class="line">            downstream.accept(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    downstream.end();</div><div class="line">    list = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    list.add(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1499071806.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="叠加后如何执行"><a href="#叠加后如何执行" class="headerlink" title="叠加后如何执行?"></a>叠加后如何执行?</h4><p>执行操作是由终端操作来触发的,例如foreach操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</div><div class="line">    <span class="comment">//evaluate就是开关,一旦调用就立即执行整个Stream    </span></div><div class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行前会对操作从末尾到起始反向包裹起来,得到调用链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Sink <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个Sink是终端操作所对应的Sink</span></div><div class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(sink);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</div><div class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1499071772.png?imageMogr2/thumbnail/!70p" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(wrappedSink);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</div><div class="line">        <span class="comment">//依次执行调用链</span></div><div class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</div><div class="line">        spliterator.forEachRemaining(wrappedSink);</div><div class="line">        wrappedSink.end();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        copyIntoWithCancel(wrappedSink, spliterator);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="有状态的中间操作何时执行"><a href="#有状态的中间操作何时执行" class="headerlink" title="有状态的中间操作何时执行?"></a>有状态的中间操作何时执行?</h4><p>例如sorted()操作,其依赖上一次操作的结果集,按照调用链来说结果集必须在accept()调用完才会产生.那也就说明sorted操作需要在end中,然后再重新开启调用链.</p>
<p><strong>sorted的end方法</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">     list.sort(comparator);</div><div class="line">     downstream.begin(list.size());</div><div class="line">     <span class="keyword">if</span> (!cancellationWasRequested) &#123;</div><div class="line">         list.forEach(downstream::accept);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">for</span> (T t : list) &#123;</div><div class="line">             <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</div><div class="line">             downstream.accept(t);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     downstream.end();</div><div class="line">     list = <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>那么就相当于sorted给原有操作断路了一次,然后又重新接上,再次遍历.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1499071708.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="如何收集到结果"><a href="#如何收集到结果" class="headerlink" title="如何收集到结果?"></a>如何收集到结果?</h4><p>foreach是不需要收集到结果的,但是对于collect这样的操作是需要拿到最终end产生的结果.end产生的结果在最后一个Sink中,这样的操作最终都会提供一个取出数据的get方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></div><div class="line">                                    Spliterator&lt;P_IN&gt; spliterator) &#123;</div><div class="line">     <span class="keyword">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如此拿到数据返回</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一篇博文,很好的介绍了Stream的原理.本文对其进行一些补充更加详细的讲解.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: 李豪&lt;br&gt;地址: &lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals/
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(一)-函数式接口</title>
    <link href="http://mrdear.cn/2017/05/18/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://mrdear.cn/2017/05/18/java/Java8学习记录(一)-函数式接口/</id>
    <published>2017-05-18T15:39:11.000Z</published>
    <updated>2017-05-20T10:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>实习前只是粗略的看了下Java8的一些基本语法,但是没有系统的学习过.在使用一段时间后决定系统的对其进行一次分析,加深对Java8函数式编程的理解,提高自己的编码技巧.另外kotlin崛起,感兴趣的朋友尝试下混编也未尝不可.</p>
<hr>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口,对于Java来说就是接口内只有一个公开方法的接口,因为使用lanbda表达式,例如<code>() -&gt; user.getName()</code>对应的调用则可能是<code>func.get()</code>,编译器会根据接口推断所属于的方法,如果有两个则无法推断.Java8提供了很多函数式接口,一般都使用注解<code>@FunctionalInterface</code>声明,有必要了解如下一些函数式接口.</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supplier<t></t></td>
<td>无</td>
<td>T</td>
<td>接收一个T类型的值</td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>T</td>
<td>无</td>
<td>处理一个T类型的值</td>
</tr>
<tr>
<td>BiConsumer<t, u=""></t,></td>
<td>T,U</td>
<td>无</td>
<td>处理T类型和U类型的值</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>T</td>
<td>boolean</td>
<td>处理T类型的值,并返回true或者false.</td>
</tr>
<tr>
<td>ToIntFunction<t></t></td>
<td>T</td>
<td>int</td>
<td>处理T类型的值,并返回int值</td>
</tr>
<tr>
<td>ToLongFunction<t></t></td>
<td>T</td>
<td>long</td>
<td>处理T类型的值,并返回long值</td>
</tr>
<tr>
<td>ToDoubleFunction<t></t></td>
<td>T</td>
<td>double</td>
<td>处理T类型的值,并返回double值</td>
</tr>
<tr>
<td>Function<t, r=""></t,></td>
<td>T</td>
<td>R</td>
<td>处理T类型的值,并返回R类型值</td>
</tr>
<tr>
<td>BiFunction<t, u,="" r=""></t,></td>
<td>T,U</td>
<td>R</td>
<td>处理T类型和U类型的值,并返回R类型值</td>
</tr>
<tr>
<td>BiFunction<t, u,="" r=""></t,></td>
<td>T,U</td>
<td>R</td>
<td>处理T类型和U类型的值,并返回R类型值</td>
</tr>
<tr>
<td>UnaryOperator<t></t></td>
<td>T</td>
<td>T</td>
<td>处理T类型值,并返回T类型值,</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T,T</td>
<td>T</td>
<td>处理T类型值,并返回T类型值</td>
</tr>
</tbody>
</table>
<p>以上的函数每一个代表的都是一种基本的操作,操作之间可以自由组合,所以才有了stream这些灵活的操作.</p>
<h3 id="Stream操作"><a href="#Stream操作" class="headerlink" title="Stream操作"></a>Stream操作</h3><p>Stream的操作是建立在函数式接口的组合上的,最好的学习方法是看Stream接口来学习.下面举一些例子来分析,假设有这样的一些初始数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; testData = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    testData.add(<span class="string">"张三"</span>);</div><div class="line">    testData.add(<span class="string">"李四"</span>);</div><div class="line">    testData.add(<span class="string">"王二"</span>);</div><div class="line">    testData.add(<span class="string">"麻子"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>filter</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div></pre></td></tr></table></figure></p>
<p>filter接收predicate函数,predicate是接收T值,返回boolean值,那么对应的引用就可以写成如下形式,意思是取集合中以’张’开头的名字.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .filter(x -&gt; x.startsWith(<span class="string">"张"</span>))</div></pre></td></tr></table></figure></p>
<p><strong>map</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</div></pre></td></tr></table></figure></p>
<p>map操作接收的是Function接口,对于Function接收T值返回R值,那map的作用就很明显是转换用的,比如下面代码,转换名称为对应的名称长度,也就是从输入String数据返回int数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .map(x -&gt; x.length())</div></pre></td></tr></table></figure></p>
<p><strong>flatMap</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</div></pre></td></tr></table></figure></p>
<p>flatMap和map都是使用Function接口,不同的是返回值flatMap限定为Stream类型.所以flatMap可以作为合并流使用,如以下代码,提取出所有的字符.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">        .collect(Collectors.toList());</div><div class="line">        <span class="comment">//输出  [张, 三, 李, 四, 王, 二, 麻, 子]</span></div></pre></td></tr></table></figure></p>
<p><strong>peek</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div></pre></td></tr></table></figure></p>
<p>peek参数为Consumer,Consumer接收T值,无返回,那么该方法就可以作为调试不影响stream中内容的一些操作,不过由于对象都是地址引用,你再此做一些对象内容操作也是可以的.<br><strong>reduce</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Reduce比较复杂的一个接口,属于归纳性操作,看参数,第一个是U泛型,也就是输入类型的参数,最为初始值,第二个BiFunction,接收T,U参数,返回U类型参数,BinaryOperator接收U,U类型,并返回U类型.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> StringBuilder identity = <span class="keyword">new</span> StringBuilder();</div><div class="line"> StringBuilder reduce = testData.stream()</div><div class="line">     .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">     .reduce(identity, (r, x) -&gt; &#123;</div><div class="line">       r.append(x);</div><div class="line">       <span class="keyword">return</span> r;</div><div class="line">     &#125;, StringBuilder::append);</div><div class="line"> System.out.println(identity == reduce);</div><div class="line"> System.out.println(reduce.toString());</div><div class="line"> <span class="comment">//输出 true</span></div><div class="line"><span class="comment">//  张三李四王二麻子</span></div></pre></td></tr></table></figure></p>
<p>首先提供一个基本容器identity,然后两个参数r即是identity,x为每次输入参数,最后一个StringBuilder::append是并发下多个identity的合并策略.<br>再举个例子,既然reduce属于归纳性操作,那么也可以当成collect使用,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; identity = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   ArrayList&lt;String&gt; result = testData.stream()</div><div class="line">       .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">       .reduce(identity, (r, x) -&gt; &#123;</div><div class="line">         r.add(x);</div><div class="line">         <span class="keyword">return</span> r;</div><div class="line">       &#125;,(r1,r2) -&gt; &#123;</div><div class="line">         r1.addAll(r2);</div><div class="line">         <span class="keyword">return</span> r1;</div><div class="line">       &#125;);</div><div class="line">   System.out.println(identity == result);</div><div class="line">   System.out.println(result);</div><div class="line">   <span class="comment">//输出 true</span></div><div class="line">   <span class="comment">//[张, 三, 李, 四, 王, 二, 麻, 子]</span></div></pre></td></tr></table></figure></p>
<h3 id="强大的collect"><a href="#强大的collect" class="headerlink" title="强大的collect"></a>强大的collect</h3><p>collect无疑是stream中最强大的操作,掌握了collect操作才能说掌握了stream.为了便于使用者,Java提供了<code>Collectors</code>类,该类提供了很多便捷的collect操作,如<code>Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>,<code>Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>等操作.这些操作最终都会调用如下构造函数构造出collector对象,因此掌握该本质是最佳的学习方式.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CollectorImpl(Supplier&lt;A&gt; supplier,</div><div class="line">                      BiConsumer&lt;A, T&gt; accumulator,</div><div class="line">                      BinaryOperator&lt;A&gt; combiner,</div><div class="line">                      Function&lt;A,R&gt; finisher,</div><div class="line">                      Set&lt;Characteristics&gt; characteristics) &#123;</div><div class="line">            <span class="keyword">this</span>.supplier = supplier;</div><div class="line">            <span class="keyword">this</span>.accumulator = accumulator;</div><div class="line">            <span class="keyword">this</span>.combiner = combiner;</div><div class="line">            <span class="keyword">this</span>.finisher = finisher;</div><div class="line">            <span class="keyword">this</span>.characteristics = characteristics;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>Supplier类似reduce中的u,接收一个元数据,BiConsumer则是操作数据,BinaryOperator并发下聚合,finisher完成时的转换操作,Set<characteristics>应该按照定义是优化一些操作中的转换.如下面的toList()操作,其finish操作为<code>castingIdentity()</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"> Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</div><div class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</div><div class="line">                                CH_ID);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></characteristics></p>
<p>再看toMap的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;</div><div class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</div><div class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</div><div class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</div><div class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</div><div class="line">    BiConsumer&lt;M, T&gt; accumulator</div><div class="line">            = (map, element) -&gt; map.merge(keyMapper.apply(element),</div><div class="line">                                          valueMapper.apply(element), mergeFunction);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Function作为转换函数提供了key和value的转换,BinaryOperator提供了重复key合并策略,mapSupplier则表示最终收集到的容器.那么使用就很简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Character, String&gt; map = testData.stream()</div><div class="line">        .collect(Collectors.toMap(x -&gt; x.charAt(<span class="number">0</span>), Function.identity()</div><div class="line">            , (v1, v2) -&gt; v2, HashMap::<span class="keyword">new</span>));</div></pre></td></tr></table></figure></p>
<p>其他还有很多方法,就不一一叙述,主要是了解这些接口,知道他所拥有的功能,以及组合的意义,即可很好的掌握Java中的函数式编程.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习前只是粗略的看了下Java8的一些基本语法,但是没有系统的学习过.在使用一段时间后决定系统的对其进行一次分析,加深对Java8函数式编程的理解,提高自己的编码技巧.另外kotlin崛起,感兴趣的朋友尝试下混编也未尝不可.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;函数式接口&quot;&gt;
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java中序列化相关知识</title>
    <link href="http://mrdear.cn/2017/05/02/%E5%B7%A5%E5%85%B7/Java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://mrdear.cn/2017/05/02/工具/Java中的序列化相关知识/</id>
    <published>2017-05-02T08:00:00.000Z</published>
    <updated>2017-05-07T13:13:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天线上遇到了DTO类实现了<code>Serializable</code>接口,但是其并没有显示声明<code>serialVersionUID</code>,这样的话每次打包有改动JDK就会为其重新生成<code>serialVersionUID</code>.这就带来了不同版本之间的实体类可能反序列化不成功,线上RPC调用出现了问题.那么就深入探讨一下原因.</p>
<h3 id="Serializable的作用"><a href="#Serializable的作用" class="headerlink" title="Serializable的作用"></a>Serializable的作用</h3><p>看该类的JDK注释可以发现<code>The serialization interface has no methods or fields and serves only to identify the semantics of being serializable.</code>也就是说Serializable是一个标识接口,和<code>Cloneable</code>接口等一样的效果.<br>如下面的User类,实现了序列化接口,并使用<code>serialVersionUID</code>标识其序列化对应的ID序号.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5768430629641297769L</span>;</div><div class="line">  <span class="keyword">private</span> String nickname;</div><div class="line">  <span class="keyword">private</span> String passwd;</div><div class="line">  <span class="comment">//省略get和set</span></div></pre></td></tr></table></figure></p>
<h3 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h3><p><code>java.io.ObjectOutputStream</code>代表对象输出流,其使用writeObject()方法把对象实例转换为字节流然后写入到文件,或者用于网络传输.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  User userDO = <span class="keyword">new</span> User();</div><div class="line">  userDO.setNickname(<span class="string">"屈定"</span>);</div><div class="line">  userDO.setPasswd(<span class="string">"123456"</span>);</div><div class="line">  File file = <span class="keyword">new</span> File(<span class="string">"user.out"</span>);</div><div class="line">  ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">  outputStream.writeObject(userDO);<span class="comment">//序列化写入到文件中.</span></div><div class="line">  outputStream.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何反序列化"><a href="#如何反序列化" class="headerlink" title="如何反序列化"></a>如何反序列化</h3><p><code>java.io.ObjectInputStream</code>代表对象输入流,其使用readObject()方法读取序列化的字节,然后再转换为对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">  File file = <span class="keyword">new</span> File(base+File.separator+<span class="string">"user.out"</span>);</div><div class="line">  ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">  User user = (User) inputStream.readObject();</div><div class="line">  Assert.assertTrue(StringUtils.equals(user.getNickname(),<span class="string">"屈定"</span>));</div><div class="line">  Assert.assertTrue(StringUtils.equals(user.getPasswd(),<span class="string">"123456"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h3><p>按照上面代码,序列化和反序列化都是成功的,如果在已经序列化后,对User要作修改,增加一个email字段,再试试反序列化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5768430629641297769L</span>;</div><div class="line">    <span class="keyword">private</span> String nickname;</div><div class="line">    <span class="keyword">private</span> String passwd;</div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序会正常运行,而且这个email会被很智能的初始化为null.<br>修改<code>serialVersionUID</code>为1L再试试.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.io.InvalidClassException: cn.edu.aust.test.ObjectTest$User; local class incompatible: stream classdesc serialVersionUID = 5768430629641297769, local class serialVersionUID = 1</div></pre></td></tr></table></figure></p>
<p>报错很明显,两边类的<code>serialVersionUID</code>不一样,也就是说对于编译好的class,其<code>serialVersionUID</code>是其序列化的唯一标识,如果未显示声明JDK则会自动为其加上,可以使用命令<code>seriserialver</code>可以查看一个class文件的<code>serialVersionUID</code>,当线上版本忘记加该字段的时候该命令还是很有用处的.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">seriserialver cn.edu.aust.test.ObjectTest\<span class="variable">$User</span> </div><div class="line">cn.edu.aust.test.ObjectTest<span class="variable">$User</span>:    private static final long serialVersionUID = 1L;</div></pre></td></tr></table></figure></p>
<h3 id="transient的作用"><a href="#transient的作用" class="headerlink" title="transient的作用"></a>transient的作用</h3><p>transient翻译为瞬时,也就是被其修饰的变量序列化时会忽略该字段.什么时候需要用到这个字段呢?<br>在Java中对象之间的关系会组成一个对象图,序列化的过程是对该对象图的遍历,那么反序列化也仍然是对该对象图的遍历.对于对象里面的对象就是递归过程,对于链表之类的数据结构递归的话很容易引起栈溢出,那么就可以使用<code>transient</code>忽略该字段.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天线上遇到了DTO类实现了&lt;code&gt;Serializable&lt;/code&gt;接口,但是其并没有显示声明&lt;code&gt;serialVersionUID&lt;/code&gt;,这样的话每次打包有改动JDK就会为其重新生成&lt;code&gt;serialVersionUID&lt;/code&gt;.这就带
    
    </summary>
    
      <category term="工作问题" scheme="http://mrdear.cn/categories/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="jdk" scheme="http://mrdear.cn/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>对一个WEB请求的理解</title>
    <link href="http://mrdear.cn/2017/04/30/%E8%BF%90%E7%BB%B4/%E5%AF%B9%E4%B8%80%E4%B8%AAWEB%E8%AF%B7%E6%B1%82%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://mrdear.cn/2017/04/30/运维/对一个WEB请求的理解/</id>
    <published>2017-04-29T16:00:00.000Z</published>
    <updated>2017-05-06T01:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着写的WEB程序越来越多,项目的部署也越来越繁琐,对于一些线上问题总是搞不清楚是哪个环节出的问题,归根结底是对整个流程的不熟悉导致,所以分析下一个WEB请求从用户输入地址到页面出来到底经历过多少东西.</p>
<h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><p>首先把URL分割为几个部分,以地址<code>http://mrdear.cn/2017/04/15/动漫推荐/</code>为例<br>协议: http<br>网址: mrdear.cn<br>资源路径: 2017/04/15/动漫推荐/</p>
<p>浏览器拿到地址后会对其中非ASCII码的Unicode字符解析,比如空格会变成%20,汉字也会变成其16进制对应的编码值,如下例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">上面链接等价于</div><div class="line">http:<span class="comment">//mrdear.cn/2017/04/15/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/</span></div></pre></td></tr></table></figure></p>
<p>中间还有其他很复杂的流程,比如参数,协议,请求头,请求体等建立.</p>
<h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>对于网址mrdear.cn,浏览器并不知道他所处的服务器位置,因此需要解析出其服务器ip,这个过程就是DNS域名解析.</p>
<ul>
<li>浏览器首先检查自身缓存dns解析,以chrome为例,输入<code>chrome://net-internals/#dns</code>即可看到缓存列表.该缓存通常几分钟到几小时不等,存在的话就直接返回,否则下一步</li>
<li>和浏览器同样策略,OS对每一次解析结果也会做缓存,浏览器中不存在则在OS的缓存中查找.这个过成功也包括在本地hosts中查找.找到则返回,找不到则向本机的dns服务器发送查找请求.</li>
<li><p>DNS服务器和本机在一个子网内,则APR解析到具体设备的mac地址,然后向其查找.如果不在一个子网,则直接ARP解析当前主机网关地址,网关一般是上一个路由节点,也就是把查询转交给上一层服务器,那么上一层服务器找不到还会转交给它的上一层,如此形成一个递归查询过程,直到查找到根服务器.找不到则返回失败.找到则返回ip地址和其TTL时间.<br>linux和unix下的dns配置在<code>/etc/resolv.conf</code>中,可以使用<code>nslookup或者dig查</code>看解析过程.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1493479248.png?imageMogr2/thumbnail/!60p" alt=""></p>
</li>
<li><p>解析成功后,浏览器创建与服务器的socket连接,构造请求信息,进行TCP三次握手,开始向服务器传输消息,并等服务器回复信息,这也是TPC可靠的一个原因.</p>
</li>
</ul>
<h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>服务器以nginx+tomcat为例,经过以上步骤后请求到达了nginx,nginx对URL进行分析,验证其所在机器上有所需要的服务,并且用户是有权限调用的,决定该URL由哪一个tomcat服务处理,捕获处理结果,返回给请求者,最后四次挥手结束请求.到此完成浏览器,服务端的通信.</p>
<h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>浏览器拿到了服务器的返回信息后会对内容进行解析,展现成用户所需要的内容,如html,pdf等.</p>
<hr>
<p>那么整个过程总结来看就是 用户输入URL -&gt; 浏览器解析地址 -&gt; DNS查找域名对应ip -&gt; 服务器响应 -&gt;浏览器拿到响应渲染.</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="1-CDN网络"><a href="#1-CDN网络" class="headerlink" title="1.CDN网络"></a>1.CDN网络</h4><p>CDN又叫内容分布网络,一般用于静态资源如html,css,js的存储,简单的理解为一张大网,网上每一个节点都有着很多资源.那么每一个用户想要访问的时候就会去找离他最近的节点上面获取需要的内容.从而加快了网站整体访问速度.<br>举个例子:用户访问taobao的某css文件,首先浏览器会发送请求 -&gt; DNS解析域名,这里一般会有一个DNS负载均衡服务器,其得到最适合用户的CDN节点ip -&gt; 用户拿到CDN节点ip得到资源.</p>
<h4 id="2-DNS劫持"><a href="#2-DNS劫持" class="headerlink" title="2.DNS劫持"></a>2.DNS劫持</h4><p>了解了DNS的解析是一个递归过程,找到域名 &lt;-&gt; ip就返回,如果有人手动修改了该条映射信息,那么就会返回到错误的ip地址,这种行为也叫DNS劫持,对于客户端来说,没有很好地方式能认为服务器返回的信息是可靠的,也就是不可靠的HTTP通信,所以也就导致了这一层的攻击漏洞,而这种事一般是天朝的电信运营商能干得出来,所以选择一个靠谱的DNS是非常重要,推荐<code>114.114.114.114</code></p>
<h4 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3.HTTPS"></a>3.HTTPS</h4><p>应对HTTP的不可靠通信,所以诞生了HTTPS,即HTTP over SSL,使用SSL/TLS对HTTP的内容进行加密解密.整个流程如下图:</p>
<p><center><img src="http://oobu4m7ko.bkt.clouddn.com/1493510445.png?imageMogr2/thumbnail/!100p" alt=""></center></p>
<ul>
<li>在SSL握手阶段，客户端浏览器会认证服务器的身份，这是通过“证书”来实现的，证书由证书权威（CA）为某个域名签发，可以理解为网站的身份证件，客户端需要对这个证件进行认证，需要确定该证书是否属于目标网站并确认证书本身是否有效。最后在握手阶段，通信的双方还会协商出一个用于加密和解密的会话密钥。</li>
<li>SSL握手阶段结束之后，服务器和客户端使用协商出的会话密钥对交互的数据进行加密/解密操作，对于HTTP协议来说，就是将HTTP请求和应答经过加密之后再发送到网络上。<br>HTTPS协议对服务器进行了一次身份验证,所以即使DNS被劫持,定向到的服务器也会因为没证书而无法通过身份验证.</li>
</ul>
<h4 id="4-乱码问题"><a href="#4-乱码问题" class="headerlink" title="4.乱码问题"></a>4.乱码问题</h4><p>流程清晰后乱码问题就很好解决了,把浏览器,Nginx,Tomcat等都当成水池的话,数据的乱码只能在每一个的入口端和出口端.如果发生了乱码,那么首先定位到是哪一个口产生了乱码,然后再去找原因,一般都能解决.<br>以JavaWEB应用为例,乱码主要发生在IO交互的过程中.其一浏览器与服务器建立socket连接,浏览器对URL以及request转换编码.请求到达tomcat,tomcat会对其进行解码,这个解码可在tomcat目录下的conf/server.xml中配置URIEncoding<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">connector</span> <span class="attr">port</span>=<span class="string">”8080″</span> <span class="attr">protocol</span>=<span class="string">”HTTP/1.1″</span> <span class="attr">maxThreads</span>=<span class="string">”150″</span>   <span class="attr">connectionTimeout</span>=<span class="string">”200000″</span></span></div><div class="line">     <span class="attr">redirecPort</span>=<span class="string">”8443″</span>    <span class="attr">URIEncoding</span>=<span class="string">”utf-8″/</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这里要保证不乱码,下一步tomcat建立了ServletRequest和ServletResponse,那么这里也有编码,一般是post表单或者request body乱码,那么就需要指定ServletRequest和ServletResponse的编码格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request.setCharacterEncoding(encoding);<span class="comment">//设置请求信息编码</span></div><div class="line">response.setCharacterEncoding(encoding);<span class="comment">//设置返回信息编码</span></div></pre></td></tr></table></figure></p>
<p>Java程序在处理请求时和操作系统会有IO通信,和数据库会有IO通信,整个过程也会涉及编码,这种一般代码中会自动控制,出问题几率不大.<br>浏览器拿到返回信息后对页面进行渲染,这一步也会有编码,这个一般手动指定下浏览器的渲染编码,比如<code>Content-Type: text/html;charset=UTF-8</code>,指定以UTF-8渲染该text/html返回.</p>
<h4 id="5-几种域名解析"><a href="#5-几种域名解析" class="headerlink" title="5.几种域名解析"></a>5.几种域名解析</h4><p>域名解析记录主要分为：A 记录、MX记录、CNAME 记录、NS记录和 TXT记录</p>
<ul>
<li>A记录：A 代表的是Address，用来指定域名对应的IP地址。域名可以多对一但是不能一对多。</li>
<li>MX记录：Mail Exchange,就是讲某个域名下的邮件服务器指向自己的Mail Server。</li>
<li>CNAME记录：别名解析。将一个域名设置一个或者多个别名。</li>
<li>NS记录：为某个域名指定DNS解析服务器。</li>
<li>TXT记录：为某个主机名或者域名设置文字说明。<br>本站是托管于github的,主域名<code>mrdear.cn</code>是使用CNAME解析到<code>nl101531.github.io</code>的,二级域名<code>oj.mrdear.cn</code>和<code>md.mrdear.cn</code>都是使用A记录解析到对应主机的ip地址,到达主机后再使用Nginx进行不同的服务器转发.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1493775848.png?imageMogr2/thumbnail/!70p" alt=""></li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>个人总结,如有错误请指出,以免误人子弟.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着写的WEB程序越来越多,项目的部署也越来越繁琐,对于一些线上问题总是搞不清楚是哪个环节出的问题,归根结底是对整个流程的不熟悉导致,所以分析下一个WEB请求从用户输入地址到页面出来到底经历过多少东西.&lt;/p&gt;
&lt;h3 id=&quot;URL解析&quot;&gt;&lt;a href=&quot;#URL解析&quot;
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="http" scheme="http://mrdear.cn/tags/http/"/>
    
      <category term="web" scheme="http://mrdear.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(八)</title>
    <link href="http://mrdear.cn/2017/04/29/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E5%85%AB)/"/>
    <id>http://mrdear.cn/2017/04/29/毕业设计/毕业设计周记(八)/</id>
    <published>2017-04-29T10:00:00.000Z</published>
    <updated>2017-04-29T11:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>写毕业设计过程中发现一些设计不是很好的地方,比如说结构上之前maven模块化分层,dao,service,controller每一个都是单独的maven项目,导致开发起来比较麻烦,所以改掉了,把数据库模型对应的DO单独放入一个架包,然后dao,service,controller等放入一个war包中,明白了对于一个小项目来说过多的分层是系统开发的累赘.</p>
<p>修改数据库模型后代码不少地方重新写了下,耽误了点时间,五一期间仍然是写毕业论文.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>后端项目地址: <a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
<p>测试地址: <a href="http://oj.mrdear.cn" target="_blank" rel="external">http://oj.mrdear.cn</a></p>
<p>测试账号: 1015315668@qq.com<br>          111111</p>
<p>等待完成:</p>
<p>1.毕业论文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写毕业设计过程中发现一些设计不是很好的地方,比如说结构上之前maven模块化分层,dao,service,controller每一个都是单独的maven项目,导致开发起来比较麻烦,所以改掉了,把数据库模型对应的DO单独放入一个架包,然后dao,service,control
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(七)</title>
    <link href="http://mrdear.cn/2017/04/24/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%B8%83)/"/>
    <id>http://mrdear.cn/2017/04/24/毕业设计/毕业设计周记(七)/</id>
    <published>2017-04-24T11:00:00.000Z</published>
    <updated>2017-04-24T11:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周把个人中心完成了,用户注册后的邮件验证,以及注册后的更新自身信息,找回密码等功能都完成.</p>
<p>毕业论文正在写系统整体设计,需要画一些图.预计五一假期之后初稿出来.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>后端项目地址: <a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
<p>测试地址: <a href="http://oj.mrdear.cn" target="_blank" rel="external">http://oj.mrdear.cn</a></p>
<p>测试账号: 1015315668@qq.com<br>          111111</p>
<p>等待完成:</p>
<p>1.毕业论文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周把个人中心完成了,用户注册后的邮件验证,以及注册后的更新自身信息,找回密码等功能都完成.&lt;/p&gt;
&lt;p&gt;毕业论文正在写系统整体设计,需要画一些图.预计五一假期之后初稿出来.&lt;/p&gt;
&lt;p&gt;前端项目地址: &lt;a href=&quot;https://github.com/nl101
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>少走弯路的10条建议(转)</title>
    <link href="http://mrdear.cn/2017/04/21/%E7%BB%8F%E9%AA%8C/%E5%B0%91%E8%B5%B0%E5%BC%AF%E8%B7%AF%E7%9A%8410%E6%9D%A1%E5%BB%BA%E8%AE%AE(%E8%BD%AC)/"/>
    <id>http://mrdear.cn/2017/04/21/经验/少走弯路的10条建议(转)/</id>
    <published>2017-04-21T01:50:00.000Z</published>
    <updated>2017-04-21T01:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="少走弯路的10条建议-转"><a href="#少走弯路的10条建议-转" class="headerlink" title="少走弯路的10条建议(转)"></a>少走弯路的10条建议(转)</h1><p>标签（空格分隔）： 经验</p>
<hr>
<p>转载自一个很佩服的大牛博客:<a href="http://www.cnblogs.com/xdp-gacl/p/4102862.html" target="_blank" rel="external">孤傲苍狼</a></p>
<hr>
<p>　如何在涉世之初少走弯路，有一个好的开端，开始一番成功的事业？以下是一些先行者积累的10条有益的涉世忠告。好好地遵循、把握这些忠告和建议吧，比起所学的课堂课程来，它毫不逊色！</p>
<p>1.1、买个闹钟，以便按时叫醒你</p>
<p>　　贪睡和不守时，都将成为你工作和事业上的绊脚石，任何时候都一样。不仅要学会准时，更要学会提前。就如你坐车去某地，沿途的风景很美，你忍不住下车看一看，后来虽然你还是赶到了某地，却不是准时到达。“闹钟”只是一种简单的标志和提示，真正灵活、实用的时间，掌握在每个人的心中。  </p>
<p>1.2、如果你不喜欢现在的工作，要么辞职不干，要么就闭嘴不言</p>
<p>　　初出茅庐，往往眼高手低，心高气傲，大事做不了，小事不愿做。不要养成挑三拣四的习惯。不要雨天烦打伞，不带伞又怕淋雨，处处表现出不满的情绪。记住，不做则已，要做就要做好。</p>
<p>1.3、每个人都有孤独的时候 </p>
<p>　　要学会忍受孤独，这样才会成熟起来。年轻人嘻嘻哈哈、打打闹闹惯了，到了一个陌生的环境，面对形形色色的人和事，一下子不知所措起来，有时连一个可以倾心说话的地方也没有。这时，千万别浮躁，学会静心，学会忍受孤独。在孤独中思考，在思考中成熟，在成熟中升华。不要因为寂寞而乱了方寸，而去做无聊无益的事情，白白浪费了宝贵的时间。  </p>
<p>1.4、走运时要做好倒霉的准备</p>
<p>　　有一天，一只狐狸走到一个葡萄园外，看见里面水灵灵的葡萄垂涎欲滴。可是外面有栅栏挡着，无法进去。于是它一狠心绝食三日，减肥之后，终于钻进葡萄园内饱餐一顿。当它心满意足地想离开葡萄园时，发觉自己吃得太饱，怎么也钻不出栅栏了。相信任何人都不愿做这样的狐狸。退路同样重要。饱带干粮，晴带雨伞，点滴积累，水到渠成。有的东西今天似乎一文不值，但有朝一日也许就会身价百倍。  </p>
<p>1.5、不要像玻璃那样脆弱</p>
<p>　　有的人眼睛总盯着自己，所以长不高看不远；总是喜欢怨天尤人，也使别人无比厌烦。没有苦中苦，哪来甜中甜？不要像玻璃那样脆弱，而应像水晶一样透明，太阳一样辉煌，腊梅一样坚强。既然睁开眼睛享受风的清凉，就不要埋怨风中细小的沙粒。  </p>
<p>1.6、管住自己的嘴巴</p>
<p>　　不要谈论自己，更不要议论别人。谈论自己往往会自大虚伪，在名不副实中失去自己。议论别人往往陷入鸡毛蒜皮的是非口舌中纠缠不清。每天下班后和你的那些同事朋友喝酒聊天可不是件好事，因为，这中间往往会把议论同事、朋友当做话题。背后议论人总是不好的，尤其是议论别人的短处，这些会降低你的人格。  </p>
<p>1.7、机会从不会“失掉”，你失掉了，自有别人会得到</p>
<p>　　不要凡事在天，守株待兔，更不要寄希望于“机会”。机会只不过是相对于充分准备而又善于创造机会的人而言的。也许，你正为失去一个机会而懊悔、埋怨的时候，机会正被你对面那个同样的“倒霉鬼”给抓住了。没有机会，就要创造机会，有了机会，就要巧妙地抓住。  </p>
<p>1.8、若电话老是不响，你该打出去</p>
<p>　　很多时候，电话会给你带来意想不到的收获，它不是花瓶，仅仅成为一种摆设。交了新朋友，别忘了老朋友，朋友多了路好走。交际的一大诀窍就是主动。好的人缘好的口碑，往往助你的事业更上一个台阶。  </p>
<p>1.9、千万不要因为自己已经到了结婚年龄而草率结婚</p>
<p>　　想结婚，就要找一个能和你心心相印、相辅相携的伴侣。不要因为放纵和游戏而恋爱，不要因为恋爱而影响工作和事业，更不要因一桩草率而失败的婚姻而使人生受阻。感情用事往往会因小失大。  </p>
<p>1.10、写出你一生要做的事情，把单子放在皮夹里，经常拿出来看</p>
<p>　　人生要有目标，要有计划，要有提醒，要有紧迫感。一个又一个小目标串起来，就成了你一生的大目标。生活富足了，环境改善了，不要忘了皮夹里那张看似薄薄的单子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;少走弯路的10条建议-转&quot;&gt;&lt;a href=&quot;#少走弯路的10条建议-转&quot; class=&quot;headerlink&quot; title=&quot;少走弯路的10条建议(转)&quot;&gt;&lt;/a&gt;少走弯路的10条建议(转)&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 经验&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;转载自
    
    </summary>
    
      <category term="经验" scheme="http://mrdear.cn/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://mrdear.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
