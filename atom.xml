<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  
  <subtitle>change from today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrdear.cn/"/>
  <updated>2017-10-09T15:34:43.000Z</updated>
  <id>http://mrdear.cn/</id>
  
  <author>
    <name>Niu li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular中引入第三方JS库</title>
    <link href="http://mrdear.cn/2017/10/09/web/Angular%E4%B8%AD%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9Js%E5%BA%93/"/>
    <id>http://mrdear.cn/2017/10/09/web/Angular中引入第三方Js库/</id>
    <published>2017-10-09T15:34:43.000Z</published>
    <updated>2017-10-09T15:34:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写<a href="http://www.itoolshub.com/" target="_blank" rel="external">http://www.itoolshub.com/</a>的时候用到了日期时间选择器,Angular本身material2只有日期选择器,也不知道为什么官方不提供日期时间选择器,也可能是Angular2以及如今的4有些年轻,很多库都不是很成熟,于是乎搜索到的解决方案就是借助第三方的库来使用一些优秀的组件.本文以<a href="https://github.com/sentsin/laydate" target="_blank" rel="external">https://github.com/sentsin/laydate</a>组件为例.</p><h3 id="引入js与css"><a href="#引入js与css" class="headerlink" title="引入js与css"></a>引入js与css</h3><p><a href="https://github.com/sentsin/laydate" target="_blank" rel="external">https://github.com/sentsin/laydate</a>是采用原生js实现的组件,因此不需要考虑相关依赖,直接入手.<br>1.使用npm下载该组件<code>npm install layui-laydate -save</code><br>2.在<code>.angular-cli.json</code>文件中配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"styles": [</div><div class="line">     "styles.scss",</div><div class="line">     <span class="string">"../node_modules/layui-laydate/dist/theme/default/laydate.css"</span></div><div class="line">   ],</div><div class="line">   "scripts": [</div><div class="line">     <span class="string">"../node_modules/layui-laydate/dist/laydate.js"</span></div><div class="line">   ],</div></pre></td></tr></table></figure></p><p>Angular在编译的时候会把上述的js引用都打包到<code>scripts.bundle.js</code>文件中</p><h3 id="ts编译识别laydate"><a href="#ts编译识别laydate" class="headerlink" title="ts编译识别laydate"></a>ts编译识别laydate</h3><p>第一步完成后如果在TS中使用laydate变量,编译器是会直接报错的,因为其找不到这个变量,因此这一步要做的就是让ts识别该变量.做法很简单,在<code>typings.d.ts</code>中加入声明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* SystemJS module definition */</span></div><div class="line">declare <span class="keyword">var</span> <span class="built_in">module</span>: NodeModule;</div><div class="line">interface NodeModule &#123;</div><div class="line">  id: string;</div><div class="line">&#125;</div><div class="line"><span class="comment">// laydate声明</span></div><div class="line">declare <span class="keyword">var</span> laydate: any;</div></pre></td></tr></table></figure></p><h3 id="使用laydate功能"><a href="#使用laydate功能" class="headerlink" title="使用laydate功能"></a>使用laydate功能</h3><p><code>laydate</code>是需要更改Dom节点的,因此该步骤必须放到Angular对视图渲染之后,也就是生命周期中的<code>AfterViewInit</code>函数中执行.另外该渲染会使得双向绑定失效,需要处理结果则可以在<code>laydate</code>的回调函数中处理.<br>另外使用的时候就可以按照ts的语法来使用了,最终都会解析成原生js.比如下方的箭头函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ngAfterViewInit(): <span class="keyword">void</span> &#123;</div><div class="line">  <span class="keyword">let</span> done = <span class="function">(<span class="params">value, date, endDate</span>) =&gt;</span>&#123;</div><div class="line">    <span class="keyword">let</span> selectTime = <span class="keyword">new</span> <span class="built_in">Date</span>(value);</div><div class="line">    <span class="keyword">this</span>.timeStampOut = selectTime.getTime() / <span class="number">1000</span>;</div><div class="line">    <span class="keyword">this</span>.timeStampWeek = TimestampComponent.WEEKS[selectTime.getDay()] == <span class="literal">null</span> ? <span class="string">"Invalid Week"</span>: TimestampComponent.WEEKS[selectTime.getDay()]</div><div class="line">  &#125;;</div><div class="line">  laydate.render(&#123;</div><div class="line">    elem: <span class="string">'#layerdate'</span>,</div><div class="line">    type: <span class="string">'datetime'</span>,</div><div class="line">    change: done,</div><div class="line">    done: done</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>很多库都是直接对DOM进行操作,这对于Angular这种虚拟Dom操作会导致绑定失效等各种异常问题,一般情况下不建议混编,尤其是大项目,到后期会出现各种折磨人的小问题.</p><p>更多Angular实战代码可以参考我的开源项目:</p><blockquote><p>github: <a href="https://github.com/nl101531/IToolsHub" target="_blank" rel="external">https://github.com/nl101531/IToolsHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写&lt;a href=&quot;http://www.itoolshub.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.itoolshub.com/&lt;/a&gt;的时候用到了日期时间选择器,Angular本身material2只有日期选择
      
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>博客的好搭档七牛云</title>
    <link href="http://mrdear.cn/2017/09/24/%E8%BF%90%E7%BB%B4/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A5%BD%E6%90%AD%E6%A1%A3%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>http://mrdear.cn/2017/09/24/运维/博客的好搭档七牛云/</id>
    <published>2017-09-24T01:58:10.000Z</published>
    <updated>2017-09-24T01:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客也搭建有一段时间了,期间一些同学来询问如何搭建博客,找了几篇文章让其搭建好了后我却发现大量图片也没他上传到github了,图片本身大,再加上github国内访问并不是很流畅,那么结果就是博客速度的下降,所以分享七牛云就是解决这个问题.</p><hr><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h3><p>七牛云是一个云存储平台,对于个人博客而言他就是一个图床,我们可以把图片等静态资源放在上面,甚至可以把整个博客都放在上面.比如<code>http://oobu4m7ko.bkt.clouddn.com/1506220469.png</code>这张图片就是我上传到七牛云上的,嵌入到markdown中的话展示效果如下:<br><img src="http://oobu4m7ko.bkt.clouddn.com/1506220469.png?imageMogr2/thumbnail/!100p" alt=""></p><p>七牛云允许你对链接加参数来对图片进行一些处理,比如下面这些操作<br><code>http://oobu4m7ko.bkt.clouddn.com/1506220469.png?imageMogr2/thumbnail/!70p</code>,这参数以为等比缩放为70%,对于mac等高分辨屏来说很实用.<br>当然还有缩略,转换,裁剪等功能.详细的可以参考该文档<a href="https://developer.qiniu.com/dora/manual/1279/basic-processing-images-imageview2" target="_blank" rel="external">七牛图片处理基本文档</a></p><p>七牛给免费用户提供了每月10GB的流量,足够个人网站的使用了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1506223925.png?imageMogr2/thumbnail/!70p" alt=""></p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用?"></a>怎么用?</h3><p>七牛虽好,但是上传是个麻烦的事情,写作的时候不能还开个浏览器窗口专门上传图片,这个肯定不合理.这样的不合理肯定有好的解决方案,我理想中的方案时复制图片到剪贴板,软件从剪贴板读取,上传,返回指定形式链接到粘贴板.下面推荐一些比较好的开源方案.</p><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>首先注册七牛账号,不介意的话可以走我的邀请链接.</p><blockquote><p><a href="https://portal.qiniu.com/signup?code=3lea5e6tnitsi" target="_blank" rel="external">注册七牛云</a></p></blockquote><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><p>对于mac下图床的客户端选择是非常多的,这里首推alfred的workflow,简洁实用.<br><a href="https://github.com/kaito-kidd/markdown-image-alfred" target="_blank" rel="external">https://github.com/kaito-kidd/markdown-image-alfred</a></p><blockquote><p>支持复制本地图片获取图片链接<br>支持截图获取图片图片链接<br>支持gif格式<br>操作结果会在通知栏显示</p></blockquote><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>windows下首推mpic这款软件,操作简单,文档清晰,下载后配置下即可使用.<br><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="external">http://mpic.lzhaofu.cn/</a></p><p>如果你有更好的方案,欢迎分享.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客也搭建有一段时间了,期间一些同学来询问如何搭建博客,找了几篇文章让其搭建好了后我却发现大量图片也没他上传到github了,图片本身大,再加上github国内访问并不是很流畅,那么结果就是博客速度的下降,所以分享七牛云就是解决这个问题.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="运维" scheme="http://mrdear.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="七牛" scheme="http://mrdear.cn/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="图片存储" scheme="http://mrdear.cn/tags/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(三)-强大的collect操作</title>
    <link href="http://mrdear.cn/2017/09/20/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-%E5%BC%BA%E5%A4%A7%E7%9A%84collect%E6%93%8D%E4%BD%9C/"/>
    <id>http://mrdear.cn/2017/09/20/java/Java8学习记录(三)-强大的collect操作/</id>
    <published>2017-09-20T14:59:38.000Z</published>
    <updated>2017-09-20T14:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>collect</code>应该说是<code>Stream</code>中最强大的终端操作了,使用其几乎能得到你想要的任意数据的聚合,下面好好分析该工具的用法.</p><hr><p>在Stream接口中有如下两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></div><div class="line"><span class="function"><span class="params">                 BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></div><div class="line"><span class="function"><span class="params">                 BiConsumer&lt;R, R&gt; combiner)</span></span>;</div><div class="line">                 </div><div class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</div></pre></td></tr></table></figure></p><p>很明显第一种相当于简易实现版本,第二种为高级用法.更多更复杂的操作都封装到Collector接口中,并提供一些静态方法供使用者调用.下面逐一分析.</p><h3 id="简易调用形式"><a href="#简易调用形式" class="headerlink" title="简易调用形式"></a>简易调用形式</h3><p>简易调用形式就是第一种接口,接口如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></div><div class="line"><span class="function"><span class="params">                BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></div><div class="line"><span class="function"><span class="params">                BiConsumer&lt;R, R&gt; combiner)</span></span>;</div></pre></td></tr></table></figure></p><p>调用方式如下,很明显第一个参数<code>supplier</code>为结果存放容器,第二个参数<code>accumulator</code>为结果如何添加到容器的操作,第三个参数<code>combiner</code>则为多个容器的聚合策略.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String concat = stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append,StringBuilder::append).toString();</div><div class="line"><span class="comment">//等价于上面,这样看起来应该更加清晰</span></div><div class="line">String concat = stringStream.collect(() -&gt; <span class="keyword">new</span> StringBuilder(),(l, x) -&gt; l.append(x), (r1, r2) -&gt; r1.append(r2)).toString();</div></pre></td></tr></table></figure></p><p>那么换一种,我想对一个List<integer>收集结果总和,按照Collect的要求,首先需要容器sum,然后添加操作 sum+x,聚合操作,sum1+sum2,那么就很容易写出来了,看完下面代码后好好体会下,然后再看高级用法.当然用sum方法收集是最佳解决方案,这里只是提供一种示例应用.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于基本类型都是不可变类型,所以这里用数组当做容器</span></div><div class="line"><span class="keyword">final</span> Integer[] integers = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .stream()</div><div class="line">        .collect(() -&gt; <span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>&#125;, (a, x) -&gt; a[<span class="number">0</span>] += x, (a1, a2) -&gt; a1[<span class="number">0</span>] += a2[<span class="number">0</span>]);</div></pre></td></tr></table></figure></integer></p><p>那么再换一种,有一个<code>Person</code>类,其拥有type与name两个属性,那么使用<code>collect</code>把他收集到Map集合中,其中键为type,值为person的集合.如下代码所示,看明白了相信就掌握了该方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Lists.&lt;Person&gt;newArrayList().stream()</div><div class="line">     .collect(() -&gt; <span class="keyword">new</span> HashMap&lt;Integer,List&lt;Person&gt;&gt;(),</div><div class="line">         (h, x) -&gt; &#123;</div><div class="line">           List&lt;Person&gt; value = h.getOrDefault(x.getType(), Lists.newArrayList());</div><div class="line">           value.add(x);</div><div class="line">           h.put(x.getType(), value);</div><div class="line">         &#125;,</div><div class="line">         HashMap::putAll</div><div class="line">     );</div></pre></td></tr></table></figure></p><h3 id="Collector高级调用"><a href="#Collector高级调用" class="headerlink" title="Collector高级调用"></a>Collector高级调用</h3><p><code>Collector</code>接口是使得<code>collect</code>操作强大的终极武器,对于绝大部分操作可以分解为旗下主要步骤,<strong>提供初始容器-&gt;加入元素到容器-&gt;并发下多容器聚合-&gt;对聚合后结果进行操作</strong>,同时<code>Collector</code>接口又提供了<code>of</code>静态方法帮助你最大化的定制自己的操作,官方也提供了<code>Collectors</code>这个类封装了大部分的常用收集操作.<br>另外<code>CollectorImpl</code>为<code>Collector</code>的实现类,因为接口不可实例化,这里主要完成实例化操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始容器</span></div><div class="line"> <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//加入到容器操作</span></div><div class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//多容器聚合操作</span></div><div class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//聚合后的结果操作</span></div><div class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//操作中便于优化的状态字段</span></div><div class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p><h3 id="Collectors的方法封装"><a href="#Collectors的方法封装" class="headerlink" title="Collectors的方法封装"></a>Collectors的方法封装</h3><p><code>Collectors</code>作为官方提供的收集工具类,那么其很多操作都具有参考性质,能帮助我们更加理解<code>Collector</code>接口,万变不离其宗,最终只是上面五个函数接口的混合操作,下面来分析下官方是如何使用这几个接口的.</p><h4 id="toList"><a href="#toList" class="headerlink" title="toList()"></a>toList()</h4><p>容器: <code>ArrayList::new</code><br>加入容器操作: <code>List::add</code><br>多容器合并: <code>left.addAll(right); return left;</code><br>聚合后的结果操作: 这里直接返回,因此无该操作,默认为<code>castingIdentity()</code><br>优化操作状态字段: <code>CH_ID</code><br>这样看起来很简单,那么对于Map,Set等操作都是类似的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"> Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</div><div class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</div><div class="line">                                CH_ID);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h4 id="joining"><a href="#joining" class="headerlink" title="joining()"></a>joining()</h4><p>容器: <code>StringBuilder::new</code><br>加入容器操作: <code>StringBuilder::append</code><br>多容器合并: <code>r1.append(r2); return r1;</code><br>聚合后的结果操作: <code>StringBuilder::toString</code><br>优化操作状态字段: <code>CH_NOID</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</div><div class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</div><div class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</div><div class="line">            StringBuilder::toString, CH_NOID);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面来个复杂的</p><h4 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy()"></a>groupingBy()</h4><p><code>groupingBy</code>是<code>toMap</code>的一种高级方式,弥补了<code>toMap</code>对值无法提供多元化的收集操作,比如对于返回<code>Map&lt;T,List&lt;E&gt;&gt;</code>这样的形式<code>toMap</code>就不是那么顺手,那么<code>groupingBy</code>的重点就是对Key和Value值的处理封装.分析如下代码,其中<code>classifier</code>是对key值的处理,<code>mapFactory</code>则是指定Map的容器具体类型,<code>downstream</code>为对Value的收集操作,具体代码这里不做分析,无非是把值一个一个的put进指定容器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</div><div class="line"> Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                               Supplier&lt;M&gt; mapFactory,</div><div class="line">                               Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">    .......</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>对于之前用原生<code>collect</code>方法做的收集操作那么就可以很容易改写为groupBy形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原生形式</span></div><div class="line">   Lists.&lt;Person&gt;newArrayList().stream()</div><div class="line">        .collect(() -&gt; <span class="keyword">new</span> HashMap&lt;Integer,List&lt;Person&gt;&gt;(),</div><div class="line">            (h, x) -&gt; &#123;</div><div class="line">              List&lt;Person&gt; value = h.getOrDefault(x.getType(), Lists.newArrayList());</div><div class="line">              value.add(x);</div><div class="line">              h.put(x.getType(), value);</div><div class="line">            &#125;,</div><div class="line">            HashMap::putAll</div><div class="line">        );</div><div class="line"><span class="comment">//groupBy形式</span></div><div class="line">Lists.&lt;Person&gt;newArrayList().stream()</div><div class="line">        .collect(Collectors.groupingBy(Person::getType, HashMap::<span class="keyword">new</span>, Collectors.toList()));</div><div class="line"><span class="comment">//因为对值有了操作,因此我可以更加灵活的对值进行转换</span></div><div class="line">Lists.&lt;Person&gt;newArrayList().stream()</div><div class="line">        .collect(Collectors.groupingBy(Person::getType, HashMap::<span class="keyword">new</span>, Collectors.mapping(Person::getName,Collectors.toSet())));</div></pre></td></tr></table></figure></p><h4 id="reducing"><a href="#reducing" class="headerlink" title="reducing()"></a>reducing()</h4><p><code>reducing</code>是针对单个值的收集,其返回结果不是集合家族的类型,而是单一的实体类T<br>容器: <code>boxSupplier(identity)</code>,这里包裹用的是一个长度为1的Object[]数组,至于原因自然是不可变类型的锅<br>加入容器操作: <code>a[0] = op.apply(a[0], t)</code><br>多容器合并: <code>a[0] = op.apply(a[0], b[0]); return a;</code><br>聚合后的结果操作: 结果自然是Object[0]所包裹的数据<code>a -&gt; a[0]</code><br>优化操作状态字段: <code>CH_NOID</code><br>那么看到这里困惑是不是有一种恍然大悟的感觉,反正我是有的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, T&gt;</div><div class="line">  reducing(T identity, BinaryOperator&lt;T&gt; op) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</div><div class="line">              boxSupplier(identity),</div><div class="line">              (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], t); &#125;,</div><div class="line">              (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</div><div class="line">              a -&gt; a[<span class="number">0</span>],</div><div class="line">              CH_NOID);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>那么接下来就是对之前Collect的一些操作的改造<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原生操作</span></div><div class="line"><span class="keyword">final</span> Integer[] integers = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .stream()</div><div class="line">        .collect(() -&gt; <span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>&#125;, (a, x) -&gt; a[<span class="number">0</span>] += x, (a1, a2) -&gt; a1[<span class="number">0</span>] += a2[<span class="number">0</span>]);</div><div class="line"><span class="comment">//reducing操作</span></div><div class="line"><span class="keyword">final</span> Integer collect = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .stream()</div><div class="line">        .collect(Collectors.reducing(<span class="number">0</span>, Integer::sum));    </div><div class="line"><span class="comment">//当然Stream也提供了reduce操作</span></div><div class="line"><span class="keyword">final</span> Integer collect = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .stream().reduce(<span class="number">0</span>, Integer::sum)</div></pre></td></tr></table></figure></p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>记录下生产中使用该工具遇到的一些小错误</p><h4 id="toMap所产生的异常"><a href="#toMap所产生的异常" class="headerlink" title="toMap所产生的异常"></a>toMap所产生的异常</h4><p>toMap的操作主要如下代码,异常来自两个方面</p><ol><li>操作调用的是<code>map.merge</code>方法,该方法遇到value为null的情况会报npe,即使你使用的是hashMap可以接受null值,也照样报.搞不懂这里为什么这样设计.</li><li>未指定冲突合并策略,也就是第三个参数<code>BinaryOperator&lt;U&gt; mergeFunction</code>时遇到重复的key会直接抛<code>IllegalStateException</code>,因此需要注意.</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此对于<code>collect</code>的操作应该就很清晰了,希望通过这些例子能掌握核心,也就是<code>Collector</code>接口中那几个函数的作用,希望对你有帮助.</p><blockquote><p>个人博客 <a href="mrdear.cn">mrdear.cn</a> ,欢迎交流</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;collect&lt;/code&gt;应该说是&lt;code&gt;Stream&lt;/code&gt;中最强大的终端操作了,使用其几乎能得到你想要的任意数据的聚合,下面好好分析该工具的用法.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在Stream接口中有如下两个方法&lt;br&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(三)--动态Sql中的参数解析</title>
    <link href="http://mrdear.cn/2017/09/10/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)--%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>http://mrdear.cn/2017/09/10/mybatis/Mybatis源码分析(三)--参数解析/</id>
    <published>2017-09-10T03:45:04.000Z</published>
    <updated>2017-09-10T03:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis中参数解析对于开发人员来说是至关重要的,不然很容易出小问题,举个例子,假设现在方法为,当然这个是很糟糕的写法,这里只是想要搞清楚参数如何解析,项目中万万不可这样写.</p><h3 id="参数输入解析"><a href="#参数输入解析" class="headerlink" title="参数输入解析"></a>参数输入解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//方法</span></div><div class="line">   <span class="function">User <span class="title">findUser</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name,<span class="keyword">int</span> age,String email)</span></div><div class="line"><span class="function">   <span class="comment">//对应xml</span></span></div><div class="line"><span class="function">&lt;select id</span>=<span class="string">"findUser"</span> resultType=<span class="string">"cn.mrdear.users.dao.User"</span>&gt;</div><div class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;age&#125; AND email = #&#123;email&#125; </div><div class="line">&lt;/select&gt;</div><div class="line"><span class="comment">//调用参数</span></div><div class="line">   <span class="keyword">final</span> User user = userMapper.findUser(<span class="string">"quding"</span>, <span class="number">18</span>, <span class="string">"qq@mail.com"</span>);</div></pre></td></tr></table></figure><p>那么这里Mybatis会怎么解析参数呢?这个xml会构造失败不?首先是<code>MapperMethod</code>中使用<code>ParamNameResolver</code>对输入参数解析,针对上述输入参数会得到下面的结果.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<span class="comment">//获取参数类型,对于上述例子则是String,int,String</span></div><div class="line">   <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();<span class="comment">//这里获取到的则是@Param,getParameterAnnotations方法也用到了动态代理.</span></div><div class="line">   <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</div><div class="line">   <span class="keyword">int</span> paramCount = paramAnnotations.length;</div><div class="line">   <span class="comment">// get names from @Param annotations</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</div><div class="line">     <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123; <span class="comment">//过滤其内部一些特殊类型</span></div><div class="line">       <span class="comment">// skip special parameters</span></div><div class="line">       <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     String name = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</div><div class="line">       <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</div><div class="line">         hasParamAnnotation = <span class="keyword">true</span>;</div><div class="line">         name = ((Param) annotation).value();<span class="comment">//获取到'name'值</span></div><div class="line">         <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// @Param was not specified.</span></div><div class="line">       <span class="keyword">if</span> (config.isUseActualParamName()) &#123;<span class="comment">//默认为true,因此编译后参数都是args0,args1之类,因此这里获取的也是args0...</span></div><div class="line">         name = getActualParamName(method, paramIndex);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//当上面配置为false的时候这里才会使用0,1代替,因此如果未开启则会报错</span></div><div class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="comment">// use the parameter index as the name ("0", "1", ...)</span></div><div class="line">         <span class="comment">// gcode issue #71</span></div><div class="line">         name = String.valueOf(map.size());<span class="comment">//上述都没的话则世界使用map的index.</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     map.put(paramIndex, name);</div><div class="line">   &#125;</div><div class="line">   names = Collections.unmodifiableSortedMap(map);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>那么执行完毕后对于上述例子,names里面如下图所示,由于<code>config.isUseActualParamName()</code>为true,所以#{0}这种写法这里并不支持,而且也不建议这种写法,无可读性.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504965737.png?imageMogr2/thumbnail/!120p" alt=""><br>接下来执行<code>method.convertArgsToSqlCommandParam(args)</code>获取到实际输入的参数,对于上面例子我获取到的是个Map集合,如下图所示,对于单一实体例如User那么获取到的就是该实体.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505017418.png?imageMogr2/thumbnail/!120p" alt=""><br>再看我所用的sql写法,那么这里只能获取到name的值,sql处理时就会报错.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;age&#125; AND email = #&#123;email&#125;</div></pre></td></tr></table></figure></p><p><strong>由此可见针对多参数的输入</strong>,最佳解决方案是用<code>@Param</code>注解,其次为使用Map集合包裹参数,这样的话<code>method.convertArgsToSqlCommandParam(args)</code>得到的则是该Map集合.</p><h3 id="动态sql渲染解析"><a href="#动态sql渲染解析" class="headerlink" title="动态sql渲染解析"></a>动态sql渲染解析</h3><p>上述流程能得到所有的输入参数,那么接下来就是对sql的解析,下面把我们的sql变得复杂一些.(不要讨论sql的意义…这里只是分析参数如何解析)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mapper接口</span></div><div class="line">  <span class="function">User <span class="title">findUser</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, @<span class="title">Param</span><span class="params">(<span class="string">"user"</span>)</span> User user,@<span class="title">Param</span><span class="params">(<span class="string">"ids"</span>)</span> List&lt;Long&gt; ids)</span>;</div><div class="line"><span class="comment">//xml</span></div><div class="line">    &lt;select id=<span class="string">"findUser"</span> resultType=<span class="string">"cn.mrdear.users.dao.User"</span>&gt;</div><div class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;user.age&#125; AND email = #&#123;user.email&#125;</div><div class="line">OR id in</div><div class="line">&lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"item"</span> open=<span class="string">"("</span> close=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</div><div class="line">#&#123;item&#125;</div><div class="line">&lt;/foreach&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure></p><p>按照上述流程Mybatis解析出来的输入参数如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505020777.png?imageMogr2/thumbnail/!100p" alt=""></p><p>接下进入<code>DefaultSqlSession</code>的处理中,在其中有如下方法会多参数进一步判断,可以看出对于单一参数为<code>Collection</code>或者<code>Array</code>时Mybatis都会给默认命名方案.(这里是在3.3.0之前的版本只会处理List)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</div><div class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</div><div class="line">    map.put(<span class="string">"collection"</span>, object);</div><div class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</div><div class="line">      map.put(<span class="string">"list"</span>, object);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> map;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</div><div class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</div><div class="line">    map.put(<span class="string">"array"</span>, object);</div><div class="line">    <span class="keyword">return</span> map;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> object;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到了接下来转到执行器,使用<code>DynamicContext</code>构造动态sql所需要的上下文,对其构造函数分析<br>执行到这里的话参数只有三种情况</p><ol><li>null,无任何参数传入</li><li>Map类型，对于多参数,或者参数本身就是map再或者输入单一参数集合类型,数组类型都会转换为map</li><li>单一POJO类型.<br>Mybatis这里要做的就是把参数的各种形式尽可能都放在<code>ContextMap</code>中,该<code>ContextMap</code>是绑定了Ognl的,方便Ognl直接从其中获取到值.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</div><div class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</div><div class="line">    <span class="comment">//对于单个输入数据直接保存在ContentMap中</span></div><div class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//输入参数形式为 _parameter  : parameterObject</span></div><div class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</div><div class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p><img src="http://oobu4m7ko.bkt.clouddn.com/1505023031.png?imageMogr2/thumbnail/!70p" alt=""></p><h4 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h4><p>SqlNode是动态Sql解析和完善<code>ContextMap</code>的地方,对于我上述sql会转换为其三个子类,相关解析方法都在其内部.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505027107.png?imageMogr2/thumbnail/!70p" alt=""><br>解析后的sql如下图<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = ? <span class="keyword">AND</span> age = ? <span class="keyword">AND</span> email = ?</div><div class="line"><span class="keyword">OR</span> <span class="keyword">id</span> <span class="keyword">in</span> (  ?, ?, ?)</div></pre></td></tr></table></figure></p><p>此时<code>ContextMap</code>如下,其中有<code>_frch_item_2</code>这种形式的参数,这是Mybatis对foreach解析后所生成的键,便于填充数据,具体可以看<code>ForeachSqlNode</code><br><img src="http://oobu4m7ko.bkt.clouddn.com/1505027407.png?imageMogr2/thumbnail/!100p" alt=""><br>那么接下来要做的事情就是一一设置进去这些值.</p><h4 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h4><p>顾名思义,其提供<code>void setParameters(PreparedStatement ps)</code>对于sql参数设置的处理.分析下<code>DefaultParameterHandler</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</div><div class="line">   ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</div><div class="line">   List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</div><div class="line">   <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">//parameterMappings存储着要设置进去的值类型等信息</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</div><div class="line">       ParameterMapping parameterMapping = parameterMappings.get(i);</div><div class="line">       <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</div><div class="line">         Object value;</div><div class="line">         String propertyName = parameterMapping.getProperty();</div><div class="line">         <span class="comment">//AdditionalParameter是从ContextMap中copy到的,其没有的话说明是_parameter里面的值.</span></div><div class="line">         <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></div><div class="line">           value = boundSql.getAdditionalParameter(propertyName);</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</div><div class="line">           value = <span class="keyword">null</span>;</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</div><div class="line">           value = parameterObject;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">//获取_parameter里面的值.</span></div><div class="line">           MetaObject metaObject = configuration.newMetaObject(parameterObject);</div><div class="line">           <span class="comment">//其内部是一个递归实现获取.</span></div><div class="line">           value = metaObject.getValue(propertyName);</div><div class="line">         &#125;</div><div class="line">           <span class="comment">//typeHandle的处理</span></div><div class="line">         TypeHandler typeHandler = parameterMapping.getTypeHandler();</div><div class="line">         JdbcType jdbcType = parameterMapping.getJdbcType();</div><div class="line">         <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</div><div class="line">           jdbcType = configuration.getJdbcTypeForNull();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">           typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</div><div class="line">         &#125; <span class="keyword">catch</span> (TypeException e) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</div><div class="line">         &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>那么看<code>MetaObject</code>的递归获取,递归是针对参数为<code>user.username</code>这样的话会先从<code>_parameter</code>中找到user,然后再调用user 的getUsername()方法获取到结果.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">  PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</div><div class="line">  <span class="comment">//hasNext判断user.username这种类型</span></div><div class="line">  <span class="keyword">if</span> (prop.hasNext()) &#123;</div><div class="line">    MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</div><div class="line">    <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//递归获取</span></div><div class="line">      <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> objectWrapper.get(prop);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么针对上面的例子,这里先是去boundSql中的addtionParameters中获取参数,该参数一般是sql解析时动态生成的,比如foreach生成的_frch_xx,获取不到的话再去原始的ParamsObject中获取,该处的解析为递归形式了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505526788.png?imageMogr2/thumbnail/!70p" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mybatis的SQL解析总体流程如下:</p><ol><li>构造ParamtersMap,保存输入参数.</li><li>构造ContextMap,为OGNL解析提供数据.</li><li>读取xml.使用SqlSource与SqlNode解析xml中的sql,设置参数值到boundSql的addtionParameters中,其为ContextMap的一个副本.</li><li>根据<code>boundSql.parameterMappings</code>获取到参数,从<code>addtionParameters</code>与<code>ParamtersMap</code>中读取参数设置到<code>PreparedStatement</code>中</li><li>执行sql<br>本文只分析了总体流程,其中有很多细节都忽略了,如遇到问题再看也不迟.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mybatis中参数解析对于开发人员来说是至关重要的,不然很容易出小问题,举个例子,假设现在方法为,当然这个是很糟糕的写法,这里只是想要搞清楚参数如何解析,项目中万万不可这样写.&lt;/p&gt;
&lt;h3 id=&quot;参数输入解析&quot;&gt;&lt;a href=&quot;#参数输入解析&quot; class=&quot;he
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(二)--Sqlsession的执行流程</title>
    <link href="http://mrdear.cn/2017/09/09/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)--Sqlsession%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://mrdear.cn/2017/09/09/mybatis/Mybatis源码分析(二)--Sqlsession的执行流程/</id>
    <published>2017-09-09T11:49:52.000Z</published>
    <updated>2017-09-09T11:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇Mapper动态代理中发现Mybatis会对Mapper接口的方法转向<code>mapperMethod.execute(sqlSession, args)</code>,那么该篇就学习Mybatis对于sql的执行总体流程,文章不会涉及很多细节点,重点学习其设计以及这样做的理由.</p><hr><h3 id="SqlCommand"><a href="#SqlCommand" class="headerlink" title="SqlCommand"></a>SqlCommand</h3><p><code>SqlCommand</code>是<code>MapperMethod</code>的一个内部类,其封装着要执行sql的id(xml的namespace+方法名)与类型(select,insert等),这些都是从<code>MappedStatement</code>中获取到,<code>MappedStatement</code>是mybatis初始化读取xml时所构造的对象,具体可以参考之前的文章.对于一个确定的Mapper接口中方法来说这个是确定的值.还有这里有些人认为是命令模式,我认为不是,这里只是该方法对应sql的唯一标识的体现,从下面代码Mybatis对其的使用来看,也不是命令模式具有的行为,而对于命令的执行实际上是<code>sqlSession</code>来执行的,而命令模式的要求是命令中封装委托对象,调用其excute()把任务交给委托执行的对象.<br><strong>Mybatis对sqlCommand的使用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object result;</div><div class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</div><div class="line">      <span class="keyword">case</span> INSERT: &#123;</div><div class="line">    Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> UPDATE: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      ...............</div></pre></td></tr></table></figure></p><h3 id="MethodSignature与ParamNameResolver"><a href="#MethodSignature与ParamNameResolver" class="headerlink" title="MethodSignature与ParamNameResolver"></a>MethodSignature与ParamNameResolver</h3><p><code>MethodSignature</code>也是<code>MapperMethod</code>中的一个内部类对象,其封装着该方法的详细信息,比如返回值类型,参数值类型等,分析该类可以得到Mybatis支持的返回类型有集合,Map,游标等各式各样,还支持自定义结果映射器.<br><code>ParamNameResolver</code>是用于方法参数名称解析并重命名的一个类,在Mybatis的xml中使用<code>#{0},#{id}</code>或者注解<code>@Param()</code>等写法都是合法的,为什么合法这个类就是解释,具体的分析过程因为跨度比较长,后面专用一篇文章来分析.</p><h3 id="INSERT-UPDATE-DELETE的结果处理"><a href="#INSERT-UPDATE-DELETE的结果处理" class="headerlink" title="INSERT,UPDATE,DELETE的结果处理"></a>INSERT,UPDATE,DELETE的结果处理</h3><p>对于这三种方法的执行,Mybatis会用<code>rowCountResult()</code>方法包裹结果,从源码中可以很清楚的看出来Mybatis只支持返回void,Integer,Long,Boolean类型的值,<strong>默认是int类型,这里建议数量查询使用int</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> Object result;</div><div class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</div><div class="line">    result = <span class="keyword">null</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</div><div class="line">    result = rowCount;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</div><div class="line">    result = (<span class="keyword">long</span>)rowCount;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</div><div class="line">    result = rowCount &gt; <span class="number">0</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() + <span class="string">"' has an unsupported return type: "</span> + method.getReturnType());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Select的处理"><a href="#Select的处理" class="headerlink" title="Select的处理"></a>Select的处理</h3><p>Select是最复杂的处理,其拥有多样的返回值类型,从源码中可以发现Mybatis支持自定义结果映射器,集合返回,Map返回,游标返回以及单条返回.具体该方法是属于哪一种类型在<code>MethodSignature</code>中都有定义,这里不多叙述.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SELECT:</div><div class="line">       <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</div><div class="line">         executeWithResultHandler(sqlSession, args);</div><div class="line">         result = <span class="keyword">null</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</div><div class="line">         result = executeForMany(sqlSession, args);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</div><div class="line">         result = executeForMap(sqlSession, args);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</div><div class="line">         result = executeForCursor(sqlSession, args);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">         Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">         result = sqlSession.selectOne(command.getName(), param);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>上述流程之后,SQL的执行就转交给<code>SqlSession</code>,这里会设置参数,去数据库查询,映射结果,可谓是Mybatis的核心.<code>SqlSession</code>下有如下四大对象.</p><ol><li>ParameterHandler: 处理参数设置问题</li><li>ResultHandler: 结果处理</li><li>StatementHandler: 负责连接数据库,执行sql</li><li>Executor: 对上述过程的调度组织.</li></ol><h3 id="Executor的桥接设计模式"><a href="#Executor的桥接设计模式" class="headerlink" title="Executor的桥接设计模式"></a>Executor的桥接设计模式</h3><p><code>Exexutor</code>是一种一对多的模式,所谓的一是对于调用方Client,其任务就是调度执行sql,获取结果返回,所谓的多是其实现可以有多种,比如Mybatis的<code>SimpleExecutor</code>,<code>ReuseExecutor</code>,<code>BatchExecutor</code>其实现这个功能的方式都有些差异,Mybatis在这里的实现就是采用了桥接设计模式,具体结构如下图.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504971925.png?imageMogr2/thumbnail/!100p" alt=""><br><strong>关于桥接模式或者其他设计模式可以参考此链接</strong><a href="https://github.com/me115/design_patterns/blob/master/structural_patterns/bridge.rst" target="_blank" rel="external">design_patterns</a><br>因为对于调用方来说只关心接口,因此这里提供<code>Exexutor</code>接口,对于内部多种实现把公共的部分比如缓存处理提取出来作为抽象类<code>BaseExecutor</code>,抽象类具有抽象方法与具体方法,那么最适合作为执行模板.其不同的内容定义为抽象方法,由其子类<code>SimpleExecutor</code>,<code>ReuseExecutor</code>等来实现.这一分支可以视作模板设计模式.<br>另外是一个<code>CachingExecutor</code>,Mybatis会在xml中根据配置<code>cacheEnabled</code>来初始化该类,默认为true,那么该类的作用也就是二级缓存.作为桥接类,其对其他的Executor进行调度,并缓存其结果,解耦接口与实现类之间的联系.</p><p>那么问题就来了</p><ul><li>桥接模式是怎么体现的?<blockquote><p>桥接模式主要是针对接口与实现类的桥接,按理说接口与实现类是属于强耦合的关系,那么使用桥接模式的话就可以去除这种耦合,桥接类中随时可以更换该接口的实现类,比如这里的<code>CacheingExecutor</code>其本身目的是二级缓存,但是二级缓存是针对<code>Executor</code>下的多个实现类,那么这里做下桥接则是一种很优雅的解决方式.</p></blockquote></li><li>二级缓存为什么不用插件形式来实现,反而用桥接模式来实现呢?<blockquote><p>这个问题估计需要我分析完插件设计后才能回答,也可能是其本身设计的问题.占坑.</p></blockquote></li><li><code>BaseExecutor</code>是一种怎样的设计?<blockquote><p>这里是很明显的模板设计,那么这里就要谈对抽象类以及接口的理解,个人认为抽象类与接口的不同之处在于接口定义的是协议,一般对外使用,抽象类定义的是过程,也就是模板,这也是抽象类中非抽象方法与抽象方法共存的优势.</p></blockquote></li></ul><p>除去上述问题,接下来的执行流程是很清晰的<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505400024.png?imageMogr2/thumbnail/!100p" alt=""></p><h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    BoundSql boundSql = ms.getBoundSql(parameter);<span class="comment">//获取sql,此时还都是?占位符状态的sql    </span></div><div class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); <span class="comment">//获取缓存key,根据id,sql,分页参数计算</span></div><div class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);<span class="comment">//跳到下面方法执行</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</div><div class="line">    <span class="keyword">if</span> (closed) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//queryStack用于延时加载,暂时未研究,若配置不用缓存,则每次查询前清空一级缓存.</span></div><div class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">      clearLocalCache();</div><div class="line">    &#125;</div><div class="line">    List&lt;E&gt; list;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      queryStack++;</div><div class="line">      <span class="comment">//缓存中取出数据,具体会在缓存详解中分析,这里只需要了解具体执行过程</span></div><div class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">//针对存储过程更新参数缓存</span></div><div class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//缓存未中则去查数据库</span></div><div class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      queryStack--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这边是延迟加载的实现,不在本次分析内容中</span></div><div class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</div><div class="line">        deferredLoad.load();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// issue #601</span></div><div class="line">      deferredLoads.clear();</div><div class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</div><div class="line">        <span class="comment">// issue #482</span></div><div class="line">        clearLocalCache();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>接下来是DB的查询,DB的查询主要由其子类来实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">  List&lt;E&gt; list;</div><div class="line">  <span class="comment">//这里先放入缓存中占位符,一级缓存的实现</span></div><div class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//调用子类的方法处理,模板方法的体现</span></div><div class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    localCache.removeObject(key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//放入查询结果缓存,一级缓存的实现</span></div><div class="line">  localCache.putObject(key, list);</div><div class="line">  <span class="comment">//存储过程还需要缓存参数</span></div><div class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">    localOutputParameterCache.putObject(key, parameter);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p>按照上述模板的执行,<code>SimpleExecutor</code>是真正从数据库查询的地方,这里也能看出来模板设计模式的好处,将缓存处理与实际数据查询分离解耦,各司其职.<br>查询是要经过<code>StatementHandler</code>组织<code>ParameterHandler</code>,<code>ResultHandler</code>的处理过程,那么<code>StatementHandler</code>承担了什么样的角色?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">  Statement stmt = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Configuration configuration = ms.getConfiguration();</div><div class="line">    <span class="comment">//创建statement</span></div><div class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">    <span class="comment">//获取连接,设置参数等预处理</span></div><div class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</div><div class="line">    <span class="comment">//执行查询并映射结果</span></div><div class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    closeStatement(stmt);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>…<br>篇幅已经过长了,剩下的<code>StatementHandler</code>等也是类似的设计,不打算再继续分析了,有兴趣的同学可以自己研究一下.接下来会对一些关键点的实现分析,比如sql的解析,延迟加载的实现等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇Mapper动态代理中发现Mybatis会对Mapper接口的方法转向&lt;code&gt;mapperMethod.execute(sqlSession, args)&lt;/code&gt;,那么该篇就学习Mybatis对于sql的执行总体流程,文章不会涉及很多细节点,重点学习其设计以
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(一)--Mapper的动态代理</title>
    <link href="http://mrdear.cn/2017/09/07/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)--Mapper%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://mrdear.cn/2017/09/07/mybatis/Mybatis源码分析(一)--Mapper的动态代理/</id>
    <published>2017-09-07T14:04:05.000Z</published>
    <updated>2017-09-07T14:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中用的最多的就是Mybatis这款半自动ORM框架,用的久却对其了解不是很深,因此打算开一系列文章对其进行解析,顺便对知识进行查漏补缺.本篇是对Mapper动态代理原理的详解.</p><hr><h3 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h3><p>为另一个对象提供一个替身或者占位符以控制对这个对象的访问.也就是说目的是控制对象形式其职责.当然也可以增强其职责,比如Spring AOP.</p><h3 id="代理模式类图"><a href="#代理模式类图" class="headerlink" title="代理模式类图"></a>代理模式类图</h3><p>由下图分析,代理模式所需要的角色为:</p><ol><li>对外的行为接口Subject,对于调用方Client可见</li><li>RealSubject真实的Subject,其包含具体的接口行为,对于Client不可见</li><li>代理类Proxy,其是RealSubject的替身,也可以当成对RealSubject的一层包装,对于Client不可见.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504793889.png?imageMogr2/thumbnail/!150p" alt=""></li></ol><h3 id="JDK动态代理Example"><a href="#JDK动态代理Example" class="headerlink" title="JDK动态代理Example"></a>JDK动态代理Example</h3><p>案例采取Java的动态代理形式开发,按照上述类图定义角色<br><strong>Subject</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 反转输入的input字符串</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> input 要反转的串</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> 反转后的串</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function">String <span class="title">reversalInput</span><span class="params">(String input)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>RealSubject</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">reversalInput</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"我是RealSubject: "</span>+input);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(input).reverse().toString();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>SubjectProxy</strong><br>该类实现了InvocationHandler,实际上是对调用的拦截,拦截后转向真实对象的调用,从而拿到正确的结果.是不是很像装饰者模式?其实也可以这样理解,设计模式之前本身就有很多关联性,不需要认定某一个行为就是单一的某个模式,从产生效果来看这里的SubjectProxy实际上就是对RealSubject的装饰,只不过这个装饰并没有添加新功能.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxy</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.target = target;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    System.out.println(<span class="string">"proxy subject is "</span>+proxy.getClass());</div><div class="line">    System.out.println(<span class="string">"real subject : "</span>+ToStringBuilder.reflectionToString(target));</div><div class="line">    System.out.println(<span class="string">"method: "</span>+method);</div><div class="line">    System.out.println(<span class="string">"args: "</span>+ ToStringBuilder.reflectionToString(args));</div><div class="line">    <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Client</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    RealSubject subject = <span class="keyword">new</span> RealSubject();</div><div class="line"></div><div class="line">    Subject proxyInstance = (Subject) Proxy.newProxyInstance(</div><div class="line">        Subject.class.getClassLoader(),</div><div class="line">        <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,</div><div class="line">        <span class="keyword">new</span> SubjectProxy(subject));</div><div class="line"></div><div class="line">    System.out.println(proxyInstance.reversalInput(<span class="string">"hello world"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>输出</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proxy is class com.sun.proxy.$Proxy0</div><div class="line">target proxy: cn.mrdear.proxy.RealSubject@51016012[]</div><div class="line">method: public abstract java.lang.String cn.mrdear.proxy.Subject.reversalInput(java.lang.String)</div><div class="line">args: [Ljava.lang.Object;@29444d75[&#123;hello world&#125;]</div><div class="line">我是RealSubject: hello world</div><div class="line">dlrow olleh</div></pre></td></tr></table></figure></p><p><strong>分析</strong><br>1.动态代理哪里体现了动态?</p><blockquote><p>对于常规Java类变量创建要求有.java文件,然后编译成.class文件,然后虚拟机加载该.class文件,最后才能生成对象.但是对于<code>Subject proxyInstance</code>该代理类其是不存在.java文件的,也就是该对象的.class文件是动态生成的,然后虚拟机加载该class文件,创建对象.在Proxy.java中有如下代码动态生成class文件,感兴趣的话可以研究研究,这里不多深入.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Generate the specified proxy class.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</div></pre></td></tr></table></figure></p></blockquote><p>2.JDK动态代理的要求</p><blockquote><p>JDK动态代理只能针对接口,如果要针对普通类则可以考虑CGLib的实现,这里不多分析.其次动态代理的要求有接口类<code>Subject</code>,<code>InvocationHandler</code>代理方法类存在,才能创建出代理对象,代理对象的执行方法都被<code>InvocationHandler</code>接口所拦截,转向真实类的执行或者你想要的操作.</p></blockquote><h3 id="Mybatis的动态Mapper"><a href="#Mybatis的动态Mapper" class="headerlink" title="Mybatis的动态Mapper"></a>Mybatis的动态Mapper</h3><p>由上面内容可以看出JDK动态代理需要接口,真实实现类,Clinet调用方,在常规的Mybatis的Mapper代理中接口就是Mapper,Client是service,那么真实的实现类是什么?显而易见这里就是Mapper代理的关键点.</p><h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><p>顾名思义该类是产生Mapper接口的工厂类,其内部有如下方法,由此可以看出<code>MapperProxy</code>是方法拦截的地方,那么到此动态代理所需要的必须角色都以凑齐,那么接下来分析最重要的<code>MapperProxy</code>方法拦截.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><p>该类是Mapper接口的Proxy角色,继承了<code>InvocationHandler</code>,所以具有方法拦截功能,看代码注释.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123; <span class="comment">////判断是否为object,因为其不是接口</span></div><div class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123; <span class="comment">//判断是否为接口总的默认方法,jdk8允许接口中声明默认方法.</span></div><div class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对正常Mapper请求的处理</span></div><div class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</div><div class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于正常的Mapper接口中的方法调用,mybatis都会转向到<code>MapperMethod</code>的execute方法中执行,拿到结果返回给调用方Client,整个代理过程结束.对于正常调用是有缓存的,并且该代理类是项目启动时就生成好的,对于性能影响并不是很大实用性还是很高的.</p><p>这里要注意下对于默认接口方法的处理<code>invokeDefaultMethod(proxy, method, args)</code>,该方法中每次都直接生成代理类,对性能是一种损耗应该不小,所以<strong>不建议在Mapper接口中写默认方法</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@UsesJava</span>7</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class</div><div class="line">      .getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</div><div class="line">  <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</div><div class="line">    constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</div><div class="line">  <span class="keyword">return</span> constructor</div><div class="line">      .newInstance(declaringClass,</div><div class="line">          MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</div><div class="line">              | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</div><div class="line">      .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面来看动态代理的最大的好处就是接口(不单指Java的interface,也包括CGLib的动态代理实现)与其实现类的解耦,原本接口和动态类之间是强关联状态,接口不能实例化,实现类必须实现接口的所有方法,有了动态代理之后,接口与实现类的关系并不是很大,甚至不需要实现类就可以完成调用,比如Mybatis这种形式,其并没有创建该接口的实现类,而是用一个方法拦截器转向到自己的通用处理逻辑.<br>另外就是Spring AOP的动态代理,解耦后自然可以实现对原有方法增强的同时又对其代码的零侵入性.<br>最后Mybatis的Mapper动态代理实现原理还是很清晰的,下一篇具体分析<code>MapperMethod</code>,顺便学习Mybatis的各种设计模式.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中用的最多的就是Mybatis这款半自动ORM框架,用的久却对其了解不是很深,因此打算开一系列文章对其进行解析,顺便对知识进行查漏补缺.本篇是对Mapper动态代理原理的详解.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;代理模式定义&quot;&gt;&lt;a href=&quot;#代理模式定义&quot; cla
      
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
      <category term="设计模式" scheme="http://mrdear.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>cnpm导致IDEA对于Angular项目提示失效</title>
    <link href="http://mrdear.cn/2017/08/26/web/Cnpm%E5%AF%BC%E8%87%B4IDEA%E5%AF%B9%E4%BA%8EAngular%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BA%E5%A4%B1%E6%95%88/"/>
    <id>http://mrdear.cn/2017/08/26/web/Cnpm导致IDEA对于Angular项目提示失效/</id>
    <published>2017-08-26T03:17:15.000Z</published>
    <updated>2017-08-26T03:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写Angular项目的时候,IDEA的提示时而有时而没有,找了好久的原因才发现是cnpm的锅.<br>对于<code>cnpm install</code>,安装的angular依赖时链接方式引入,如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717543.png?imageMogr2/thumbnail/!70p" alt=""></p><p>对于<code>npm install</code>,安装后的依赖时实在的文件,如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717577.png?imageMogr2/thumbnail/!70p" alt=""></p><p>解决方案老老实实的用npm命令,觉得慢的话可以使用http代理,mac下的shadowsocks支持直接导出http代理,复制命令后粘贴到终端,即可实现终端翻墙.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717675.png?imageMogr2/thumbnail/!70p" alt=""></p><p>如果你不会翻墙,可以参考我之前写的教程  <a href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/">如何搭建属于自己的shadowsocks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写Angular项目的时候,IDEA的提示时而有时而没有,找了好久的原因才发现是cnpm的锅.&lt;br&gt;对于&lt;code&gt;cnpm install&lt;/code&gt;,安装的angular依赖时链接方式引入,如下图&lt;br&gt;&lt;img src=&quot;http://oobu4m7ko.bk
      
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
      <category term="idea" scheme="http://mrdear.cn/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>动漫推荐</title>
    <link href="http://mrdear.cn/2017/08/25/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"/>
    <id>http://mrdear.cn/2017/08/25/动漫/动漫推荐/</id>
    <published>2017-08-25T03:26:23.000Z</published>
    <updated>2017-08-25T03:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动漫推荐"><a href="#动漫推荐" class="headerlink" title="动漫推荐"></a>动漫推荐</h1><p>标签（空格分隔）： 动漫</p><hr><p>从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典动漫剧场版.我也不知道自己是什么风格的动漫迷,只是觉得好看,有共鸣就认为是好作品.人们总是把自己喜爱的东西推荐给别人,我也不例外,下面推荐我认为很不错的片子.(排名不分先后)</p><h3 id="异邦人-无皇刃谭"><a href="#异邦人-无皇刃谭" class="headerlink" title="异邦人 无皇刃谭"></a>异邦人 无皇刃谭</h3><p>2017年初来在上海实习时看的,故事很温情,对于刚到一个陌生城市打拼的青年来说很容易引起共鸣,也因此我感触颇深,异邦人都是孤独的存在,内心是挣扎的,想要找到自己的归属,然而哪里才是归属?背景音乐很赞,听起来内心有点温暖,但是又会觉得很伤感,充满了无奈</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=508793&auto=0&height=66"></iframe><h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>大概高一的时候第一次看了这个作品,唯美的画面,伤感的故事,再加上年少懵懂的恋爱经历,从此新海诚一生粉.回想以前是不是很多事情都可以 <code>One more time,One more chance</code></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=540968&auto=0&height=66"></iframe><h3 id="你看起来很好吃"><a href="#你看起来很好吃" class="headerlink" title="你看起来很好吃"></a>你看起来很好吃</h3><p>相当有趣的一部动漫,看起来完全没有负重感,从母爱,父爱,独立,自强等方面诠释了一个龙的成长.电影版是温情的结局,萌萌的画面,治愈的故事,给心情带来不一样的体验.<br>记住:哭闹的孩子 不管在哪里都会被霸王龙叼走</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=795251922&auto=0&height=66"></iframe><h3 id="萤火之森"><a href="#萤火之森" class="headerlink" title="萤火之森"></a>萤火之森</h3><p>无法触碰的爱情,只是梦中的憧憬,这样的动漫是提醒你,在你年轻的时候曾经心里也住着一个无法触碰的他/她.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=541381&auto=0&height=66"></iframe><h3 id="fate-stay-night"><a href="#fate-stay-night" class="headerlink" title="fate stay night"></a>fate stay night</h3><p>作为番剧来说最喜欢的一个系列,fate stay night也是最早出来的一部,配乐,战斗,剧情都那么引人入胜,虽然fate zero也非常不错,但是让我来选择的话还是该部更让我难忘.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=448119&auto=0&height=66"></iframe><h3 id="怪物之子"><a href="#怪物之子" class="headerlink" title="怪物之子"></a>怪物之子</h3><p>细田守家族系列电影,复杂成长的环境会造成我们内心的空洞,然而填补这些空洞的方式就是父母的爱,即使在你眼中认为一无是处,半吊子的父亲,在最关键的时候也会奋不顾身的化身为剑去填补你内心的黑暗,细细回想小时候学习父亲的一举一动或许是每个人都无法忘记的时刻.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26352841&auto=0&height=66"></iframe><h3 id="斩·赤红之瞳"><a href="#斩·赤红之瞳" class="headerlink" title="斩·赤红之瞳"></a>斩·赤红之瞳</h3><p>有点虐的番剧,几乎每个角色都是主角的设定,所以每个人角色的个性都很鲜明,也导致了每一个人物死去所带来的感染力.尤其看到结局,最初的一群角色就剩一个赤瞳了,其帮助革命军成立了新国家,然而其还要背负革命军为了革命所做的恶.该番剧有点杀红了眼,所以看的话就要做好心理准备.</p><h3 id="亚人"><a href="#亚人" class="headerlink" title="亚人"></a>亚人</h3><p>这两周把亚人的电影版和TV版都看了一遍,首先电影版绝对是圈钱的作品,还是直接看TV版本吧,剧情一样.整个看下来感觉亚人一部很理性的动漫,无论是主角的处事风格,还是亚人和搜查官的联合,都是利益组建了一个关系网,截止到第二季来说目前还是这样的理性,不知道后期有没有变化.能把不死这一老套的技能演绎出这么多惊心动魄的故事场景的估计也只有亚人了吧.另外这动漫也透漏出政府只是比较大的土匪头子而已.</p><h3 id="犬夜叉剧场版"><a href="#犬夜叉剧场版" class="headerlink" title="犬夜叉剧场版"></a>犬夜叉剧场版</h3><p>犬夜叉是儿时的回忆,尤其是其四个剧场版,小时候最喜欢看<code>天下霸道之剑</code>这一部,犬夜叉相比火影之类动漫的优点是其有一条爱情线,犬夜叉与阿离(我喜欢台版的这个翻译),犬夜叉与桔梗这之间复杂但却互相信任的关系.最喜欢的人物莫过于桔梗,其只是想过上普通的生活,然而命运却让其至死也无法得到想要的生活,悲情人物总能引起观看者的同情.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=463673252&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动漫推荐&quot;&gt;&lt;a href=&quot;#动漫推荐&quot; class=&quot;headerlink&quot; title=&quot;动漫推荐&quot;&gt;&lt;/a&gt;动漫推荐&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 动漫&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典
      
    
    </summary>
    
      <category term="动漫" scheme="http://mrdear.cn/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://mrdear.cn/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习记录(一)--环境部署</title>
    <link href="http://mrdear.cn/2017/08/19/%E8%BF%90%E7%BB%B4/Zookeeper%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)--%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>http://mrdear.cn/2017/08/19/运维/Zookeeper学习记录(一)--环境部署/</id>
    <published>2017-08-19T01:34:10.000Z</published>
    <updated>2017-08-19T01:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>zk在公司系统中承担着一个很重要的角色,因此作为开发有必要了解关于zk的一些知识,推荐文档资料<a href="http://www.majunwei.com/category/201612011952003333/" target="_blank" rel="external">Zookeeper文档目录</a>.</p><hr><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><p>zk的安装很简单,只需要下载修改配置启动即可,本文主要是用Docker方式安装,直接上Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># Version 0.0.1</div><div class="line">FROM java:8</div><div class="line">MAINTAINER quding mrdear.cn </div><div class="line"></div><div class="line">#修改源信息</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse&quot; &gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse&quot;&gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse&quot;&gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;APT::Get::AllowUnauthenticated 1 ;&quot; &gt;&gt; /etc/apt/apt.conf</div><div class="line"></div><div class="line">#更新源,并安装vim</div><div class="line">RUN apt-get update</div><div class="line">RUN apt install vim -y</div><div class="line"></div><div class="line">ENV ZOOKEEPER_VERSION 3.4.9</div><div class="line"></div><div class="line"># 下载zk</div><div class="line">RUN wget -q http://mirror.vorboss.net/apache/zookeeper/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;.tar.gz</div><div class="line"></div><div class="line"># 安装</div><div class="line">RUN tar -xvf zookeeper-$&#123;ZOOKEEPER_VERSION&#125;.tar.gz -C /opt</div><div class="line"></div><div class="line"># 配置zoo.cfg</div><div class="line">RUN mv /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/conf/zoo_sample.cfg /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/conf/zoo.cfg</div><div class="line">ENV ZK_HOME /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;</div><div class="line"></div><div class="line">RUN sed  -i &quot;s|/tmp/zookeeper|$ZK_HOME/data|g&quot; $ZK_HOME/conf/zoo.cfg; mkdir $ZK_HOME/data</div><div class="line"></div><div class="line">EXPOSE 2181 2888 3888</div><div class="line"></div><div class="line">WORKDIR /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;</div><div class="line">VOLUME [&quot;/opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/conf&quot;, &quot;/opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/data&quot;]</div><div class="line"></div><div class="line">CMD bash /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/bin/zkServer.sh start-foreground</div></pre></td></tr></table></figure></p><p>build之后,启动该docker image,暴露出2181端口,然后使用zkClient.sh连接即可操作.</p><h3 id="多机部署"><a href="#多机部署" class="headerlink" title="多机部署"></a>多机部署</h3><p>多机部署主要参考文章<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html" target="_blank" rel="external">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a>.下面说下注意事项.</p><h4 id="注意端口配置"><a href="#注意端口配置" class="headerlink" title="注意端口配置"></a>注意端口配置</h4><p><strong>initLimit</strong>：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000=10 秒<br><strong>syncLimit</strong>：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2</em>2000=4 秒<br><strong>server.A=B：C：D</strong>：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p><h4 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h4><p>zk是主从复制形式,那么只要在leader节点中插入一个node,然后去salve中查看该node是否存在即可.</p><h3 id="如何连接"><a href="#如何连接" class="headerlink" title="如何连接?"></a>如何连接?</h3><p>zk的安装目录下bin中有zkCli.sh,该工具格式为<code>zkCli.sh -server host:port</code>,使用其可以对zk进行增删改查,具体命令使用参数<code>-?</code>即可翻阅.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;zk在公司系统中承担着一个很重要的角色,因此作为开发有必要了解关于zk的一些知识,推荐文档资料&lt;a href=&quot;http://www.majunwei.com/category/201612011952003333/&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="运维" scheme="http://mrdear.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="zookeeper" scheme="http://mrdear.cn/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>OpenVZ的VPS加速指南</title>
    <link href="http://mrdear.cn/2017/08/13/%E5%B7%A5%E5%85%B7/OpenVZ%E7%9A%84VPS%E5%8A%A0%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    <id>http://mrdear.cn/2017/08/13/工具/OpenVZ的VPS加速指南/</id>
    <published>2017-08-13T14:39:05.000Z</published>
    <updated>2017-08-13T14:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h3><p>OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较好的方案是Google BBR加速,为了在OpenVZ架构上使用必须借助UML这一子linux系统.</p><p>所谓的UML全称为User Mode Linux,允许用户在Linux中以一个进程的方式再运行一个lInux,那么就很容易实现我们所需要的加速架构,原理是在UML中启动Shadowsocks,然后访问该Shadowsocks实现加速.</p><h3 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h3><p>拿来主义原则,给出原博主链接<a href="https://www.91yun.co/archives/5345" target="_blank" rel="external">OpenVZ的UML+BBR加速一键包</a>,按照文章描述步骤配置即可,在这里做一些额外的补充.</p><p><strong>宿主机请求转发</strong><br>一键脚本配置完毕后其是运行在UML主机里面的程序,其内网相对宿主机ip为<code>10.0.0.2</code>,但我们只能访问到宿主机,需要如下命令转发,其中端口<code>8888</code>改成你的ss配置的端口即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -i venet0 -p tcp --dport 8888 -j DNAT --to-destination 10.0.0.2</div><div class="line">iptables -t nat -A PREROUTING -i venet0 -p udp --dport 8888 -j DNAT --to-destination 10.0.0.2</div></pre></td></tr></table></figure><p>接下来像以往一样访问即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现理论&quot;&gt;&lt;a href=&quot;#实现理论&quot; class=&quot;headerlink&quot; title=&quot;实现理论&quot;&gt;&lt;/a&gt;实现理论&lt;/h3&gt;&lt;p&gt;OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较
      
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建属于自己的shadowsocks</title>
    <link href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/"/>
    <id>http://mrdear.cn/2017/08/07/工具/如何搭建属于自己的shadowsocks/</id>
    <published>2017-08-07T15:19:01.000Z</published>
    <updated>2017-08-07T15:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shadowsocks是什么"><a href="#shadowsocks是什么" class="headerlink" title="shadowsocks是什么?"></a>shadowsocks是什么?</h3><p>能看到这篇文章的人大概对这个都有些了解,可以理解为一个代理隧道,通过其可以代理到指定的vps服务器,然后服务器去获取到你所访问的内容再返回给你.<br>如果你把服务器当做跳板机的话,那么shadowsocks就是你与跳板机之间的关联.</p><h3 id="vps服务器的选择"><a href="#vps服务器的选择" class="headerlink" title="vps服务器的选择"></a>vps服务器的选择</h3><p>vps服务器有很多,这里推荐下搬瓦工KVM架构的机器,推荐理由便宜,可靠,支持支付宝.</p><blockquote><p>不介意可以使用我的邀请链接: <a href="https://bandwagonhost.com/aff.php?aff=17639" target="_blank" rel="external">https://bandwagonhost.com/aff.php?aff=17639</a></p></blockquote><p>注册后选择最便宜款的KVM架构,重要的事情说三遍,KVM架构,KVM架构,KVM架构.至于好处是可以使用锐速,能让你的shadowsocks更加快.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120173.png?imageMogr2/thumbnail/!70p" alt=""><br>接下来是选择付款方案,一般选择$19.9的年付,三四个小伙伴一起用,平摊这个费用的话,就相当划算了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120257.png?imageMogr2/thumbnail/!70p" alt=""><br>买完后会进去类似的管理后台,选择一键安装即可.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120362.png?imageMogr2/thumbnail/!70p" alt=""><br>到这里,vps服务端的shadowsocks就部署完毕了.接下来是客户端连接.</p><h3 id="shadowsocks客户端"><a href="#shadowsocks客户端" class="headerlink" title="shadowsocks客户端"></a>shadowsocks客户端</h3><p>在github上有各个平台的客户端<a href="https://github.com/shadowsocks" target="_blank" rel="external">https://github.com/shadowsocks</a>,windows一般用<code>shadowsocks-windows</code>,mac用<code>ShadowsocksX-NG</code>,linux则用<code>shadowsocks-qt5</code>,下载对应客户端,配置好vps生成的shadowsocks端口和密码,启用即可,其主要作为一个本地服务器,其他应用软件通过其余vps服务器通信.</p><p><strong>如何访问?</strong><br>浏览器安装插件<a href="https://switchyomega.com/" target="_blank" rel="external">switchyomega</a>,该插件会代理浏览器的请求链接,根据规则列表决定该链接是否要使用shadowsocks代理.<br>首先新建一个代理模式,该模式下所有请求都会走shadowsocks.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120910.png?imageMogr2/thumbnail/!70p" alt=""><br>其次建立一个自动情景切换模式,该模式会根据配置的规则自动选择对应的情景模式来处理.该模式主要分为三部分,第一部分是用户自定义,比如图片中我指定匹配<code>*.github.com</code>的连接走的是ss情景模式.<br>第二部分是规则列表,我配置的为<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>,该文件中是被墙的一些地址,这些地址都走ss情景模式,其余的都是直接连接.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502121104.png?imageMogr2/thumbnail/!70p" alt=""></p><p>接下来就可以访问google了.</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p>锐速安装教程: <a href="https://github.com/91yun/serverspeeder" target="_blank" rel="external">https://github.com/91yun/serverspeeder</a><br>Google BBR : <a href="https://teddysun.com/489.html" target="_blank" rel="external">https://teddysun.com/489.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;shadowsocks是什么&quot;&gt;&lt;a href=&quot;#shadowsocks是什么&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks是什么?&quot;&gt;&lt;/a&gt;shadowsocks是什么?&lt;/h3&gt;&lt;p&gt;能看到这篇文章的人大概对这个都有些了解,
      
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>maven仓库清理脚本</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://mrdear.cn/2017/07/29/工具/maven仓库清理脚本/</id>
    <published>2017-07-29T14:40:15.000Z</published>
    <updated>2017-07-29T14:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.<br>没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.</p><p>附上清理脚本,实际上就是递归遍历文件夹然后判断文件更新时间,对比后决定是否要删除.首次清理后仓库从1.5G变为650M,清爽了不少.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> shutil</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="comment"># maven仓库地址</span></div><div class="line">mvnHome = <span class="string">"/Users/niuli/.m2/repository"</span></div><div class="line"><span class="comment"># 删除该日期前的文件以及文件夹</span></div><div class="line">deleteDateBefore = datetime(<span class="number">2017</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listPathAndClean</span><span class="params">(pathContext)</span>:</span></div><div class="line">    pathDir = os.listdir(pathContext)</div><div class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> pathDir:</div><div class="line">        filepath = os.path.join(pathContext, filename)</div><div class="line">        currentTimeFile = datetime.fromtimestamp(os.path.getmtime(filepath))</div><div class="line"></div><div class="line">        <span class="comment"># 对比时间</span></div><div class="line">        <span class="keyword">if</span> deleteDateBefore &gt; currentTimeFile:</div><div class="line">            print(<span class="string">"filePath:"</span>+filepath+<span class="string">"-----updatetime:"</span>+str(currentTimeFile))</div><div class="line">            print(<span class="string">'delete this'</span>)</div><div class="line">            <span class="keyword">if</span> (os.path.isdir(filepath)):</div><div class="line">                shutil.rmtree(filepath)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                os.remove(filepath)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">            </div><div class="line">        <span class="comment"># 不到期的则深入遍历</span></div><div class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</div><div class="line">            listPathAndClean(filepath)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(deleteDateBefore)</div><div class="line">    print(<span class="string">'start list should delete path'</span>)</div><div class="line">    listPathAndClean(mvnHome)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.&lt;br&gt;没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.&lt;/p&gt;
&lt;p&gt;附上清理脚本,实际上就是递归遍历文件
      
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven子模块打包后拷贝目标文件到父模块</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/Maven%E5%AD%90%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%90%8E%E6%8B%B7%E8%B4%9D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%B0%E7%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>http://mrdear.cn/2017/07/29/工具/Maven子模块打包后拷贝目标文件到父模块/</id>
    <published>2017-07-29T07:15:56.000Z</published>
    <updated>2017-07-29T07:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>看着这个标题一定想怎么会有这么奇怪的需求….<br>嗯,我也认为这个是很奇怪的需求,但实际上确实存在.</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近对公司一个大项目进行整改,该项目是写在一个模块下,也就是一个Maven项目,因此打算把其更改为Maven多模块项目.目录结构的变化如下:<br>原目录结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buy</div><div class="line">   ---src</div><div class="line">       ---main</div><div class="line">       ---test</div><div class="line">   ---conf</div></pre></td></tr></table></figure></p><p>更改后的为,也就是按照业务分为三个部分,其中gateway是打包的入口,不含有业务逻辑,其引用其他两个模块.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">buy</div><div class="line">   ---buy-shop</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---buy-course</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---buy-gateway</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---conf</div></pre></td></tr></table></figure></p><p>那么自然而然打包后生成的buy.war就到了<code>buy-gateway/target</code>这个目录下,对于<code>master</code>分支的代码是生成在<code>buy/target</code>目录下,这样就倒是线上的自动化打包失效,首先保证master能打包成功就不能更改线上的配置,因此需要把<code>buy-gateway/target/buy.war</code>打包成功后拷贝到<code>buy/target/buy.war</code>,保证线上打包脚本的运行.</p><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案是<code>maven-dependency-plugin</code>这款插件,该插件有copy功能,可以自由选择target目录下的任意文件拷贝(要注意该插件不同版本配置是有差异的,如果一直不成功就要检查下配置)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">artifactItems</span>&gt;</span></div><div class="line">                        <span class="comment">&lt;!--把target目录下的war拷贝到buy/target下--&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">artifactItem</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">type</span>&gt;</span>$&#123;project.packaging&#125;<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">overWrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWrite</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.parent.build.directory&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">destFileName</span>&gt;</span>buy.war<span class="tag">&lt;/<span class="name">destFileName</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">artifactItem</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">artifactItems</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p><p>该模块可以用于各种资源的拷贝,因此不要局限于war包</p><p><strong>备注</strong>:<br>maven中常见的变量 <a href="http://qiaolevip.iteye.com/blog/1816652" target="_blank" rel="external">maven常用配置的变量</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看着这个标题一定想怎么会有这么奇怪的需求….&lt;br&gt;嗯,我也认为这个是很奇怪的需求,但实际上确实存在.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近对公司一
      
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>病态的开发模式</title>
    <link href="http://mrdear.cn/2017/07/28/%E9%9A%8F%E8%B0%88/%E7%97%85%E6%80%81%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://mrdear.cn/2017/07/28/随谈/病态的面向对象开发/</id>
    <published>2017-07-28T04:51:50.000Z</published>
    <updated>2017-07-28T04:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对象吗?</p><p>我苦恼于这个问题,不清楚自己做的事情有什么意义,每次需求最重要的部分就是建立表了,然后”重复性”的写各个层次,顶多用点设计模式在service,strategy,factory等之上,这种开发使我产生了厌烦的情绪,我想这个应该不是所谓的面向对象.</p><p>查询一些资料,发现疑惑的不止我一个,我得知<code>贫血模型</code>这一关键词,所谓的贫血模型指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。也就是目前大多数Java项目使用的结构,这样的结构决定了实现之前必须要先设计表结构.那么这和面向对象就没什么关联了.</p><p>与<code>贫血模型</code>相对应,充血模型也就是所谓的面向对象形式,我还没有去用过,不敢枉加主观看法,随着搜索我发现了DDD即领域驱动设计这一充血模型的实现,打算好好看看.</p><p>无论怎么样,我认为Java WEB目前的开发形式是有点小问题的</p><p>希望后续的学习能够解决我的疑问.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对
      
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="面向对象" scheme="http://mrdear.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于老项目替换dubbo的一点经验</title>
    <link href="http://mrdear.cn/2017/07/23/dubbo/%E5%85%B3%E4%BA%8E%E8%80%81%E9%A1%B9%E7%9B%AE%E6%9B%BF%E6%8D%A2dubbo%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%8F%E9%AA%8C/"/>
    <id>http://mrdear.cn/2017/07/23/dubbo/关于老项目替换dubbo的一点经验/</id>
    <published>2017-07-23T01:07:41.000Z</published>
    <updated>2017-07-23T01:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司一直以来使用内部编写的一个rpc框架,简称old_rpc这套RPC框架,由于历史原因,old_rpc存在如下缺点.</p><ol><li>old_rpc已经很久没人维护了,因此出了错误很难定位到具体的原因.</li><li>old_rpc本身只是RPC框架,随着项目的增多各个项目之间的依赖关系已经很复杂了,需要一套支持服务治理的解决方案.</li><li>old_rpc缺乏监控平台,对于动态部署,增加机器或者减少机器都比较麻烦.</li><li>…<br>这些缺点已经严重影响到线上稳定性,本文就dubbox替换掉old_rpc方案做的一个调研,对工作量,替换后的稳定性做一个评估,以供大家参考.</li></ol><h3 id="替换要求"><a href="#替换要求" class="headerlink" title="替换要求"></a>替换要求</h3><ol><li>支持平滑上线,也就是说替换后依然支持现有的测试系统,发布系统.</li><li>替换必须尽可能小的缩小对业务的影响,代码层面上来看就是业务处理代码中不应该有替换的代码</li><li>短期内需要支持dubbox与old_rpc两套方案,并且两套方案可以快速切换,防止替换后线上出现不可预料的问题.</li></ol><h3 id="替换思路"><a href="#替换思路" class="headerlink" title="替换思路"></a>替换思路</h3><ol><li>saturn作为服务提供者,替换比较简单,只需要在原有基础上,增加dubbo协议的Service.</li><li>vienna作为消费者,使用dubbo协议引入dubbo的service</li><li>vienna增加断路器配置,对于repo层引入的service,dubbox作为主service,old_rpc作为备份service,当主service调用失败则自动切换到备份service进行重试,此过程需要有监控.</li></ol><h3 id="dubbox"><a href="#dubbox" class="headerlink" title="dubbox"></a>dubbox</h3><ul><li>github: <a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a><br>clone下来后使用<code>mvn package -DskipTests</code>,会打包该项目,生成主要的<strong>dubbo.jar</strong>,以及管理平台<strong>dubbo-admin.war</strong>,监控平台<strong>dubbo-simple-monitor.tar.gz</strong>.我已经把相关jar,deploy到公司的nexus上了.mvn的pom中直接引入如下依赖,这里需要去除Spring依赖,dubbox是基于Spring3开发的,强制引入会与现有项目产生冲突.<br>另外dubbox添加了kryo和FST序列化支持,以及多种新特性,使用的话均需要引入相应的jar,具体参考项目的github.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</div><div class="line">           &lt;version&gt;2.8.4&lt;/version&gt;</div><div class="line">           &lt;exclusions&gt;</div><div class="line">               &lt;exclusion&gt;</div><div class="line">                   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">                   &lt;artifactId&gt;*&lt;/artifactId&gt;</div><div class="line">               &lt;/exclusion&gt;</div><div class="line">           &lt;/exclusions&gt;</div><div class="line">       &lt;/dependency&gt;</div></pre></td></tr></table></figure></li></ul><h4 id="zk注册中心"><a href="#zk注册中心" class="headerlink" title="zk注册中心"></a>zk注册中心</h4><p>dubbo的注册如下所示:<br><img src="http://oobu4m7ko.bkt.clouddn.com/1500736706.png?imageMogr2/thumbnail/!100p" alt=""><br>实际操作下来,第三层还会有<code>routers</code>,<code>configurators</code>节点,当在dubbo-admin平台操作该service时,比如倍权,该操作会存在在这些节点中.</p><h4 id="服务提供者saturn"><a href="#服务提供者saturn" class="headerlink" title="服务提供者saturn"></a>服务提供者saturn</h4><p>saturn作为服务提供者,其任务是抛出新的dubbo服务RPC接口.在引入上述pom后,需要做少量的配置.</p><h5 id="dubbo基本配置"><a href="#dubbo基本配置" class="headerlink" title="dubbo基本配置"></a>dubbo基本配置</h5><p>因此demo只测试能否实现,每一个配置的详细内容并未研究,详细可以参考官方文档配置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 注册中心配置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">    registryConfig.setAddress(<span class="string">"115.159.185.14:2181"</span>);</div><div class="line">    registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">    <span class="keyword">return</span> registryConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 当前应用配置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">application</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</div><div class="line">    applicationConfig.setName(<span class="string">"saturn"</span>);</div><div class="line">    <span class="keyword">return</span> applicationConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 监控配置,监控需要dubbo-monitor</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MonitorConfig <span class="title">monitorConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    MonitorConfig mc = <span class="keyword">new</span> MonitorConfig();</div><div class="line">    mc.setProtocol(<span class="string">"registry"</span>);</div><div class="line">    <span class="keyword">return</span> mc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 提供者监控服务</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</div><div class="line">    providerConfig.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> providerConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 消费者监控</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReferenceConfig <span class="title">referenceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    ReferenceConfig rc = <span class="keyword">new</span> ReferenceConfig();</div><div class="line">    rc.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * RPC协议配置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocol</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</div><div class="line">    protocolConfig.setPort(<span class="number">20880</span>);</div><div class="line">    <span class="keyword">return</span> protocolConfig;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h5><p>服务的提供利用的是<code>ServiceBean</code>包裹,形成该bean的代理类,可以写一个通用的配置函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 通用service配置类</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> saturnService 对应服务</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> dubbo服务</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ServiceBean&lt;T&gt; <span class="title">configService</span><span class="params">(T saturnService)</span> </span>&#123;</div><div class="line">  ServiceBean&lt;T&gt; serviceBean = <span class="keyword">new</span> ServiceBean&lt;&gt;();</div><div class="line">  serviceBean.setProxy(<span class="string">"javassist"</span>);</div><div class="line">  serviceBean.setVersion(<span class="string">"1.0"</span>);</div><div class="line">  serviceBean.setInterface(saturnService.getClass().getInterfaces()[<span class="number">0</span>].getName());</div><div class="line">  serviceBean.setRef(saturnService);</div><div class="line">  serviceBean.setTimeout(<span class="number">2000</span>);</div><div class="line">  serviceBean.setRetries(<span class="number">3</span>);</div><div class="line">  <span class="keyword">return</span> serviceBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么我想要抛出IUserService这个服务,只需要如下几行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServiceBean&lt;IUserService&gt; <span class="title">userServiceExport</span><span class="params">(IUserService userService)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> configService(userService);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到此提供者配置完毕.</p><h4 id="服务消费者vienna-无断路器版本"><a href="#服务消费者vienna-无断路器版本" class="headerlink" title="服务消费者vienna(无断路器版本)"></a>服务消费者vienna(无断路器版本)</h4><p>vienna作为服务消费者与提供者一样也需要基本的dubbo配置,两者配置几乎一模一样.</p><h5 id="dubbo基本配置-1"><a href="#dubbo基本配置-1" class="headerlink" title="dubbo基本配置"></a>dubbo基本配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfig</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 注册中心</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">    registryConfig.setAddress(<span class="string">"115.159.185.14:2181"</span>);</div><div class="line">    registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">    registryConfig.setTimeout(<span class="number">60000</span>);<span class="comment">// vienna不知道为什么链接zk很慢</span></div><div class="line">    <span class="keyword">return</span> registryConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 应用信息,计算依赖关系</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">application</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</div><div class="line">    applicationConfig.setName(<span class="string">"vienna"</span>);</div><div class="line">    <span class="keyword">return</span> applicationConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 监控中心地址</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MonitorConfig <span class="title">monitorConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    MonitorConfig mc = <span class="keyword">new</span> MonitorConfig();</div><div class="line">    mc.setProtocol(<span class="string">"registry"</span>);</div><div class="line">    <span class="keyword">return</span> mc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 提供者监控服务</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</div><div class="line">    providerConfig.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> providerConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 消费者监控</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReferenceConfig <span class="title">referenceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    ReferenceConfig rc = <span class="keyword">new</span> ReferenceConfig();</div><div class="line">    rc.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 协议配置,自身无提供者的话可以不配置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocol</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</div><div class="line">    protocolConfig.setPort(<span class="number">20880</span>);</div><div class="line">    <span class="keyword">return</span> protocolConfig;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="配置消费者"><a href="#配置消费者" class="headerlink" title="配置消费者"></a>配置消费者</h5><p>消费者是用<code>ReferenceBean</code>类来代理的,可以像提供者那样写一个通用的处理方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 基本配置类</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> serviceReference 接口</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ReferenceBean&lt;T&gt; <span class="title">configReference</span><span class="params">(Class&lt;T&gt; serviceReference)</span> </span>&#123;</div><div class="line">  ReferenceBean&lt;T&gt; ref = <span class="keyword">new</span> ReferenceBean&lt;&gt;();</div><div class="line">  ref.setVersion(<span class="string">"1.0"</span>);</div><div class="line">  ref.setInterface(serviceReference);</div><div class="line">  ref.setTimeout(<span class="number">2000</span>);</div><div class="line">  ref.setRetries(<span class="number">3</span>);</div><div class="line">  ref.setCheck(<span class="keyword">false</span>);</div><div class="line">  ref.setLoadbalance(<span class="string">"roundrobin"</span>);</div><div class="line">  <span class="keyword">return</span> ref;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么引用服务也就只需要几行代码即可,为了更好的与old_rpc服务区分对于dubbo引入的服务都加上dubbo前缀命名.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = <span class="string">"dubboUserService"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ReferenceBean&lt;IUserService&gt; <span class="title">userService</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> configReference(IUserService.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="替换old-rpc"><a href="#替换old-rpc" class="headerlink" title="替换old_rpc"></a>替换old_rpc</h5><p>无断路器版本替换就很简单了,找到引用该服务的地方,在Spring注入时为其选择注入dubbo服务即可.问题是一旦该服务出现了问题,那么需要手动切换回old_rpc服务.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Resource</span></div><div class="line"> <span class="keyword">private</span> IUserService dubboUserService;</div></pre></td></tr></table></figure></p><h4 id="服务消费者vienna-断路器版本"><a href="#服务消费者vienna-断路器版本" class="headerlink" title="服务消费者vienna(断路器版本)"></a>服务消费者vienna(断路器版本)</h4><p>断路器本身是做服务降级,防止系统因一个服务出问题而产生雪崩效应,对于当前系统的两套RPC方案可以利用这一点把要替换掉的old_rpc作为降级服务,当dubboService出现异常时可以立即去调取old_rpc的服务,从而保证系统的健壮性.</p><h5 id="断路器要求"><a href="#断路器要求" class="headerlink" title="断路器要求"></a>断路器要求</h5><ol><li>业务代码无侵入,可以使用方法级别的注解控制该方法是否走断路器.稳定后可以直接删除,不留痕迹.</li><li>支持自动熔断,自动恢复</li><li>有支持集群的监控服务,方便排查出现问题的服务.</li></ol><h5 id="断路器依赖"><a href="#断路器依赖" class="headerlink" title="断路器依赖"></a>断路器依赖</h5><p>对于上述要求,符合条件,又经得起生产考验的大概只有hystrix了,github地址为 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a>,pom依赖如下,主要是核心服务包,注解包,监控包.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.12&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.12&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div></pre></td></tr></table></figure></p><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>实现思路与feign对hystrix的包装很相像,以UserRepo为例,UserRepo中引入了userService服务,那么要自动切换则需要两个UserRepo,一个是引用了dubbox的dubboUserService,一个是引用了old_rpc的old_rpcUserService.断路器是方法级别的监控,使用AOP可以轻松地拦截UserRepo中每一个方法的执行,在执行时使用hystrix包装,执行失败时再使用另一个UserRepo重新执行该方法.<br>上述流程有几个要点:</p><ol><li>需要通过引用dubbo服务的UserRepo获取到引入old_rpc的UserRepo</li><li>需要获取到UserRepo中全部的public方法,方便二次调用.</li><li>可以从UserRepo中得到断路器的配置,比如分组,线程池等信息.</li></ol><h5 id="增强Repo功能"><a href="#增强Repo功能" class="headerlink" title="增强Repo功能"></a>增强Repo功能</h5><p>上述的几个要点需要在UserRepo中附加的功能使用一个接口来抽象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDubboRepoProxy</span> <span class="keyword">extends</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 获取使用dubbo服务调用的Repo</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function">IDubboRepoProxy <span class="title">getDubboRepo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 获取当前类所有的public方法</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> 键与值都是该方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function">Map&lt;Method, Method&gt; <span class="title">getAllPublicMethods</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 得到断路器的配置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  HystrixCommand.<span class="function">Setter <span class="title">getHystrixSetter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了让实现类更少的写代码,再为其定义一个抽象类,该抽象类主要负责接口功能的实现,其中<code>initOtherRepo</code>作为抽象方法,需要子类来实现,也就是初始化备份的Repo.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRepoProxyImpl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDubboRepoProxy</span>&gt; <span class="keyword">implements</span> <span class="title">IDubboRepoProxy</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Getter</span></div><div class="line">  <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">  <span class="meta">@Setter</span></div><div class="line">  <span class="keyword">private</span> T otherRepo;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Map&lt;Method, Method&gt; publicMethodMap = Maps.newHashMap();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> HystrixCommand.Setter setter;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> IDubboRepoProxy <span class="title">getDubboRepo</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> otherRepo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, Method&gt; <span class="title">getAllPublicMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> publicMethodMap;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">getHystrixSetter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> setter;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//init repo</span></div><div class="line">    initOtherRepo();</div><div class="line">    <span class="comment">//init method</span></div><div class="line">    Class&lt;? extends IDubboRepoProxy&gt; old_rpcClass = <span class="keyword">this</span>.otherRepo.getClass();</div><div class="line">    <span class="keyword">for</span> (Method method : old_rpcClass.getDeclaredMethods()) &#123;</div><div class="line">      publicMethodMap.put(method, method);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//init setter</span></div><div class="line">    setter = HystrixCommand.Setter</div><div class="line">        .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="keyword">this</span>.getClass().getName()))</div><div class="line">        .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="keyword">this</span>.getClass().getSimpleName()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initOtherRepo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = applicationContext;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="使用AOP动态切换"><a href="#使用AOP动态切换" class="headerlink" title="使用AOP动态切换"></a>使用AOP动态切换</h5><p>上述接口与抽象类会赋予UserRepo我们想要的功能.接下来就是AOP拦截.因为断路器是方法级别的操作,因此该AOP只拦截方法,为了更好的配置增加一个AOP专用注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该注解修饰的方法会被AOP拦截</span></div><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoDubboAspect &#123;&#125;</div></pre></td></tr></table></figure></p><p>然后写具体的拦截器.该拦截器责任就是按部就班的执行之前的思路.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoDubboAspectImpl</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AutoDubboAspectImpl.class);</div><div class="line"></div><div class="line">  <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.duitang.context.dubbo.AutoDubboAspect)"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoDubboAspect</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//环绕通知</span></div><div class="line">  <span class="meta">@Around</span>(<span class="string">"autoDubboAspect()"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">autoCheck</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">//要执行的主repo</span></div><div class="line">    IDubboRepoProxy target = (IDubboRepoProxy) pjp.getTarget();</div><div class="line">    <span class="comment">//备用repo</span></div><div class="line">    IDubboRepoProxy otherRepo = target.getDubboRepo();</div><div class="line">    <span class="comment">//该repo中所有方法</span></div><div class="line">    Map&lt;Method, Method&gt; methods = target.getAllPublicMethods();</div><div class="line">    <span class="comment">//断路器执行</span></div><div class="line">    HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(</div><div class="line">        target.getHystrixSetter()) &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">return</span> pjp.proceed();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</div><div class="line">          <span class="comment">//异常直接抛出</span></div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line"><span class="comment">       * 备用降级方案</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</div><div class="line">        logger.error(<span class="string">"start getFallback,this exception is &#123;&#125;"</span>, <span class="keyword">this</span>.getFailedExecutionException());</div><div class="line">        logger.error(<span class="string">"start getFallback"</span>, pjp.getSignature().toLongString());</div><div class="line">        MethodSignature signature = (MethodSignature) pjp.getSignature();</div><div class="line">        <span class="comment">//获取执行方法</span></div><div class="line">        Method method = methods.get(signature.getMethod());</div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//使用备用repo执行该方法</span></div><div class="line">          <span class="keyword">return</span> method.invoke(otherRepo, pjp.getArgs());</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</div><div class="line">          logger.error(<span class="string">"getFallback error,&#123;&#125;"</span>,e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> hystrixCommand.execute();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到此准备工作算是结束,下面是真正的替换.</p><h5 id="开始替换old-rpc服务"><a href="#开始替换old-rpc服务" class="headerlink" title="开始替换old_rpc服务"></a>开始替换old_rpc服务</h5><p>因为准备的充分,那么替换就变得相当简单了.首先为UserRepo增强功能,也就是继承抽象类<code>DubboRepoProxyImpl</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class UserRepo extends DubboRepoProxyImpl&lt;UserRepo&gt;</div></pre></td></tr></table></figure></p><p>然后实现<code>initOtherRepo</code>方法,该方法主要是从Spring容器中获取到old_rpc的服务,然后再初始化一个UserRepo.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initOtherRepo</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != getContext()) &#123;</div><div class="line">     IUserService userService = getContext().getBean(<span class="string">"userService"</span>, IUserService.class);</div><div class="line">     IRelationshipService relationshipService = getContext().getBean(<span class="string">"relationshipService"</span>,</div><div class="line">         IRelationshipService.class);</div><div class="line">     IUserInterestsService userInterestsService = getContext().getBean(<span class="string">"userInterestsService"</span>,</div><div class="line">         IUserInterestsService.class);</div><div class="line">     IFriendRecomendService friendRecomendService = getContext().getBean(<span class="string">"friendRecomendService"</span>,</div><div class="line">         IFriendRecomendService.class);</div><div class="line">     <span class="comment">//备用old_rpc服务</span></div><div class="line">     UserRepo userRepo = <span class="keyword">new</span> UserRepo(userService, <span class="keyword">this</span>.appealAccountService, <span class="keyword">this</span>.datasourceService,</div><div class="line">         relationshipService, <span class="keyword">this</span>.lifeArtistService, userInterestsService, <span class="keyword">this</span>.jedisPersist, friendRecomendService);</div><div class="line">     <span class="keyword">this</span>.setOtherRepo(userRepo);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>最后为想要实现短路功能的方法加上注解.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoDubboAspect</span></div><div class="line"><span class="function"><span class="keyword">public</span> BaseUser <span class="title">findBasicInfo</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="消费者无法从zk中获取提供者信息"><a href="#消费者无法从zk中获取提供者信息" class="headerlink" title="消费者无法从zk中获取提供者信息?"></a>消费者无法从zk中获取提供者信息?</h4><p>这种情况大多数都是因为配置时两方信息不一致导致,可以去dubbo-admin平台检查提供者完整的url,再与日志中消费者引用的url做个比较,定位到问题.</p><h4 id="zk连接超时"><a href="#zk连接超时" class="headerlink" title="zk连接超时"></a>zk连接超时</h4><p>zk是我在自己服务器上部署的,在vienna项目中配置了外网地址,在prism环境中启动后总是出现zk连接超时,后来测试要连上zk大概需要20秒左右,索性把超时时间配置为60秒,解决,具体原因未知.</p><h4 id="saturn中配置zk注册服务后测试案例无法跑通"><a href="#saturn中配置zk注册服务后测试案例无法跑通" class="headerlink" title="saturn中配置zk注册服务后测试案例无法跑通"></a>saturn中配置zk注册服务后测试案例无法跑通</h4><p>这个问题是我在saturn配置了测试环境的zk,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">  RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">  registryConfig.setAddress(<span class="string">"10.1.4.10:2181"</span>);</div><div class="line">  registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">  <span class="keyword">return</span> registryConfig;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是jenkins打包时,测试案例一直失败,大概要打包10多分钟,问题有点莫名其妙,在测试时避免Spring引入该bean即可解决.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体过程是比较顺利的,下篇再记录dubbo-admin与dubbo-monitor,以及hystrix-dashborad的搭建.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;公司一直以来使用内部编写的一个rpc框架,简称old_rpc这套RPC框架,由于历史原因,old_rpc存在如下缺点.&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="服务治理" scheme="http://mrdear.cn/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
      <category term="dubbo" scheme="http://mrdear.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(四) -- JSON Web Token实践(下)</title>
    <link href="http://mrdear.cn/2017/06/30/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E5%9B%9B)%20--%20JSON%20Web%20Token%E5%AE%9E%E8%B7%B5(%E4%B8%8B)/"/>
    <id>http://mrdear.cn/2017/06/30/spring/Spring Security学习记录(四) -- JSON Web Token实践(下)/</id>
    <published>2017-06-30T10:19:22.000Z</published>
    <updated>2017-06-30T10:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>接着上篇的内容,了解了JWT Token后,发现这东西就是一个可信的用户信息存储方式,那么可信的话就可以省去验证这个步骤,只有当需要用户的详细信息时候才会去DB中查询用户的详细信息.那么现在的流程就是<br><code>用户请求 -&gt; Spring Security通过token把tokenUser设置到上下文中 -&gt; Spring Security Token以及权限验证 -&gt; 具体的业务接口 -&gt; 需要详细信息则根据用户id去DB中获取</code><br>那么就会有以下几个问题.</p><h4 id="token在什么时候生成"><a href="#token在什么时候生成" class="headerlink" title="token在什么时候生成?"></a>token在什么时候生成?</h4><p>这个在登录接口中生成,登录后token放入用户id,用户权限等基础信息,以供验证使用.</p><h4 id="token签名的密钥该使用什么"><a href="#token签名的密钥该使用什么" class="headerlink" title="token签名的密钥该使用什么?"></a>token签名的密钥该使用什么?</h4><p>这个我也不太清楚,写死一个密钥感觉很不安全,我的想法是使用用户的密码的密文作为签名密钥,这样当用户更改密码的时候原token都是失效.<br>这样做有个缺点,用户密码的密文每次获取需要查询DB,势必会造成DB的压力,可以考虑加缓存,但要考虑缓存挂掉的情况下对DB的压力.</p><h4 id="token该怎么较少被盗后的损失"><a href="#token该怎么较少被盗后的损失" class="headerlink" title="token该怎么较少被盗后的损失?"></a>token该怎么较少被盗后的损失?</h4><p>token既然被系统认为是可信的信息集合,那么就需要有相应的超时机制,超时机制是为了防止token被盗用后的损失也只能在一段时间内,就和session超时机制是一样的用处.</p><h4 id="如何解决SSO"><a href="#如何解决SSO" class="headerlink" title="如何解决SSO?"></a>如何解决SSO?</h4><p>SSO需要借助cookie或者localStorge,把token放在顶级域名中,这样的话子系统都能使用到,也就完成的SSO机制.<br>对于多域名,那要解决的问题就是如何跨域设置cookie了</p><h4 id="如何解决CSRF"><a href="#如何解决CSRF" class="headerlink" title="如何解决CSRF?"></a>如何解决CSRF?</h4><p>CSRF产生的原因是对方使用了你的Cookie也就是使用了你的认证信息,那么的话获取token这一步就不能依赖token,所以把cookie存在cookie中,然后请求时放入header中,解析时从header中获取token信息.</p><hr><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="JWT签名与验签"><a href="#JWT签名与验签" class="headerlink" title="JWT签名与验签"></a>JWT签名与验签</h4><p>首先POM引入依赖包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p><p>接着定义一个简单的用户,用作存储在上下文中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUserDTO</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Long id;</div><div class="line">  <span class="keyword">private</span> String username;</div><div class="line">  <span class="keyword">private</span> String email;</div><div class="line">  <span class="keyword">private</span> String avatar;</div><div class="line">  <span class="keyword">private</span> List&lt;String&gt; roles;</div><div class="line">  <span class="comment">//省略get set</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接着实现jwt<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   * 从用户中创建一个jwt Token</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> userDTO 用户</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> token</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(TokenUserDTO userDTO)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Jwts.builder()</div><div class="line">        .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + VALIDITY_TIME_MS))</div><div class="line">        .setSubject(userDTO.getUsername())</div><div class="line">        .claim(<span class="string">"id"</span>, userDTO.getId())</div><div class="line">        .claim(<span class="string">"avatar"</span>, userDTO.getAvatar())</div><div class="line">        .claim(<span class="string">"email"</span>, userDTO.getEmail())</div><div class="line">        .claim(<span class="string">"roles"</span>, userDTO.getRoles())</div><div class="line">        .signWith(SignatureAlgorithm.HS256, secret)</div><div class="line">        .compact();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 从token中取出用户</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> TokenUserDTO <span class="title">parse</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">    Claims claims = Jwts.parser()</div><div class="line">        .setSigningKey(secret)</div><div class="line">        .parseClaimsJws(token)</div><div class="line">        .getBody();</div><div class="line">    TokenUserDTO userDTO = <span class="keyword">new</span> TokenUserDTO();</div><div class="line">    userDTO.setId(NumberUtils.toLong(claims.getId()));</div><div class="line">    userDTO.setAvatar(claims.get(<span class="string">"avatar"</span>,String.class));</div><div class="line">    userDTO.setUsername(claims.get(<span class="string">"username"</span>,String.class));</div><div class="line">    userDTO.setEmail(claims.get(<span class="string">"email"</span>,String.class));</div><div class="line">    userDTO.setRoles((List&lt;String&gt;) claims.get(<span class="string">"roles"</span>));</div><div class="line">    <span class="keyword">return</span> userDTO;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><h4 id="Spring-Security过滤"><a href="#Spring-Security过滤" class="headerlink" title="Spring Security过滤"></a>Spring Security过滤</h4><p>上述流程中Spring Security所承担的角色是验证token+保存token解析出来的用户到<code>SecurityContextHolder</code>中,弄清楚角色那么实现就很简单了.看之前的过滤器链,<br>蓝色框内包含跨站攻击检测与用户信息获取校验,因为用的是jwt所以这些都可以省略掉,替换为解析并验证token,然后设置解析后的用户到上下文中.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1499046528.png?imageMogr2/thumbnail/!70p" alt=""></p><p>首先<code>SecurityContextHolder</code>中存储的是<code>Authentication</code>对象,所以需要在TokenUser基础封装一层认证用户.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Spring Security中存放的认证用户</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Niu Li</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/6/28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUserAuthentication</span> <span class="keyword">implements</span> <span class="title">Authentication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3730332217518791533L</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> TokenUserDTO userDTO;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Boolean authentication = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TokenUserAuthentication</span><span class="params">(TokenUserDTO userDTO, Boolean authentication)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.userDTO = userDTO;</div><div class="line">    <span class="keyword">this</span>.authentication = authentication;</div><div class="line">  &#125;</div><div class="line">    <span class="comment">//这里的权限是FilterSecurityInterceptor做权限验证使用</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getRoles().stream()</div><div class="line">        .map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getDetails</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getUsername();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> authentication;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.authentication = isAuthenticated;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getUsername();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后实现验签方法,验签是从header中取出相应的token,验签成功后返回一个<code>Authentication</code>的对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 验签</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Authentication&gt; <span class="title">verifyToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String token = request.getHeader(AUTH_HEADER_NAME);</div><div class="line">  <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; !token.isEmpty())&#123;</div><div class="line">    <span class="keyword">final</span> TokenUserDTO user = parse(token.trim());</div><div class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> TokenUserAuthentication(user, <span class="keyword">true</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Optional.empty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后实现验证Token的过滤器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  jwt token验证类,验证成功后设置进去SecurityContext中</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Niu Li</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/6/28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VerifyTokenFilter</span><span class="params">(JwtTokenUtil jwtTokenUtil)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.jwtTokenUtil = jwtTokenUtil;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Optional&lt;Authentication&gt; authentication = jwtTokenUtil.verifyToken(request);</div><div class="line">      log.debug(<span class="string">"VerifyTokenFilter result: &#123;&#125;"</span>,authentication.orElse(<span class="keyword">null</span>));</div><div class="line">      SecurityContextHolder.getContext().setAuthentication(authentication.orElse(<span class="keyword">null</span>));</div><div class="line">      filterChain.doFilter(request,response);</div><div class="line">    &#125; <span class="keyword">catch</span> (JwtException e) &#123;</div><div class="line">      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</div><div class="line">      <span class="comment">//可以在这里指定重定向还是返回错误接口示例</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>配置下Spring Security,主要就是关闭一些不用的过滤器,实现自己的验证过滤器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">  <span class="meta">@Resource</span></div><div class="line">  <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 在此配置不过滤的请求</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//每一个请求对应一个空的filter链,这里一般不要配置过多,</span></div><div class="line">    <span class="comment">// 因为查找处是一个for循环,过多就导致每个请求都需要循环一遍直到找到</span></div><div class="line">    web.ignoring().antMatchers(<span class="string">"/"</span>,<span class="string">"/login"</span>,<span class="string">"/favicon.ico"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 在此配置过滤链</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    http</div><div class="line">        .authorizeRequests()</div><div class="line">        <span class="comment">//角色定义,Spring Security会在其前面自动加上ROLE_,因此存储权限的时候也要加上ROLE_ADMIN</span></div><div class="line">        .antMatchers(<span class="string">"/detail"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</div><div class="line">        .anyRequest().permitAll().and()</div><div class="line">        <span class="comment">//异常处理,可以再此使用entrypoint来定义错误输出</span></div><div class="line">        .exceptionHandling().and()</div><div class="line">        <span class="comment">//不需要session来控制,所以这里可以去掉</span></div><div class="line">        .securityContext().securityContextRepository(<span class="keyword">new</span> NullSecurityContextRepository()).and()</div><div class="line">        <span class="comment">//开启匿名访问</span></div><div class="line">        .anonymous().and()</div><div class="line">        <span class="comment">//退出登录自己来控制</span></div><div class="line">        .logout().disable()</div><div class="line">        <span class="comment">//因为没用到cookies,所以关闭cookies</span></div><div class="line">        .csrf().disable()</div><div class="line">        <span class="comment">//验证token</span></div><div class="line">        .addFilterBefore(<span class="keyword">new</span> VerifyTokenFilter(jwtTokenUtil),</div><div class="line">            UsernamePasswordAuthenticationFilter.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样做的话,验证就需要在相应的代码中,或者对指定链接使用Spring Security的权限验证.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 该链接尝试获取登录用户,返回该认证用户的信息,请求该链接需要在header中放入x-authorization: token</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/detail"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> TokenUserDTO <span class="title">userDetail</span><span class="params">()</span> </span>&#123;</div><div class="line">  Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</div><div class="line">  <span class="keyword">if</span> (Objects.isNull(authentication)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (TokenUserDTO) authentication.getDetails();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">.antMatchers(<span class="string">"/detail"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</div><div class="line">...</div></pre></td></tr></table></figure></p><p>这样的话就实现了jwt验证,SSO问题也就是token传输的问题,使用cookie就可以了,客户端去请求时从cookie中加载token,然后放入到header中,对这里的代码没影响.</p><hr><blockquote><p>github地址: <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;接着上篇的内容,了解了JWT Token后,发现这东西就是一个可信的用户信息存储方式,那么可信的话就可以省去验证这个步骤,只有当需要用户的详
      
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(三) -- JSON Web Token实践(上)</title>
    <link href="http://mrdear.cn/2017/06/26/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)%20--%20JSON%20Web%20Token%E5%AE%9E%E8%B7%B5(%E4%B8%8A)/"/>
    <id>http://mrdear.cn/2017/06/26/spring/Spring Security学习记录(三) -- JSON Web Token实践(上)/</id>
    <published>2017-06-26T08:36:33.000Z</published>
    <updated>2017-06-26T08:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>JWT实际上与Spring Security没多大关系,本文打算使用Spring Security配合JWT这种方式完成用户的认证和授权.</p><hr><p>JSON Web Token(JWT),是一个开放安全的行业标准,用于多个系统之间传递安全可靠的信息.关于其解释可以参考博文:<br><a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="external">JSON Web Token - 在Web应用间安全地传递信息</a><br>因为原作者写的很详细,这里就只说下个人认为比较重要的问题.</p><h3 id="JWT是什么样子的结构"><a href="#JWT是什么样子的结构" class="headerlink" title="JWT是什么样子的结构?"></a>JWT是什么样子的结构?</h3><p>JSON Web Token说到底也是一串token,其形式分三段,看下图,<strong>红色</strong>的为Header,指定token类型与签名类型,<strong>紫色</strong>的为请求体,存储用户id等关键信息,最后<strong>蓝色</strong>的为签名,保证整个信息的完整性,可靠性.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498469217.png?imageMogr2/thumbnail/!70p" alt=""><br>其中playload中可以</p><ul><li>iss: 该JWT的签发者</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul><h3 id="JWT是一个怎样的流程"><a href="#JWT是一个怎样的流程" class="headerlink" title="JWT是一个怎样的流程?"></a>JWT是一个怎样的流程?</h3><ol><li>客户端使用账户密码请求登录接口</li><li>登录成功后返回JWT</li><li>客户端再次请求其他接口时带上JWT</li><li>服务端接收到JWT后验证签名的有效性.</li></ol><h3 id="JWT解决了什么问题"><a href="#JWT解决了什么问题" class="headerlink" title="JWT解决了什么问题?"></a>JWT解决了什么问题?</h3><p><strong>token被劫持</strong><br>一开始理解很容易陷入一个误区,比如有人会问对于JWT来说,jwt被劫持了的话,那么对方就可以伪造请求,这东西怎么能保证安全呢?<br>这里问题是没理解好JWT,JWT解决的是认证与授权的问题,上述劫持或者类似的中间人攻击是JWT不可避免的,也是其他认证与授权方式不可避免的,想避免可以使用HTTPS,或者签发jwt的时候记录下Client的ip地址,这些就和JWT没关系了.</p><p><strong>与Session的区别</strong><br>session实际上是基于cookie来传输的,最重要的session信息是存储在服务器的,所以服务器每次可以通过cookie中的sessionId获取到当前会话的用户,对于单台服务器这样做没问题,但是对于多台就涉及到共享session的问题了,而且认证用户的增多,session会占用大量的服务器内存.<br>那么jwt是存储在客户端的,服务器不需要存储jwt,jwt里面有用户id,服务器拿到jwt验证后可以获得用户信息.也就实现了session的功能,但是相比session,jwt是无状态的,其不与任何机器绑定,只要签名秘钥足够的安全就能保证jwt的可靠性.</p><h3 id="JWT下服务端认为什么样子的请求是可信的"><a href="#JWT下服务端认为什么样子的请求是可信的" class="headerlink" title="JWT下服务端认为什么样子的请求是可信的?"></a>JWT下服务端认为什么样子的请求是可信的?</h3><p>对于服务端来说,无法确定下一个请求是哪一个用户,哪一个终端发出,所以其需要一些信息定位到该用户或者该机器,对于JWT来说其Playload里面存储着UserId,那么服务端接收到Token后对其进行签名验证,验证成功,则认为其是<strong>可信的</strong>,然后通过UserId从DB或者Cache中查询出来用户信息.</p><h3 id="为什么JWT能保证信息传输的安全可靠"><a href="#为什么JWT能保证信息传输的安全可靠" class="headerlink" title="为什么JWT能保证信息传输的安全可靠?"></a>为什么JWT能保证信息传输的安全可靠?</h3><p>比如现在有token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eyJhbGciOiJIUzI1NiJ9.</div><div class="line">eyJleHAiOjE0OTg0ODIxNTQsInN1YiI6InF1ZGluZyIsInVzZXJJZCI6IjEwMzc5NDAxIiwicm9sZSI6ImFkbWluIn0.</div><div class="line">-YFTYJ6FLlIQqD4G3hYcWvYlYE8H9eAA2369WEcJFVY</div></pre></td></tr></table></figure></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Header</div><div class="line">&#123;</div><div class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></div><div class="line">&#125;</div><div class="line">Playload</div><div class="line">&#123;</div><div class="line">  <span class="attr">"exp"</span>: <span class="number">1498482154</span>,</div><div class="line">  <span class="attr">"sub"</span>: <span class="string">"quding"</span>,</div><div class="line">  <span class="attr">"userId"</span>: <span class="string">"10379401"</span>,</div><div class="line">  <span class="attr">"role"</span>: <span class="string">"admin"</span></div><div class="line">&#125;</div><div class="line">Sign</div><div class="line">YFTYJ6FLlIQqD4G3hYcWvYlYE8H9eAA2369WEcJFVY</div></pre></td></tr></table></figure><p>假设我的playload被其他人劫持了,其他人把userId修改为他自己的,比如123456,但是其没有签名的秘钥,所以他就没法生成签名.<br>服务端收到该Token后,会用先Base64解码出来相应的信息,然后重新生成sign,使用该sign与客户端传来的Sign进行对比,一样则证明没被修改,也就是可信的请求,否则拒绝该请求.</p><p>下一篇开始实战.</p><blockquote><p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JWT实际上与Spring Security没多大关系,本文打算使用Spring Security配合JWT这种方式完成用户的认证和授权.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JSON Web Token(JWT),是一个开放安全的行业标准,用于多个系统之间传递安全可靠的信息.关于其解
      
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(二) -- Spring Security的Filter</title>
    <link href="http://mrdear.cn/2017/06/22/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%20--%20Spring%20Security%E7%9A%84Filter/"/>
    <id>http://mrdear.cn/2017/06/22/spring/Spring Security学习记录(二) -- Spring Security的Filter/</id>
    <published>2017-06-22T14:03:37.000Z</published>
    <updated>2017-06-22T14:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇学习了Spring Security是如何拦截请求,并把请求转向到Filter链的,该篇就主要学习下这些Filter链的节点的作用.</p><hr><p>下面是之前配置的内容,本文也是对这些内容 的执行分析.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:http-basic</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="1-Filter链的由来"><a href="#1-Filter链的由来" class="headerlink" title="1.Filter链的由来"></a>1.Filter链的由来</h3><p>由上文可知每一个<code>security:http</code>标签实际上对应的是一个<code>SecurityFilterChain</code>的类,也就是一条Filter链,可以通过其http属性指明其作用的URL,否则作用域全部的URL,如下配置,该security:http会产生一个对/login下的所有请求Filter链.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/login/**"</span>&gt;</span></div><div class="line">    ******</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p><p>打个断点可以很清楚的看到该Filter链<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498283386.png?imageMogr2/thumbnail/!70p" alt=""></p><h3 id="2-SecurityContextPersistenceFilter"><a href="#2-SecurityContextPersistenceFilter" class="headerlink" title="2.SecurityContextPersistenceFilter"></a>2.SecurityContextPersistenceFilter</h3><p>该类在所有的Filter之前,是从<code>SecurityContextRepository</code>中取出用户认证信息,默认实现类为<code>HttpSessionSecurityContextRepository</code>,其会从Session中取出已认证用户的信息,提高效率,避免每一次请求都要查询用户认证信息.<br>取出之后会放入<code>SecurityContextHolder</code>中,以便其他filter使用,该类使用ThreadLocal存储用户认证信息,保证了线程之间的信息隔离,最后再finally中清除该信息.<br>可以配置http的<code>security-context-repository-ref</code>属性来自己控制获取到已认证用户信息的方式,比如使用redis存储session等.</p><h3 id="3-WebAsyncManagerIntegrationFilter"><a href="#3-WebAsyncManagerIntegrationFilter" class="headerlink" title="3.WebAsyncManagerIntegrationFilter"></a>3.WebAsyncManagerIntegrationFilter</h3><p>提供了对securityContext和WebAsyncManager的集成,其会把SecurityContext设置到异步线程中,使其也能获取到用户上下文认证信息.</p><h3 id="4-HeaderWriterFilter"><a href="#4-HeaderWriterFilter" class="headerlink" title="4.HeaderWriterFilter"></a>4.HeaderWriterFilter</h3><p>其会往该请求的Header中添加相应的信息,在http标签内部使用<code>security:headers</code>来控制.</p><h3 id="5-CsrfFilter"><a href="#5-CsrfFilter" class="headerlink" title="5.CsrfFilter"></a>5.CsrfFilter</h3><p>Csrf,跨站请求伪造,了解不是很深,只知道B网站使用A网站的可信Cookie发起请求,从而完成认证,伪造出正当请求.<br>验证方式是通过客户端传来的token与服务端存储的token进行对比,来判断是否为伪造请求,有兴趣的可以查看源代码研究下.</p><h3 id="6-LogoutFilter"><a href="#6-LogoutFilter" class="headerlink" title="6.LogoutFilter"></a>6.LogoutFilter</h3><p>匹配URL,默认为<code>/logout</code>,匹配成功后则用户退出,清除认证信息.</p><h3 id="7-UsernamePasswordAuthenticationFilter"><a href="#7-UsernamePasswordAuthenticationFilter" class="headerlink" title="7.UsernamePasswordAuthenticationFilter"></a>7.UsernamePasswordAuthenticationFilter</h3><p>登录认证过滤器,默认是对<code>/login</code>的POST请求进行认证,首先该方法会先调用<code>attemptAuthentication</code>尝试认证获取一个<code>Authentication</code>的认证对象,然后通过<code>sessionStrategy.onAuthentication</code>执行持久化,也就是保存认证信息,转向下一个Filter,最后调用<code>successfulAuthentication</code>执行认证后事件.</p><p><strong>attemptAuthentication</strong><br>该方法是认证的主要方法,认证是委托配置的<code>authentication-manager</code>-&gt;<code>authentication-provider</code>进行.<br>比如对于该Demo配置的为如下,则默认使用的manager为<code>ProviderManager</code>,使用的provider为<code>DaoAuthenticationProvider</code>,userDetailService为<code>InMemoryUserDetailsManager</code>也就是从内存中获取用户认证信息,也就是下面xml配置的user与admin信息.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p><p>认证基本流程为<code>UserDeatilService</code>根据用户名获取到认证用户的信息,然后通过<code>UserDetailsChecker.check</code>对用户进行状态校验,最后通过<code>additionalAuthenticationChecks</code>方法对用户进行密码校验成功后完成认证.返回一个认证对象.</p><p>都是面向接口编程,所以用户可以很轻松的扩展自己的验证方式.</p><h3 id="8-DefaultLoginPageGeneratingFilter"><a href="#8-DefaultLoginPageGeneratingFilter" class="headerlink" title="8.DefaultLoginPageGeneratingFilter"></a>8.DefaultLoginPageGeneratingFilter</h3><p>当请求为登录请求时,生成简单的登录页面返回</p><h3 id="9-BasicAuthenticationFilter"><a href="#9-BasicAuthenticationFilter" class="headerlink" title="9.BasicAuthenticationFilter"></a>9.BasicAuthenticationFilter</h3><p>Http Basci认证的支持,该认证会把用户名密码使用base64编码后放入header中传输,如下所示,认证成功后会把用户信息放入<code>SecurityContextHolder</code>中.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</div></pre></td></tr></table></figure></p><h3 id="10-RequestCacheAwareFilter"><a href="#10-RequestCacheAwareFilter" class="headerlink" title="10.RequestCacheAwareFilter"></a>10.RequestCacheAwareFilter</h3><p>恢复被打断的请求,具体未研究</p><h3 id="11-SecurityContextHolderAwareRequestFilter"><a href="#11-SecurityContextHolderAwareRequestFilter" class="headerlink" title="11.SecurityContextHolderAwareRequestFilter"></a>11.SecurityContextHolderAwareRequestFilter</h3><p>针对Servlet api不同版本做的一些包装</p><h3 id="12-AnonymousAuthenticationFilter"><a href="#12-AnonymousAuthenticationFilter" class="headerlink" title="12.AnonymousAuthenticationFilter"></a>12.AnonymousAuthenticationFilter</h3><p>当<code>SecurityContextHolder</code>中认证信息为空,则会创建一个匿名用户存入到<code>SecurityContextHolder</code>中</p><h3 id="13-SessionManagementFilter"><a href="#13-SessionManagementFilter" class="headerlink" title="13.SessionManagementFilter"></a>13.SessionManagementFilter</h3><p>与登录认证拦截时作用一样,持久化用户登录信息,可以保存到session中,也可以保存到cookie或者redis中.</p><h3 id="14-ExceptionTranslationFilter"><a href="#14-ExceptionTranslationFilter" class="headerlink" title="14.ExceptionTranslationFilter"></a>14.ExceptionTranslationFilter</h3><p>异常拦截,其处在Filter链后部分,只能拦截其后面的节点并且着重处理<code>AuthenticationException</code>与<code>AccessDeniedException</code>两个异常.</p><h3 id="15-FilterSecurityInterceptor"><a href="#15-FilterSecurityInterceptor" class="headerlink" title="15.FilterSecurityInterceptor"></a>15.FilterSecurityInterceptor</h3><p>主要是授权验证,方法为<code>beforeInvocation</code>,在其中调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</div><div class="line">.getAttributes(object);</div></pre></td></tr></table></figure></p><p>获取到所配置资源访问的授权信息,对于上述配置,获取到的则为<code>hasRole(&#39;ROLE_USER&#39;)</code>,然后根据<code>SecurityContextHolder</code>中存储的用户信息来决定其是否有权限,没权限则返回403,具体想了解可以关注<code>HttpConfigurationBuilder.createFilterSecurityInterceptor()</code>方法,分析其创建流程加载了哪些数据,或者分析<code>SecurityExpressionOperations</code>的子类,其是权限鉴定的实现方法.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个认证授权流程如下图所示,图是网上盗的<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498318805.png?imageMogr2/thumbnail/!70p" alt=""></p><p>因为是学习方面,使用的不是很多,如有错误请指出,以防误人子弟.<br>简单来说,作为用户需要关心的地方是</p><ol><li>登录验证<code>UsernamePasswordAuthenticationFilter</code></li><li>访问验证<code>BasicAuthenticationFilter</code></li><li>权限验证<code>FilterSecurityInterceptor</code><br>下一篇则讲述利用这三个验证实现JWT验证.</li></ol><p>关于这些过滤器更详细的内容可参考博客: <a href="http://www.iteye.com/blogs/subjects/spring_security" target="_blank" rel="external">http://www.iteye.com/blogs/subjects/spring_security</a></p><blockquote><p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇学习了Spring Security是如何拦截请求,并把请求转向到Filter链的,该篇就主要学习下这些Filter链的节点的作用.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是之前配置的内容,本文也是对这些内容 的执行分析.&lt;br&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(一) -- 初识Spring Security</title>
    <link href="http://mrdear.cn/2017/06/19/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%20--%20Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%20--%20%E5%88%9D%E8%AF%86Spring%20Security/"/>
    <id>http://mrdear.cn/2017/06/19/spring/Spring Security学习记录(一) -- Spring Security学习记录(一) -- 初识Spring Security/</id>
    <published>2017-06-19T06:08:25.000Z</published>
    <updated>2017-06-19T06:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Security是什么"><a href="#Spring-Security是什么" class="headerlink" title="Spring Security是什么?"></a>Spring Security是什么?</h3><p>Spring Security是一套认证授权框架,支持认证模式如<code>HTTP BASIC 认证头 (基于 IETF RFC-based 标准)</code>,<code>HTTP Digest 认证头 ( IETF RFC-based 标准)</code>,<code>Form-based authentication (用于简单的用户界面)</code>,<code>OpenID 认证</code>等,Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制.</p><h3 id="使用Spring-Security"><a href="#使用Spring-Security" class="headerlink" title="使用Spring Security"></a>使用Spring Security</h3><p>Spring Security3之后提供了Java Config的配置方式,但是我觉得xml方式比较容易理解其整体结构,所以本文都是基于xml配置的,在github上该项目会提供Java Config方式作为对比.</p><h4 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">     &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</div><div class="line"> &lt;/parent&gt;</div><div class="line"></div><div class="line"> &lt;dependencies&gt;</div><div class="line">     &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</div><div class="line">     &lt;/dependency&gt;</div><div class="line">     &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">     &lt;/dependency&gt;</div><div class="line"> &lt;/dependencies&gt;</div></pre></td></tr></table></figure><p>由于使用了Spring Boot,所以需要使用<code>@EnableWebSecurity</code>注解启用Spring Security,并指明其配置文件为classpath下的<code>spring-security.xml</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="meta">@ImportResource</span>(locations = <span class="string">"classpath:spring-security.xml"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><p>在<code>spring-security.xml</code>中引入官方提供的命名空间,然后简单配置下,该配置大概意思是对所有请求的url拦截,必须有User权限的用户才能访问.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></div><div class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/security</span></span></div><div class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">security:http</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:http-basic</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p><h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>该页面为Spring Security自动生成的登录页面,当我们访问任何连接都会被重定向到该登录页面,输入<code>user:123456</code>登录后才能有权限访问.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1497854910.png?imageMogr2/thumbnail/!70p" alt=""></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>上述是一个简单的Demo,分析则是从这个Demo深入浅出.<br><strong>1.Spring Security是如何拦截请求的?</strong><br>传统的xml配置都会在web.xml里面配置如下过滤器.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p><p>可以看出入口点就是该类,该类会从Spring容器中读取名称为<code>springSecurityFilterChain</code>的一个Filter实例,从而获取到对应代理的Filter.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);</div><div class="line"><span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</div><div class="line">delegate.init(getFilterConfig());</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> delegate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后在doFilter方法中调用该委托的filter,也就实现的拦截请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeDelegate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></div><div class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line"></div><div class="line">delegate.doFilter(request, response, filterChain);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>2. Spring Security拦截请求后是如何处理的?</strong><br>打断点可以发现<code>DelegatingFilterProxy</code>实际上代理的是<code>FilterChainProxy</code>这个类,该类中有<code>private List&lt;SecurityFilterChain&gt; filterChains;</code>全局变量,那么<code>SecurityFilterChain</code>为何物?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityFilterChain</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(HttpServletRequest request)</span></span>;</div><div class="line"></div><div class="line"><span class="function">List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从源码可以判断SecurityFilterChain是一套规则所对应的Filter链集合.再看源码<code>getFilters</code>,该方法会根据规则(也就是配置中的<code>security:http</code>标签)获取一个SecurityFilterChain中的一套对应规则的filter链.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</div><div class="line"><span class="keyword">if</span> (chain.matches(request)) &#123;</div><div class="line"><span class="keyword">return</span> chain.getFilters();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后在<code>doFilterInternal</code>方法中创建一个<code>VirtualFilterChain</code>类,调用其<code>doFilter</code>方法.<code>VirtualFilterChain</code>这个类很有意思,该类继承了<code>FilterChain</code>类,那么其就拥有了转交请求到指定filter的能力,另外其还拥有一套filter链<code>List&lt;Filter&gt; additionalFilters;</code>,那么这个类就控制了整个Spring Security的执行流程,那么它是怎么实现的呢?<br>开始我以为是一个循环,然而看了源码才发现自己太low了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      currentPosition++;</div><div class="line">Filter nextFilter = additionalFilters.get(currentPosition - <span class="number">1</span>);</div><div class="line">nextFilter.doFilter(request, response, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p><p><code>currentPosition</code>与<code>additionalFilters</code>都是全局变量,其在调用filter链的时候每次都把自己本身在<code>doFilter</code>传值过去,每一个Filter链节点执行完毕后再返回<code>VirtualFilterChain</code>的<code>doFilter</code>方法,开启下一个节点执行.其结构如下面代码所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(IAChain chain)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IAClass</span> <span class="keyword">implements</span> <span class="title">IA</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(IAChain chain)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"i am IAClass"</span>);</div><div class="line">      chain.doSomeThing();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">IAChain</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IAChainClass</span> <span class="keyword">implements</span> <span class="title">IAChain</span></span>&#123;</div><div class="line"></div><div class="line">    List&lt;IA&gt; IAChains = <span class="keyword">new</span> ArrayList&lt;IA&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IAChainClass</span><span class="params">()</span> </span>&#123;</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (position == IAChains.size()) &#123;</div><div class="line">        System.out.println(<span class="string">"end"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      IA ia = IAChains.get(position++);</div><div class="line">      ia.doSomeThing(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>当调用<code>iaChainClass.doSomeThing()</code>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i am IAClass</div><div class="line">i am IAClass</div><div class="line">i am IAClass</div><div class="line">end</div></pre></td></tr></table></figure></p><hr><p>调用链的实现还可以使用继承来实现,每次执行前先执行super()方法.</p><blockquote><p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p></blockquote><p>ok,下一章分析具体的Filter链中的节点,探究下Spring Security是如何进行用户认证与权限控制的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-Security是什么&quot;&gt;&lt;a href=&quot;#Spring-Security是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring Security是什么?&quot;&gt;&lt;/a&gt;Spring Security是什么?&lt;/h3&gt;&lt;p&gt;Spri
      
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>WEB小知识-HTTP请求对+和&amp;的处理</title>
    <link href="http://mrdear.cn/2017/05/22/web/WEB%E5%B0%8F%E7%9F%A5%E8%AF%86-HTTP%E8%AF%B7%E6%B1%82%E5%AF%B9+%E5%92%8C&amp;%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/22/web/WEB小知识-HTTP请求对+和&amp;的处理/</id>
    <published>2017-05-22T14:18:00.000Z</published>
    <updated>2017-05-22T14:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.</p><blockquote><p>对于<code>+</code>号会被编码为空格<br>对于<code>&amp;</code>也会被编码成空格</p></blockquote><p>举个例子,需要向服务端提交如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>编码后的内容如下,可以发现<code>a+b</code>被转换成了<code>a b</code>导致服务端接收到后编译失败.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include%20%3Ciostream%3E%0A%0Ausing%20namespace%20std;</div><div class="line">%<span class="number">0</span>A%<span class="number">0</span>Aint%<span class="number">20</span>main()%<span class="number">0</span>A%<span class="number">7</span>B%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span><span class="keyword">int</span>%<span class="number">20</span>a,b;</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cin%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>a%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>b;</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cout%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>a b%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>endl;</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>return%<span class="number">200</span>;%<span class="number">0</span>A%<span class="number">7</span>D</div></pre></td></tr></table></figure></p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>使用函数<code>encodeURIComponent()</code>,该函数会把特殊字符都给转义,转义结果如下面所示,可见<code>a+b</code>转换成了<code>a%2Bb</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%<span class="number">23</span>include%<span class="number">20</span>%<span class="number">3</span>Ciostream%<span class="number">3</span>E%<span class="number">0</span>A%<span class="number">0</span>Ausing%<span class="number">20</span>namespace%<span class="number">20</span>std%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">0</span>Aint%<span class="number">20</span>main()%<span class="number">0</span>A%<span class="number">7</span>B%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span><span class="keyword">int</span>%<span class="number">20</span>a%<span class="number">2</span>Cb%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cin%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>a%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>b%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cout%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>a%<span class="number">2</span>Bb%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>endl%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>return%<span class="number">200</span>%<span class="number">3</span>B%<span class="number">0</span>A%<span class="number">7</span>D</div></pre></td></tr></table></figure></p><p>服务端需要使用<code>URLDecoder</code>对其进行反转义,该问题到此解决.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1.问题&quot;&gt;&lt;/a&gt;1.问题&lt;/h3&gt;&lt;p&gt;在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.&lt;/p&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="bug" scheme="http://mrdear.cn/tags/bug/"/>
    
  </entry>
  
</feed>
