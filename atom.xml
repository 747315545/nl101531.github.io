<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  <subtitle>change from today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrdear.cn/"/>
  <updated>2017-05-22T15:59:25.000Z</updated>
  <id>http://mrdear.cn/</id>
  
  <author>
    <name>Niu li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WEB小知识-HTTP请求对+和&amp;的处理</title>
    <link href="http://mrdear.cn/2017/05/22/web/WEB%E5%B0%8F%E7%9F%A5%E8%AF%86-HTTP%E8%AF%B7%E6%B1%82%E5%AF%B9+%E5%92%8C&amp;%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/22/web/WEB小知识-HTTP请求对+和&amp;的处理/</id>
    <published>2017-05-22T14:18:00.000Z</published>
    <updated>2017-05-22T15:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.</p>
<blockquote>
<p>对于<code>+</code>号会被编码为空格<br>对于<code>&amp;</code>也会被编码成空格</p>
</blockquote>
<p>举个例子,需要向服务端提交如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编码后的内容如下,可以发现<code>a+b</code>被转换成了<code>a b</code>导致服务端接收到后编译失败.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include%20%3Ciostream%3E%0A%0Ausing%20namespace%20std;</div><div class="line">%0A%0Aint%20main()%0A%7B%0A%20%20%20%20int%20a,b;</div><div class="line">%0A%20%20%20%20cin%20%3E%3E%20a%20%3E%3E%20b;</div><div class="line">%0A%20%20%20%20cout%20%3C%3C%20a b%20%3C%3C%20endl;</div><div class="line">%0A%20%20%20%20return%200;%0A%7D</div></pre></td></tr></table></figure></p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>使用函数<code>encodeURIComponent()</code>,该函数会把特殊字符都给转义,转义结果如下面所示,可见<code>a+b</code>转换成了<code>a%2Bb</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%<span class="number">23</span>include%<span class="number">20</span>%<span class="number">3</span>Ciostream%<span class="number">3</span>E%<span class="number">0</span>A%<span class="number">0</span>Ausing%<span class="number">20</span>namespace%<span class="number">20</span>std%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">0</span>Aint%<span class="number">20</span>main()%<span class="number">0</span>A%<span class="number">7</span>B%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span><span class="keyword">int</span>%<span class="number">20</span>a%<span class="number">2</span>Cb%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cin%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>a%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>b%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cout%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>a%<span class="number">2</span>Bb%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>endl%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>return%<span class="number">200</span>%<span class="number">3</span>B%<span class="number">0</span>A%<span class="number">7</span>D</div></pre></td></tr></table></figure></p>
<p>服务端需要使用<code>URLDecoder</code>对其进行反转义,该问题到此解决.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1.问题&quot;&gt;&lt;/a&gt;1.问题&lt;/h3&gt;&lt;p&gt;在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.&lt;/p&gt;
&lt;blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="bug" scheme="http://mrdear.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(二)-Stream原理</title>
    <link href="http://mrdear.cn/2017/05/20/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)-Stream%E5%8E%9F%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/20/java/Java8学习记录(二)-Stream原理/</id>
    <published>2017-05-20T11:06:51.000Z</published>
    <updated>2017-05-24T03:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一篇博文,很好的介绍了Stream的原理.本文对其进行一些补充更加详细的讲解.</p>
<blockquote>
<p>作者: 李豪<br>地址: <a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md" target="_blank" rel="external">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md</a></p>
</blockquote>
<h3 id="操作如何记录"><a href="#操作如何记录" class="headerlink" title="操作如何记录?"></a>操作如何记录?</h3><p>操作的记录用的是双向链表,那么这个链表是怎么建立的呢?<br>类: <code>AbstractPipeline</code>是整个调用链建立的核心类,其含有成员变量<code>sourceStage(调用起始点)</code>,<code>previousStage(上一个调用)</code>,<code>nextStage(下一个调用)</code>,再看其构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</div><div class="line">     <span class="keyword">if</span> (previousStage.linkedOrConsumed)</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</div><div class="line">    <span class="comment">//previousStage为上一次调用,那么他的下一次调用则是当前的this</span></div><div class="line">     previousStage.linkedOrConsumed = <span class="keyword">true</span>;</div><div class="line">     previousStage.nextStage = <span class="keyword">this</span>;</div><div class="line">     <span class="comment">//当前this的上一次调用为previousStage</span></div><div class="line">     <span class="keyword">this</span>.previousStage = previousStage;</div><div class="line">     <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</div><div class="line">     <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</div><div class="line">     <span class="comment">//调用起始点都是同一个</span></div><div class="line">     <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</div><div class="line">     <span class="keyword">if</span> (opIsStateful())</div><div class="line">         sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</div><div class="line">     <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>每一次操作都会建立一个新的Stream,传入上一个Stream,调用上方构造函数初始化,进而形成双向链表.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</div><div class="line">                 StreamShape inputShape,</div><div class="line">                 <span class="keyword">int</span> opFlags) &#123;</div><div class="line">         <span class="keyword">super</span>(upstream, opFlags);</div><div class="line">         <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h3 id="操作如何叠加"><a href="#操作如何叠加" class="headerlink" title="操作如何叠加"></a>操作如何叠加</h3><p>如原文所说,以filter方法为例,调用该方法会产生一个StatelessOp对象,也就是AbstractPipeline的子类,其方法<code>opWrapSink</code>很关键,产生一个<code>Sink</code>对象,在自身<code>accept(t)</code>方法处理自身逻辑,得到的结果传递给下游的stream<code>downstream.accept(u);</code>,也就是博主所说的<strong>处理/转发模式</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</div><div class="line">      Objects.requireNonNull(predicate);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</div><div class="line">                                   StreamOpFlag.NOT_SIZED) &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">                      downstream.begin(-<span class="number">1</span>);</div><div class="line">                  &#125;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</div><div class="line">                      <span class="keyword">if</span> (predicate.test(u))</div><div class="line">                          downstream.accept(u);</div><div class="line">                  &#125;</div><div class="line">              &#125;;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="叠加之后的操作如何执行"><a href="#叠加之后的操作如何执行" class="headerlink" title="叠加之后的操作如何执行"></a>叠加之后的操作如何执行</h3><p>首先操作都在Sink中,操作的叠加已经没问题了,那问题就是怎么把这些操作连起来,形成一个单项的调用链.如下图所示,我们所期望的调用关系是从filter.sink开始的单链表.但是当操作到<code>sorted()</code>的时候我们只能得到<code>sort.sink</code>,无法得知上游信息,所以这个单链表的建立还需要其他方案.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1495593370.png?imageMogr2/thumbnail/!70p" alt=""><br>该调用单链表的建立是使用<code>wrapSink</code>方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</div><div class="line">     Objects.requireNonNull(sink);</div><div class="line">     <span class="comment">//该循环体,从终端stage往前迭代,到最后形成的sink对象就是filter.sink</span></div><div class="line">     <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</div><div class="line">         sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法从终端操作往前迭代,最终形成的sink就是如单链表结构,此时的sink对象就是filter.sink,并且其还指向map.sink.</p>
<p>现在拿到了调用链式,接下来就是想办法在一次循环遍历中执行全部操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(wrappedSink);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</div><div class="line">        <span class="comment">//调用begin方法准备容器</span></div><div class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</div><div class="line">        <span class="comment">//对sink迭代</span></div><div class="line">        spliterator.forEachRemaining(wrappedSink);</div><div class="line">        <span class="comment">//终端操作</span></div><div class="line">        wrappedSink.end();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        copyIntoWithCancel(wrappedSink, spliterator);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时的wrappedSink对象是一个完整的调用链,那么对于<code>spliterator.forEachRemaining(wrappedSink);</code>的执行就是对每一个元素在调用链上走一遍的流程.这三行代码可以用下图表示<br>begin<br><img src="http://oobu4m7ko.bkt.clouddn.com/1495594524.png?imageMogr2/thumbnail/!70p" alt=""><br>accept<br><img src="http://oobu4m7ko.bkt.clouddn.com/1495594311.png?imageMogr2/thumbnail/!70p" alt=""><br>end<br><img src="http://oobu4m7ko.bkt.clouddn.com/1495594563.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h3 id="执行后的结果在哪里"><a href="#执行后的结果在哪里" class="headerlink" title="执行后的结果在哪里"></a>执行后的结果在哪里</h3><p>即终端操作所提供的容器中.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一篇博文,很好的介绍了Stream的原理.本文对其进行一些补充更加详细的讲解.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: 李豪&lt;br&gt;地址: &lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals/
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(一)-函数式接口</title>
    <link href="http://mrdear.cn/2017/05/18/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://mrdear.cn/2017/05/18/java/Java8学习记录(一)-函数式接口/</id>
    <published>2017-05-18T15:39:11.000Z</published>
    <updated>2017-05-20T10:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>实习前只是粗略的看了下Java8的一些基本语法,但是没有系统的学习过.在使用一段时间后决定系统的对其进行一次分析,加深对Java8函数式编程的理解,提高自己的编码技巧.另外kotlin崛起,感兴趣的朋友尝试下混编也未尝不可.</p>
<hr>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口,对于Java来说就是接口内只有一个公开方法的接口,因为使用lanbda表达式,例如<code>() -&gt; user.getName()</code>对应的调用则可能是<code>func.get()</code>,编译器会根据接口推断所属于的方法,如果有两个则无法推断.Java8提供了很多函数式接口,一般都使用注解<code>@FunctionalInterface</code>声明,有必要了解如下一些函数式接口.</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supplier<t></t></td>
<td>无</td>
<td>T</td>
<td>接收一个T类型的值</td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>T</td>
<td>无</td>
<td>处理一个T类型的值</td>
</tr>
<tr>
<td>BiConsumer<t, u=""></t,></td>
<td>T,U</td>
<td>无</td>
<td>处理T类型和U类型的值</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>T</td>
<td>boolean</td>
<td>处理T类型的值,并返回true或者false.</td>
</tr>
<tr>
<td>ToIntFunction<t></t></td>
<td>T</td>
<td>int</td>
<td>处理T类型的值,并返回int值</td>
</tr>
<tr>
<td>ToLongFunction<t></t></td>
<td>T</td>
<td>long</td>
<td>处理T类型的值,并返回long值</td>
</tr>
<tr>
<td>ToDoubleFunction<t></t></td>
<td>T</td>
<td>double</td>
<td>处理T类型的值,并返回double值</td>
</tr>
<tr>
<td>Function<t, r=""></t,></td>
<td>T</td>
<td>R</td>
<td>处理T类型的值,并返回R类型值</td>
</tr>
<tr>
<td>BiFunction<t, u,="" r=""></t,></td>
<td>T,U</td>
<td>R</td>
<td>处理T类型和U类型的值,并返回R类型值</td>
</tr>
<tr>
<td>BiFunction<t, u,="" r=""></t,></td>
<td>T,U</td>
<td>R</td>
<td>处理T类型和U类型的值,并返回R类型值</td>
</tr>
<tr>
<td>UnaryOperator<t></t></td>
<td>T</td>
<td>T</td>
<td>处理T类型值,并返回T类型值,</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T,T</td>
<td>T</td>
<td>处理T类型值,并返回T类型值</td>
</tr>
</tbody>
</table>
<p>以上的函数每一个代表的都是一种基本的操作,操作之间可以自由组合,所以才有了stream这些灵活的操作.</p>
<h3 id="Stream操作"><a href="#Stream操作" class="headerlink" title="Stream操作"></a>Stream操作</h3><p>Stream的操作是建立在函数式接口的组合上的,最好的学习方法是看Stream接口来学习.下面举一些例子来分析,假设有这样的一些初始数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; testData = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    testData.add(<span class="string">"张三"</span>);</div><div class="line">    testData.add(<span class="string">"李四"</span>);</div><div class="line">    testData.add(<span class="string">"王二"</span>);</div><div class="line">    testData.add(<span class="string">"麻子"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>filter</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div></pre></td></tr></table></figure></p>
<p>filter接收predicate函数,predicate是接收T值,返回boolean值,那么对应的引用就可以写成如下形式,意思是取集合中以’张’开头的名字.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .filter(x -&gt; x.startsWith(<span class="string">"张"</span>))</div></pre></td></tr></table></figure></p>
<p><strong>map</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</div></pre></td></tr></table></figure></p>
<p>map操作接收的是Function接口,对于Function接收T值返回R值,那map的作用就很明显是转换用的,比如下面代码,转换名称为对应的名称长度,也就是从输入String数据返回int数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .map(x -&gt; x.length())</div></pre></td></tr></table></figure></p>
<p><strong>flatMap</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</div></pre></td></tr></table></figure></p>
<p>flatMap和map都是使用Function接口,不同的是返回值flatMap限定为Stream类型.所以flatMap可以作为合并流使用,如以下代码,提取出所有的字符.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">        .collect(Collectors.toList());</div><div class="line">        <span class="comment">//输出  [张, 三, 李, 四, 王, 二, 麻, 子]</span></div></pre></td></tr></table></figure></p>
<p><strong>peek</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div></pre></td></tr></table></figure></p>
<p>peek参数为Consumer,Consumer接收T值,无返回,那么该方法就可以作为调试不影响stream中内容的一些操作,不过由于对象都是地址引用,你再此做一些对象内容操作也是可以的.<br><strong>reduce</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Reduce比较复杂的一个接口,属于归纳性操作,看参数,第一个是U泛型,也就是输入类型的参数,最为初始值,第二个BiFunction,接收T,U参数,返回U类型参数,BinaryOperator接收U,U类型,并返回U类型.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> StringBuilder identity = <span class="keyword">new</span> StringBuilder();</div><div class="line"> StringBuilder reduce = testData.stream()</div><div class="line">     .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">     .reduce(identity, (r, x) -&gt; &#123;</div><div class="line">       r.append(x);</div><div class="line">       <span class="keyword">return</span> r;</div><div class="line">     &#125;, StringBuilder::append);</div><div class="line"> System.out.println(identity == reduce);</div><div class="line"> System.out.println(reduce.toString());</div><div class="line"> <span class="comment">//输出 true</span></div><div class="line"><span class="comment">//  张三李四王二麻子</span></div></pre></td></tr></table></figure></p>
<p>首先提供一个基本容器identity,然后两个参数r即是identity,x为每次输入参数,最后一个StringBuilder::append是并发下多个identity的合并策略.<br>再举个例子,既然reduce属于归纳性操作,那么也可以当成collect使用,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; identity = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   ArrayList&lt;String&gt; result = testData.stream()</div><div class="line">       .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">       .reduce(identity, (r, x) -&gt; &#123;</div><div class="line">         r.add(x);</div><div class="line">         <span class="keyword">return</span> r;</div><div class="line">       &#125;,(r1,r2) -&gt; &#123;</div><div class="line">         r1.addAll(r2);</div><div class="line">         <span class="keyword">return</span> r1;</div><div class="line">       &#125;);</div><div class="line">   System.out.println(identity == result);</div><div class="line">   System.out.println(result);</div><div class="line">   <span class="comment">//输出 true</span></div><div class="line">   <span class="comment">//[张, 三, 李, 四, 王, 二, 麻, 子]</span></div></pre></td></tr></table></figure></p>
<h3 id="强大的collect"><a href="#强大的collect" class="headerlink" title="强大的collect"></a>强大的collect</h3><p>collect无疑是stream中最强大的操作,掌握了collect操作才能说掌握了stream.为了便于使用者,Java提供了<code>Collectors</code>类,该类提供了很多便捷的collect操作,如<code>Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>,<code>Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>等操作.这些操作最终都会调用如下构造函数构造出collector对象,因此掌握该本质是最佳的学习方式.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CollectorImpl(Supplier&lt;A&gt; supplier,</div><div class="line">                      BiConsumer&lt;A, T&gt; accumulator,</div><div class="line">                      BinaryOperator&lt;A&gt; combiner,</div><div class="line">                      Function&lt;A,R&gt; finisher,</div><div class="line">                      Set&lt;Characteristics&gt; characteristics) &#123;</div><div class="line">            <span class="keyword">this</span>.supplier = supplier;</div><div class="line">            <span class="keyword">this</span>.accumulator = accumulator;</div><div class="line">            <span class="keyword">this</span>.combiner = combiner;</div><div class="line">            <span class="keyword">this</span>.finisher = finisher;</div><div class="line">            <span class="keyword">this</span>.characteristics = characteristics;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>Supplier类似reduce中的u,接收一个元数据,BiConsumer则是操作数据,BinaryOperator并发下聚合,finisher完成时的转换操作,Set<characteristics>应该按照定义是优化一些操作中的转换.如下面的toList()操作,其finish操作为<code>castingIdentity()</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"> Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</div><div class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</div><div class="line">                                CH_ID);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></characteristics></p>
<p>再看toMap的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;</div><div class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</div><div class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</div><div class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</div><div class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</div><div class="line">    BiConsumer&lt;M, T&gt; accumulator</div><div class="line">            = (map, element) -&gt; map.merge(keyMapper.apply(element),</div><div class="line">                                          valueMapper.apply(element), mergeFunction);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Function作为转换函数提供了key和value的转换,BinaryOperator提供了重复key合并策略,mapSupplier则表示最终收集到的容器.那么使用就很简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Character, String&gt; map = testData.stream()</div><div class="line">        .collect(Collectors.toMap(x -&gt; x.charAt(<span class="number">0</span>), Function.identity()</div><div class="line">            , (v1, v2) -&gt; v2, HashMap::<span class="keyword">new</span>));</div></pre></td></tr></table></figure></p>
<p>其他还有很多方法,就不一一叙述,主要是了解这些接口,知道他所拥有的功能,以及组合的意义,即可很好的掌握Java中的函数式编程.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习前只是粗略的看了下Java8的一些基本语法,但是没有系统的学习过.在使用一段时间后决定系统的对其进行一次分析,加深对Java8函数式编程的理解,提高自己的编码技巧.另外kotlin崛起,感兴趣的朋友尝试下混编也未尝不可.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;函数式接口&quot;&gt;
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java中序列化相关知识</title>
    <link href="http://mrdear.cn/2017/05/02/%E5%B7%A5%E5%85%B7/Java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://mrdear.cn/2017/05/02/工具/Java中的序列化相关知识/</id>
    <published>2017-05-02T08:00:00.000Z</published>
    <updated>2017-05-07T13:13:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天线上遇到了DTO类实现了<code>Serializable</code>接口,但是其并没有显示声明<code>serialVersionUID</code>,这样的话每次打包有改动JDK就会为其重新生成<code>serialVersionUID</code>.这就带来了不同版本之间的实体类可能反序列化不成功,线上RPC调用出现了问题.那么就深入探讨一下原因.</p>
<h3 id="Serializable的作用"><a href="#Serializable的作用" class="headerlink" title="Serializable的作用"></a>Serializable的作用</h3><p>看该类的JDK注释可以发现<code>The serialization interface has no methods or fields and serves only to identify the semantics of being serializable.</code>也就是说Serializable是一个标识接口,和<code>Cloneable</code>接口等一样的效果.<br>如下面的User类,实现了序列化接口,并使用<code>serialVersionUID</code>标识其序列化对应的ID序号.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5768430629641297769L</span>;</div><div class="line">  <span class="keyword">private</span> String nickname;</div><div class="line">  <span class="keyword">private</span> String passwd;</div><div class="line">  <span class="comment">//省略get和set</span></div></pre></td></tr></table></figure></p>
<h3 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h3><p><code>java.io.ObjectOutputStream</code>代表对象输出流,其使用writeObject()方法把对象实例转换为字节流然后写入到文件,或者用于网络传输.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  User userDO = <span class="keyword">new</span> User();</div><div class="line">  userDO.setNickname(<span class="string">"屈定"</span>);</div><div class="line">  userDO.setPasswd(<span class="string">"123456"</span>);</div><div class="line">  File file = <span class="keyword">new</span> File(<span class="string">"user.out"</span>);</div><div class="line">  ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">  outputStream.writeObject(userDO);<span class="comment">//序列化写入到文件中.</span></div><div class="line">  outputStream.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何反序列化"><a href="#如何反序列化" class="headerlink" title="如何反序列化"></a>如何反序列化</h3><p><code>java.io.ObjectInputStream</code>代表对象输入流,其使用readObject()方法读取序列化的字节,然后再转换为对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">  File file = <span class="keyword">new</span> File(base+File.separator+<span class="string">"user.out"</span>);</div><div class="line">  ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">  User user = (User) inputStream.readObject();</div><div class="line">  Assert.assertTrue(StringUtils.equals(user.getNickname(),<span class="string">"屈定"</span>));</div><div class="line">  Assert.assertTrue(StringUtils.equals(user.getPasswd(),<span class="string">"123456"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h3><p>按照上面代码,序列化和反序列化都是成功的,如果在已经序列化后,对User要作修改,增加一个email字段,再试试反序列化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5768430629641297769L</span>;</div><div class="line">    <span class="keyword">private</span> String nickname;</div><div class="line">    <span class="keyword">private</span> String passwd;</div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序会正常运行,而且这个email会被很智能的初始化为null.<br>修改<code>serialVersionUID</code>为1L再试试.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.io.InvalidClassException: cn.edu.aust.test.ObjectTest$User; local class incompatible: stream classdesc serialVersionUID = 5768430629641297769, local class serialVersionUID = 1</div></pre></td></tr></table></figure></p>
<p>报错很明显,两边类的<code>serialVersionUID</code>不一样,也就是说对于编译好的class,其<code>serialVersionUID</code>是其序列化的唯一标识,如果未显示声明JDK则会自动为其加上,可以使用命令<code>seriserialver</code>可以查看一个class文件的<code>serialVersionUID</code>,当线上版本忘记加该字段的时候该命令还是很有用处的.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">seriserialver cn.edu.aust.test.ObjectTest\<span class="variable">$User</span> </div><div class="line">cn.edu.aust.test.ObjectTest<span class="variable">$User</span>:    private static final long serialVersionUID = 1L;</div></pre></td></tr></table></figure></p>
<h3 id="transient的作用"><a href="#transient的作用" class="headerlink" title="transient的作用"></a>transient的作用</h3><p>transient翻译为瞬时,也就是被其修饰的变量序列化时会忽略该字段.什么时候需要用到这个字段呢?<br>在Java中对象之间的关系会组成一个对象图,序列化的过程是对该对象图的遍历,那么反序列化也仍然是对该对象图的遍历.对于对象里面的对象就是递归过程,对于链表之类的数据结构递归的话很容易引起栈溢出,那么就可以使用<code>transient</code>忽略该字段.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天线上遇到了DTO类实现了&lt;code&gt;Serializable&lt;/code&gt;接口,但是其并没有显示声明&lt;code&gt;serialVersionUID&lt;/code&gt;,这样的话每次打包有改动JDK就会为其重新生成&lt;code&gt;serialVersionUID&lt;/code&gt;.这就带
    
    </summary>
    
      <category term="工作问题" scheme="http://mrdear.cn/categories/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="jdk" scheme="http://mrdear.cn/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>对一个WEB请求的理解</title>
    <link href="http://mrdear.cn/2017/04/30/%E8%BF%90%E7%BB%B4/%E5%AF%B9%E4%B8%80%E4%B8%AAWEB%E8%AF%B7%E6%B1%82%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://mrdear.cn/2017/04/30/运维/对一个WEB请求的理解/</id>
    <published>2017-04-29T16:00:00.000Z</published>
    <updated>2017-05-06T01:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着写的WEB程序越来越多,项目的部署也越来越繁琐,对于一些线上问题总是搞不清楚是哪个环节出的问题,归根结底是对整个流程的不熟悉导致,所以分析下一个WEB请求从用户输入地址到页面出来到底经历过多少东西.</p>
<h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><p>首先把URL分割为几个部分,以地址<code>http://mrdear.cn/2017/04/15/动漫推荐/</code>为例<br>协议: http<br>网址: mrdear.cn<br>资源路径: 2017/04/15/动漫推荐/</p>
<p>浏览器拿到地址后会对其中非ASCII码的Unicode字符解析,比如空格会变成%20,汉字也会变成其16进制对应的编码值,如下例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">上面链接等价于</div><div class="line">http:<span class="comment">//mrdear.cn/2017/04/15/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/</span></div></pre></td></tr></table></figure></p>
<p>中间还有其他很复杂的流程,比如参数,协议,请求头,请求体等建立.</p>
<h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>对于网址mrdear.cn,浏览器并不知道他所处的服务器位置,因此需要解析出其服务器ip,这个过程就是DNS域名解析.</p>
<ul>
<li>浏览器首先检查自身缓存dns解析,以chrome为例,输入<code>chrome://net-internals/#dns</code>即可看到缓存列表.该缓存通常几分钟到几小时不等,存在的话就直接返回,否则下一步</li>
<li>和浏览器同样策略,OS对每一次解析结果也会做缓存,浏览器中不存在则在OS的缓存中查找.这个过成功也包括在本地hosts中查找.找到则返回,找不到则向本机的dns服务器发送查找请求.</li>
<li><p>DNS服务器和本机在一个子网内,则APR解析到具体设备的mac地址,然后向其查找.如果不在一个子网,则直接ARP解析当前主机网关地址,网关一般是上一个路由节点,也就是把查询转交给上一层服务器,那么上一层服务器找不到还会转交给它的上一层,如此形成一个递归查询过程,直到查找到根服务器.找不到则返回失败.找到则返回ip地址和其TTL时间.<br>linux和unix下的dns配置在<code>/etc/resolv.conf</code>中,可以使用<code>nslookup或者dig查</code>看解析过程.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1493479248.png?imageMogr2/thumbnail/!60p" alt=""></p>
</li>
<li><p>解析成功后,浏览器创建与服务器的socket连接,构造请求信息,进行TCP三次握手,开始向服务器传输消息,并等服务器回复信息,这也是TPC可靠的一个原因.</p>
</li>
</ul>
<h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>服务器以nginx+tomcat为例,经过以上步骤后请求到达了nginx,nginx对URL进行分析,验证其所在机器上有所需要的服务,并且用户是有权限调用的,决定该URL由哪一个tomcat服务处理,捕获处理结果,返回给请求者,最后四次挥手结束请求.到此完成浏览器,服务端的通信.</p>
<h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>浏览器拿到了服务器的返回信息后会对内容进行解析,展现成用户所需要的内容,如html,pdf等.</p>
<hr>
<p>那么整个过程总结来看就是 用户输入URL -&gt; 浏览器解析地址 -&gt; DNS查找域名对应ip -&gt; 服务器响应 -&gt;浏览器拿到响应渲染.</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="1-CDN网络"><a href="#1-CDN网络" class="headerlink" title="1.CDN网络"></a>1.CDN网络</h4><p>CDN又叫内容分布网络,一般用于静态资源如html,css,js的存储,简单的理解为一张大网,网上每一个节点都有着很多资源.那么每一个用户想要访问的时候就会去找离他最近的节点上面获取需要的内容.从而加快了网站整体访问速度.<br>举个例子:用户访问taobao的某css文件,首先浏览器会发送请求 -&gt; DNS解析域名,这里一般会有一个DNS负载均衡服务器,其得到最适合用户的CDN节点ip -&gt; 用户拿到CDN节点ip得到资源.</p>
<h4 id="2-DNS劫持"><a href="#2-DNS劫持" class="headerlink" title="2.DNS劫持"></a>2.DNS劫持</h4><p>了解了DNS的解析是一个递归过程,找到域名 &lt;-&gt; ip就返回,如果有人手动修改了该条映射信息,那么就会返回到错误的ip地址,这种行为也叫DNS劫持,对于客户端来说,没有很好地方式能认为服务器返回的信息是可靠的,也就是不可靠的HTTP通信,所以也就导致了这一层的攻击漏洞,而这种事一般是天朝的电信运营商能干得出来,所以选择一个靠谱的DNS是非常重要,推荐<code>114.114.114.114</code></p>
<h4 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3.HTTPS"></a>3.HTTPS</h4><p>应对HTTP的不可靠通信,所以诞生了HTTPS,即HTTP over SSL,使用SSL/TLS对HTTP的内容进行加密解密.整个流程如下图:</p>
<p><center><img src="http://oobu4m7ko.bkt.clouddn.com/1493510445.png?imageMogr2/thumbnail/!100p" alt=""></center></p>
<ul>
<li>在SSL握手阶段，客户端浏览器会认证服务器的身份，这是通过“证书”来实现的，证书由证书权威（CA）为某个域名签发，可以理解为网站的身份证件，客户端需要对这个证件进行认证，需要确定该证书是否属于目标网站并确认证书本身是否有效。最后在握手阶段，通信的双方还会协商出一个用于加密和解密的会话密钥。</li>
<li>SSL握手阶段结束之后，服务器和客户端使用协商出的会话密钥对交互的数据进行加密/解密操作，对于HTTP协议来说，就是将HTTP请求和应答经过加密之后再发送到网络上。<br>HTTPS协议对服务器进行了一次身份验证,所以即使DNS被劫持,定向到的服务器也会因为没证书而无法通过身份验证.</li>
</ul>
<h4 id="4-乱码问题"><a href="#4-乱码问题" class="headerlink" title="4.乱码问题"></a>4.乱码问题</h4><p>流程清晰后乱码问题就很好解决了,把浏览器,Nginx,Tomcat等都当成水池的话,数据的乱码只能在每一个的入口端和出口端.如果发生了乱码,那么首先定位到是哪一个口产生了乱码,然后再去找原因,一般都能解决.<br>以JavaWEB应用为例,乱码主要发生在IO交互的过程中.其一浏览器与服务器建立socket连接,浏览器对URL以及request转换编码.请求到达tomcat,tomcat会对其进行解码,这个解码可在tomcat目录下的conf/server.xml中配置URIEncoding<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">connector</span> <span class="attr">port</span>=<span class="string">”8080″</span> <span class="attr">protocol</span>=<span class="string">”HTTP/1.1″</span> <span class="attr">maxThreads</span>=<span class="string">”150″</span>   <span class="attr">connectionTimeout</span>=<span class="string">”200000″</span></span></div><div class="line">     <span class="attr">redirecPort</span>=<span class="string">”8443″</span>    <span class="attr">URIEncoding</span>=<span class="string">”utf-8″/</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这里要保证不乱码,下一步tomcat建立了ServletRequest和ServletResponse,那么这里也有编码,一般是post表单或者request body乱码,那么就需要指定ServletRequest和ServletResponse的编码格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request.setCharacterEncoding(encoding);<span class="comment">//设置请求信息编码</span></div><div class="line">response.setCharacterEncoding(encoding);<span class="comment">//设置返回信息编码</span></div></pre></td></tr></table></figure></p>
<p>Java程序在处理请求时和操作系统会有IO通信,和数据库会有IO通信,整个过程也会涉及编码,这种一般代码中会自动控制,出问题几率不大.<br>浏览器拿到返回信息后对页面进行渲染,这一步也会有编码,这个一般手动指定下浏览器的渲染编码,比如<code>Content-Type: text/html;charset=UTF-8</code>,指定以UTF-8渲染该text/html返回.</p>
<h4 id="5-几种域名解析"><a href="#5-几种域名解析" class="headerlink" title="5.几种域名解析"></a>5.几种域名解析</h4><p>域名解析记录主要分为：A 记录、MX记录、CNAME 记录、NS记录和 TXT记录</p>
<ul>
<li>A记录：A 代表的是Address，用来指定域名对应的IP地址。域名可以多对一但是不能一对多。</li>
<li>MX记录：Mail Exchange,就是讲某个域名下的邮件服务器指向自己的Mail Server。</li>
<li>CNAME记录：别名解析。将一个域名设置一个或者多个别名。</li>
<li>NS记录：为某个域名指定DNS解析服务器。</li>
<li>TXT记录：为某个主机名或者域名设置文字说明。<br>本站是托管于github的,主域名<code>mrdear.cn</code>是使用CNAME解析到<code>nl101531.github.io</code>的,二级域名<code>oj.mrdear.cn</code>和<code>md.mrdear.cn</code>都是使用A记录解析到对应主机的ip地址,到达主机后再使用Nginx进行不同的服务器转发.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1493775848.png?imageMogr2/thumbnail/!70p" alt=""></li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>个人总结,如有错误请指出,以免误人子弟.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着写的WEB程序越来越多,项目的部署也越来越繁琐,对于一些线上问题总是搞不清楚是哪个环节出的问题,归根结底是对整个流程的不熟悉导致,所以分析下一个WEB请求从用户输入地址到页面出来到底经历过多少东西.&lt;/p&gt;
&lt;h3 id=&quot;URL解析&quot;&gt;&lt;a href=&quot;#URL解析&quot;
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="http" scheme="http://mrdear.cn/tags/http/"/>
    
      <category term="web" scheme="http://mrdear.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(八)</title>
    <link href="http://mrdear.cn/2017/04/29/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E5%85%AB)/"/>
    <id>http://mrdear.cn/2017/04/29/毕业设计/毕业设计周记(八)/</id>
    <published>2017-04-29T10:00:00.000Z</published>
    <updated>2017-04-29T11:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>写毕业设计过程中发现一些设计不是很好的地方,比如说结构上之前maven模块化分层,dao,service,controller每一个都是单独的maven项目,导致开发起来比较麻烦,所以改掉了,把数据库模型对应的DO单独放入一个架包,然后dao,service,controller等放入一个war包中,明白了对于一个小项目来说过多的分层是系统开发的累赘.</p>
<p>修改数据库模型后代码不少地方重新写了下,耽误了点时间,五一期间仍然是写毕业论文.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>后端项目地址: <a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
<p>测试地址: <a href="http://oj.mrdear.cn" target="_blank" rel="external">http://oj.mrdear.cn</a></p>
<p>测试账号: 1015315668@qq.com<br>          111111</p>
<p>等待完成:</p>
<p>1.毕业论文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写毕业设计过程中发现一些设计不是很好的地方,比如说结构上之前maven模块化分层,dao,service,controller每一个都是单独的maven项目,导致开发起来比较麻烦,所以改掉了,把数据库模型对应的DO单独放入一个架包,然后dao,service,control
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(七)</title>
    <link href="http://mrdear.cn/2017/04/24/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%B8%83)/"/>
    <id>http://mrdear.cn/2017/04/24/毕业设计/毕业设计周记(七)/</id>
    <published>2017-04-24T11:00:00.000Z</published>
    <updated>2017-04-24T11:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周把个人中心完成了,用户注册后的邮件验证,以及注册后的更新自身信息,找回密码等功能都完成.</p>
<p>毕业论文正在写系统整体设计,需要画一些图.预计五一假期之后初稿出来.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>后端项目地址: <a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
<p>测试地址: <a href="http://oj.mrdear.cn" target="_blank" rel="external">http://oj.mrdear.cn</a></p>
<p>测试账号: 1015315668@qq.com<br>          111111</p>
<p>等待完成:</p>
<p>1.毕业论文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周把个人中心完成了,用户注册后的邮件验证,以及注册后的更新自身信息,找回密码等功能都完成.&lt;/p&gt;
&lt;p&gt;毕业论文正在写系统整体设计,需要画一些图.预计五一假期之后初稿出来.&lt;/p&gt;
&lt;p&gt;前端项目地址: &lt;a href=&quot;https://github.com/nl101
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>少走弯路的10条建议(转)</title>
    <link href="http://mrdear.cn/2017/04/21/%E7%BB%8F%E9%AA%8C/%E5%B0%91%E8%B5%B0%E5%BC%AF%E8%B7%AF%E7%9A%8410%E6%9D%A1%E5%BB%BA%E8%AE%AE(%E8%BD%AC)/"/>
    <id>http://mrdear.cn/2017/04/21/经验/少走弯路的10条建议(转)/</id>
    <published>2017-04-21T01:50:00.000Z</published>
    <updated>2017-04-21T01:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="少走弯路的10条建议-转"><a href="#少走弯路的10条建议-转" class="headerlink" title="少走弯路的10条建议(转)"></a>少走弯路的10条建议(转)</h1><p>标签（空格分隔）： 经验</p>
<hr>
<p>转载自一个很佩服的大牛博客:<a href="http://www.cnblogs.com/xdp-gacl/p/4102862.html" target="_blank" rel="external">孤傲苍狼</a></p>
<hr>
<p>　如何在涉世之初少走弯路，有一个好的开端，开始一番成功的事业？以下是一些先行者积累的10条有益的涉世忠告。好好地遵循、把握这些忠告和建议吧，比起所学的课堂课程来，它毫不逊色！</p>
<p>1.1、买个闹钟，以便按时叫醒你</p>
<p>　　贪睡和不守时，都将成为你工作和事业上的绊脚石，任何时候都一样。不仅要学会准时，更要学会提前。就如你坐车去某地，沿途的风景很美，你忍不住下车看一看，后来虽然你还是赶到了某地，却不是准时到达。“闹钟”只是一种简单的标志和提示，真正灵活、实用的时间，掌握在每个人的心中。  </p>
<p>1.2、如果你不喜欢现在的工作，要么辞职不干，要么就闭嘴不言</p>
<p>　　初出茅庐，往往眼高手低，心高气傲，大事做不了，小事不愿做。不要养成挑三拣四的习惯。不要雨天烦打伞，不带伞又怕淋雨，处处表现出不满的情绪。记住，不做则已，要做就要做好。</p>
<p>1.3、每个人都有孤独的时候 </p>
<p>　　要学会忍受孤独，这样才会成熟起来。年轻人嘻嘻哈哈、打打闹闹惯了，到了一个陌生的环境，面对形形色色的人和事，一下子不知所措起来，有时连一个可以倾心说话的地方也没有。这时，千万别浮躁，学会静心，学会忍受孤独。在孤独中思考，在思考中成熟，在成熟中升华。不要因为寂寞而乱了方寸，而去做无聊无益的事情，白白浪费了宝贵的时间。  </p>
<p>1.4、走运时要做好倒霉的准备</p>
<p>　　有一天，一只狐狸走到一个葡萄园外，看见里面水灵灵的葡萄垂涎欲滴。可是外面有栅栏挡着，无法进去。于是它一狠心绝食三日，减肥之后，终于钻进葡萄园内饱餐一顿。当它心满意足地想离开葡萄园时，发觉自己吃得太饱，怎么也钻不出栅栏了。相信任何人都不愿做这样的狐狸。退路同样重要。饱带干粮，晴带雨伞，点滴积累，水到渠成。有的东西今天似乎一文不值，但有朝一日也许就会身价百倍。  </p>
<p>1.5、不要像玻璃那样脆弱</p>
<p>　　有的人眼睛总盯着自己，所以长不高看不远；总是喜欢怨天尤人，也使别人无比厌烦。没有苦中苦，哪来甜中甜？不要像玻璃那样脆弱，而应像水晶一样透明，太阳一样辉煌，腊梅一样坚强。既然睁开眼睛享受风的清凉，就不要埋怨风中细小的沙粒。  </p>
<p>1.6、管住自己的嘴巴</p>
<p>　　不要谈论自己，更不要议论别人。谈论自己往往会自大虚伪，在名不副实中失去自己。议论别人往往陷入鸡毛蒜皮的是非口舌中纠缠不清。每天下班后和你的那些同事朋友喝酒聊天可不是件好事，因为，这中间往往会把议论同事、朋友当做话题。背后议论人总是不好的，尤其是议论别人的短处，这些会降低你的人格。  </p>
<p>1.7、机会从不会“失掉”，你失掉了，自有别人会得到</p>
<p>　　不要凡事在天，守株待兔，更不要寄希望于“机会”。机会只不过是相对于充分准备而又善于创造机会的人而言的。也许，你正为失去一个机会而懊悔、埋怨的时候，机会正被你对面那个同样的“倒霉鬼”给抓住了。没有机会，就要创造机会，有了机会，就要巧妙地抓住。  </p>
<p>1.8、若电话老是不响，你该打出去</p>
<p>　　很多时候，电话会给你带来意想不到的收获，它不是花瓶，仅仅成为一种摆设。交了新朋友，别忘了老朋友，朋友多了路好走。交际的一大诀窍就是主动。好的人缘好的口碑，往往助你的事业更上一个台阶。  </p>
<p>1.9、千万不要因为自己已经到了结婚年龄而草率结婚</p>
<p>　　想结婚，就要找一个能和你心心相印、相辅相携的伴侣。不要因为放纵和游戏而恋爱，不要因为恋爱而影响工作和事业，更不要因一桩草率而失败的婚姻而使人生受阻。感情用事往往会因小失大。  </p>
<p>1.10、写出你一生要做的事情，把单子放在皮夹里，经常拿出来看</p>
<p>　　人生要有目标，要有计划，要有提醒，要有紧迫感。一个又一个小目标串起来，就成了你一生的大目标。生活富足了，环境改善了，不要忘了皮夹里那张看似薄薄的单子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;少走弯路的10条建议-转&quot;&gt;&lt;a href=&quot;#少走弯路的10条建议-转&quot; class=&quot;headerlink&quot; title=&quot;少走弯路的10条建议(转)&quot;&gt;&lt;/a&gt;少走弯路的10条建议(转)&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 经验&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;转载自
    
    </summary>
    
      <category term="经验" scheme="http://mrdear.cn/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://mrdear.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(六)</title>
    <link href="http://mrdear.cn/2017/04/16/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E5%85%AD)/"/>
    <id>http://mrdear.cn/2017/04/16/毕业设计/毕业设计周记(六)/</id>
    <published>2017-04-16T06:30:00.000Z</published>
    <updated>2017-04-16T06:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端项目重构完毕,目前已部署到个人服务器上了.</p>
<p>接下来写毕业论文,然后对OJ的功能进行测试,并且对其中的小bug进行修复.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>后端项目地址: <a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
<p>测试地址: <a href="http://oj.mrdear.cn" target="_blank" rel="external">http://oj.mrdear.cn</a></p>
<p>测试账号: 1015315668@qq.com<br>          111111</p>
<p>等待完成:</p>
<p>1.毕业论文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端项目重构完毕,目前已部署到个人服务器上了.&lt;/p&gt;
&lt;p&gt;接下来写毕业论文,然后对OJ的功能进行测试,并且对其中的小bug进行修复.&lt;/p&gt;
&lt;p&gt;前端项目地址: &lt;a href=&quot;https://github.com/nl101531/AUSTOJ-WEB&quot; targ
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>动漫推荐</title>
    <link href="http://mrdear.cn/2017/04/15/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"/>
    <id>http://mrdear.cn/2017/04/15/动漫/动漫推荐/</id>
    <published>2017-04-15T00:21:00.000Z</published>
    <updated>2017-05-29T09:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动漫推荐"><a href="#动漫推荐" class="headerlink" title="动漫推荐"></a>动漫推荐</h1><p>标签（空格分隔）： 动漫</p>
<hr>
<p>从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典动漫剧场版.我也不知道自己是什么风格的动漫迷,只是觉得好看,有共鸣就认为是好作品.人们总是把自己喜爱的东西推荐给别人,我也不例外,下面推荐我认为很不错的片子.(排名不分先后)</p>
<h3 id="异邦人-无皇刃谭"><a href="#异邦人-无皇刃谭" class="headerlink" title="异邦人 无皇刃谭"></a>异邦人 无皇刃谭</h3><p>2017年初来在上海实习时看的,故事很温情,对于刚到一个陌生城市打拼的青年来说很容易引起共鸣,也因此我感触颇深,异邦人都是孤独的存在,内心是挣扎的,想要找到自己的归属,然而哪里才是归属?背景音乐很赞,听起来内心有点温暖,但是又会觉得很伤感,充满了无奈</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=508793&auto=0&height=66"></iframe>

<h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>大概高一的时候第一次看了这个作品,唯美的画面,伤感的故事,再加上年少懵懂的恋爱经历,从此新海诚一生粉.回想以前是不是很多事情都可以 <code>One more time,One more chance</code></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=540968&auto=0&height=66"></iframe>

<h3 id="你看起来很好吃"><a href="#你看起来很好吃" class="headerlink" title="你看起来很好吃"></a>你看起来很好吃</h3><p>相当有趣的一部动漫,看起来完全没有负重感,从母爱,父爱,独立,自强等方面诠释了一个龙的成长.电影版是温情的结局,萌萌的画面,治愈的故事,给心情带来不一样的体验.<br>记住:哭闹的孩子 不管在哪里都会被霸王龙叼走</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=795251922&auto=0&height=66"></iframe>

<h3 id="萤火之森"><a href="#萤火之森" class="headerlink" title="萤火之森"></a>萤火之森</h3><p>无法触碰的爱情,只是梦中的憧憬,这样的动漫是提醒你,在你年轻的时候曾经心里也住着一个无法触碰的他/她.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=541381&auto=0&height=66"></iframe>

<h3 id="fate-stay-night"><a href="#fate-stay-night" class="headerlink" title="fate stay night"></a>fate stay night</h3><p>作为番剧来说最喜欢的一个系列,fate stay night也是最早出来的一部,配乐,战斗,剧情都那么引人入胜,虽然fate zero也非常不错,但是让我来选择的话还是该部更让我难忘.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=448119&auto=0&height=66"></iframe>

<h3 id="怪物之子"><a href="#怪物之子" class="headerlink" title="怪物之子"></a>怪物之子</h3><p>细田守家族系列电影,复杂成长的环境会造成我们内心的空洞,然而填补这些空洞的方式就是父母的爱,即使在你眼中认为一无是处,半吊子的父亲,在最关键的时候也会奋不顾身的化身为剑去填补你内心的黑暗,细细回想小时候学习父亲的一举一动或许是每个人都无法忘记的时刻.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26352841&auto=0&height=66"></iframe>

<h3 id="斩·赤红之瞳"><a href="#斩·赤红之瞳" class="headerlink" title="斩·赤红之瞳"></a>斩·赤红之瞳</h3><p>有点虐的番剧,几乎每个角色都是主角的设定,所以每个人角色的个性都很鲜明,也导致了每一个人物死去所带来的感染力.尤其看到结局,最初的一群角色就剩一个赤瞳了,其帮助革命军成立了新国家,然而其还要背负革命军为了革命所做的恶.该番剧有点杀红了眼,所以看的话就要做好心理准备.</p>
<h3 id="亚人"><a href="#亚人" class="headerlink" title="亚人"></a>亚人</h3><p>这两周把亚人的电影版和TV版都看了一遍,首先电影版绝对是圈钱的作品,还是直接看TV版本吧,剧情一样.整个看下来感觉亚人一部很理性的动漫,无论是主角的处事风格,还是亚人和搜查官的联合,都是利益组建了一个关系网,截止到第二季来说目前还是这样的理性,不知道后期有没有变化.能把不死这一老套的技能演绎出这么多惊心动魄的故事场景的估计也只有亚人了吧.另外这动漫也透漏出政府只是比较大的土匪头子而已.</p>
<h3 id="犬夜叉剧场版"><a href="#犬夜叉剧场版" class="headerlink" title="犬夜叉剧场版"></a>犬夜叉剧场版</h3><p>犬夜叉是儿时的回忆,尤其是其四个剧场版,小时候最喜欢看<code>天下霸道之剑</code>这一部,犬夜叉相比火影之类动漫的优点是其有一条爱情线,犬夜叉与阿离(我喜欢台版的这个翻译),犬夜叉与桔梗这之间复杂但却互相信任的关系.最喜欢的人物莫过于桔梗,其只是想过上普通的生活,然而命运却让其至死也无法得到想要的生活,悲情人物总能引起观看者的同情.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=463673252&auto=0&height=66"></iframe>









]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动漫推荐&quot;&gt;&lt;a href=&quot;#动漫推荐&quot; class=&quot;headerlink&quot; title=&quot;动漫推荐&quot;&gt;&lt;/a&gt;动漫推荐&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 动漫&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典
    
    </summary>
    
      <category term="动漫" scheme="http://mrdear.cn/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://mrdear.cn/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>angular2学习记录-给后端程序员的经验分享</title>
    <link href="http://mrdear.cn/2017/04/08/web/angular2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E7%BB%99%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://mrdear.cn/2017/04/08/web/angular2学习记录-给后端程序员的经验分享/</id>
    <published>2017-04-08T15:00:00.000Z</published>
    <updated>2017-04-29T08:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>前几天刚下定决心把毕业设计改造下,因为毕业设计算是我学习的基石,学习到的东西都尽可能的在这个平台上施展,锻炼自己.改造为前后端分离,前端使用angular2,后端只提供接口.便于以后的维护.那么就要学习agular2了.</p>
<p><strong>这里就要说下个人观点了,安利一波</strong>:我认为每个程序员都应该有自己的一个项目,一个可以让你学习的东西能施展到上面的项目,可能该项目一开始很简单,但是随着你不断的学习,不断的把新知识运用进去,这个项目就会伴随着你的成长而丰富起来,给你带来的则是更多的实战经验.</p>
<h3 id="2-angular2简介"><a href="#2-angular2简介" class="headerlink" title="2.angular2简介"></a>2.angular2简介</h3><ol>
<li>angular2是类似全家桶组合的框架,所需要的东西几乎都包办了,所以开发起来很迅速.</li>
<li>使用TypeScript作为开发语言,对于Java和C#程序员可以快速上手,还有就是我比较喜欢强类型语言,每个变量各司其职,由其的类型来限定,开发人员也很明确知道变量的作用.</li>
<li>google和Microsoft支持</li>
<li>WebStorm对angular2的强大支持.</li>
<li>一篇安利文章<a href="http://www.infoq.com/cn/articles/why-choose-angular2/" target="_blank" rel="external">http://www.infoq.com/cn/articles/why-choose-angular2/</a></li>
</ol>
<blockquote>
<p>一些学习资料<br>ECMAScript 6入门  <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a><br>TypeScript入门   <a href="http://www.imooc.com/learn/763" target="_blank" rel="external">http://www.imooc.com/learn/763</a><br>TypeScript中文网  <a href="https://www.tslang.cn/docs/tutorial.html" target="_blank" rel="external">https://www.tslang.cn/docs/tutorial.html</a><br>慕课网1小时快速上手视频  <a href="http://www.imooc.com/learn/789" target="_blank" rel="external">http://www.imooc.com/learn/789</a><br>官方文档  <a href="https://www.angular.cn/docs/ts/latest/cli-quickstart.html" target="_blank" rel="external">https://www.angular.cn/docs/ts/latest/cli-quickstart.html</a></p>
</blockquote>
<h3 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3.遇到的问题"></a>3.遇到的问题</h3><h4 id="3-1滚动监听"><a href="#3-1滚动监听" class="headerlink" title="3.1滚动监听"></a>3.1滚动监听</h4><p>要实现页面滚动后导航栏会变色的效果,如下图(图来自我的csdn博客,没找到其他好图床)<br><img src="http://img.blog.csdn.net/20170408234307620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwNjgxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图来自我的csdn博客"></p>
<p>之前使用Jq是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    indexApp.scrollBar = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.body.scrollTop||<span class="built_in">document</span>.documentElement.scrollTop);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>不打算依赖Jq,搜了点资料发现了下面两种写法.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这种写法在TS下不会有效果.</span></div><div class="line">  isAddBackColor()&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getIsIndex())&#123;</div><div class="line">       <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">       <span class="comment">//该处使用匿名函数,而不是箭头函数.</span></div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> marginTop = <span class="built_in">document</span>.body.scrollTop|| <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        self.isBackColor = marginTop &gt; <span class="number">20</span> &amp;&amp; self.getIsIndex();</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 判断是否需要加背景色(有效果的)</div><div class="line">   * 使用isBackColor控制结果</div><div class="line">   */</div><div class="line">  isAddBackColor()&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getIsIndex())&#123;</div><div class="line">      <span class="comment">//监听事件使用箭头函数,这样ng2才会管理该变量</span></div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,() =&gt; &#123;</div><div class="line">        <span class="keyword">let</span> marginTop = <span class="built_in">document</span>.body.scrollTop|| <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        <span class="keyword">this</span>.isBackColor = marginTop &gt; <span class="number">20</span> &amp;&amp; <span class="keyword">this</span>.getIsIndex();</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>原因不明,猜想是<code>var self = this;</code>赋值操作后相当于一个全新的变量,self并不受angular管理,导致刷新的变量是self中的isBackColor.</p>
<h4 id="3-2http参数传递"><a href="#3-2http参数传递" class="headerlink" title="3.2http参数传递"></a>3.2http参数传递</h4><p>按照下面代码传参数应该是没有问题的,但是我遇到了url被编码问题,例如输入<code>1111@qq.com</code>会被转换为<code>1111%40qq.com</code>,导致服务端解析失败,找了很多原因才发现是<code>URLSearchParams</code>这个对象用错了,angular2提供了这个对象,es6里面也有一个该对象,换成ng2中对象即可,<code>import {URLSearchParams} from &quot;@angular/http&quot;;</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> urlParams = <span class="keyword">new</span> URLSearchParams();</div><div class="line">urlParams.set(<span class="string">'search'</span>,search);</div><div class="line">urlParams.set(<span class="string">'order'</span>,order);</div><div class="line">urlParams.set(<span class="string">'pageNum'</span>,pageNum.toString());</div><div class="line">urlParams.set(<span class="string">'pageSize'</span>,pageSize.toString());</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.http.get(Config.url_problem_stage + stage,&#123;<span class="attr">params</span>:urlParams&#125;).toPromise()</div><div class="line">          .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</div><div class="line">          .catch(LogService.handleError)</div></pre></td></tr></table></figure></p>
<h4 id="3-3跨域问题"><a href="#3-3跨域问题" class="headerlink" title="3.3跨域问题"></a>3.3跨域问题</h4><p>浏览器要求同源下才可请求,否则就产生跨域问题.</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名下</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/lab/a.js" target="_blank" rel="external">http://www.a.com/lab/a.js</a> <br><a href="http://www.a.com/script/b.js" target="_blank" rel="external">http://www.a.com/script/b.js</a></td>
<td>同一域名下不同文件夹</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com:8000/a.js" target="_blank" rel="external">http://www.a.com:8000/a.js</a> <br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名，不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="https://www.a.com/b.js" target="_blank" rel="external">https://www.a.com/b.js</a></td>
<td>同一域名，不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="http://70.32.92.74/b.js" target="_blank" rel="external">http://70.32.92.74/b.js</a></td>
<td>域名和域名对应ip</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a></td>
<td>主域相同，子域不同</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td>同一域名，不同二级域名（同上）</td>
<td>不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="external">http://www.cnblogs.com/a.js</a> <br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>不同域名</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p>解决方案是用nginx反向代理到不同端口,模拟同一域名下不同文件夹情况.nginx监听本地888端口,这个也是项目入口,对于带api标识的请求转到后端服务器,对于其他请求则到前端服务器.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       8888;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line"></div><div class="line">    #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">    location /api &#123;</div><div class="line">        proxy_pass   http://127.0.0.1:8080;</div><div class="line">    &#125;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass   http://127.0.0.1:4200;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-4路由问题"><a href="#3-4路由问题" class="headerlink" title="3.4路由问题"></a>3.4路由问题</h4><p>angular2的路由匹配规则是从根路由也就是<code>forRoot()</code>的这个开始.在该处匹配寻找规则.</p>
<p><strong>根路由:</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> appRoutes: Routes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">''</span>,</div><div class="line">    <span class="attr">component</span>: IndexComponent,</div><div class="line">    <span class="attr">pathMatch</span>:<span class="string">'full'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">'aust'</span>,</div><div class="line">    <span class="attr">loadChildren</span>:<span class="string">'./content/content.module#ContentAndAsideModule'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">'index'</span>,</div><div class="line">    <span class="attr">component</span>: IndexComponent,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">'**'</span>,</div><div class="line">    <span class="attr">loadChildren</span>:<span class="string">'./content/content.module#ContentAndAsideModule'</span></div><div class="line">  &#125;,</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p><strong>子路由:</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> childRouter : Routes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">''</span>,</div><div class="line">    <span class="attr">component</span>:ContentAndAsideComponent,</div><div class="line">    <span class="attr">children</span>:[</div><div class="line">      &#123;<span class="attr">path</span>:<span class="string">''</span>,<span class="attr">redirectTo</span>:<span class="string">'/index'</span>,<span class="attr">pathMatch</span>:<span class="string">'full'</span>&#125;,</div><div class="line">      &#123;<span class="attr">path</span>:<span class="string">'start'</span>,<span class="attr">component</span>:StartComponent&#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">  ];</div></pre></td></tr></table></figure></p>
<p><strong>举例:</strong><br>访问<code>/</code>,则先在根路由寻找,找到其跳转到IndexComponent,完成任务<br>访问<code>/aust</code>.则先在根路由找,发现需要到子路由里面寻找,到子路由后,在children中发现被重定向到<code>/index</code>,那么回到根路由,找到IndexComponent完成任务.<br>访问<code>/aust/start</code>,则先在根路由找,发现需要到子路由,到子路由匹配到StartComponent,完成任务.</p>
<p><strong>路由参数</strong><br>路由传参数主要有两种方式,一种是restful风格的,一种是?号参数风格的.两种参数都保存在<code>ActivatedRoute</code>对象中,因此下面代码中的<code>route</code>为此对象<br>— restful风格<br>配置:<code>{path:&#39;article/:id&#39;,component:ArticleComponent}</code><br>链接:<code>http://domain/article/1</code><br>路由:<code>[routerLink]=&quot;[&#39;article&#39;,article.id]&quot;</code>或者直接拼接url<br>js获取:<code>this.route.params</code>中的一系列方法,或者<code>this.route.snapshot.params[&#39;id&#39;]</code><br>— 问号参数风格<br>配置:<code>{path:&#39;article&#39;,component:ArticleComponent}</code><br>链接:<code>http://domain/article?id=1</code><br>路由:<code>routerLink=&quot;article&quot; [queryParams]=&quot;{id: article.id}&quot;</code><br>js获取:<code>this.route.queryParams</code>中的一系列方法,或者<code>this.route.snapshot.queryParams[&#39;id&#39;]</code>,另外可以使用订阅模式queryParamMap.subscribe(),路由参数更新时自动通知</p>
<h4 id="3-5组件通信"><a href="#3-5组件通信" class="headerlink" title="3.5组件通信"></a>3.5组件通信</h4><p>父-&gt;子:子组件使用input装饰器,接受父组件的属性,并且可使用ngOnChanges或则setter监听变化,做额外处理.<br>子-&gt;父:使用output装饰器加EventEmitter向上弹出事件到父组件,父组件监听后处理.<br>任意组件:使用service通讯(要求service单例),service提供Observable的next发布,其他组件引用service对象subscribe该发布,那么就实现了信息的流动,并且是在只要订阅了该发布的组件中都能获取.</p>
<h4 id="3-6单例"><a href="#3-6单例" class="headerlink" title="3.6单例?"></a>3.6单例?</h4><p>agular2的service是providers提供的,该组件如果引用了这个service,那么会先在自己的providers中寻找service,找不到则再向上找父组件,直到module.那么意味着每一个providers提供的是一个实例,旗下的组件都是享用这一个实例,那么怎么实现全局单例呢?很简单在根module中提供服务且其他组件不要自己providers该服务.</p>
<h4 id="3-7组件生命周期"><a href="#3-7组件生命周期" class="headerlink" title="3.7组件生命周期"></a>3.7组件生命周期</h4><p>组件生命周期看下面这张图.图中没有<code>onChanges(changes: SimpleChanges)</code>方法的调用,该方法检测到组件的<strong>输入属性</strong>发生变化时调用,也就是存在<strong>@inpu</strong>t装饰的属性,该属性每次变化时会调该方法.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/kRRpNMw13FEBLykaLlty4NQsVYFpeEl2OCBifcB2.jpg" alt=""></p>
<h4 id="3-8部署问题"><a href="#3-8部署问题" class="headerlink" title="3.8部署问题"></a>3.8部署问题</h4><p>单页应用部署到服务器上可能会出现访问<code>www.domain.xx</code>可以访问,并且点击什么的都能成功,但是直接访问其中一个路由<code>www.domain.xx/aust/start</code>却报404.<br>先分析下问题的原因,我们的单页应用只有一个入口,报404也就是没找到这个入口.看nginx的配置.nginx收到请求后会去root下寻找<code>aust/start</code>下的index.html那么自然找不到,所以直接访问就会404.<br>那么问题来了为什么访问<code>www.domain.xx</code>之后页面内跳转到路由没问题呢?这是因为访问主域名后angular的js都已经全部加载了,这个时候跳转是js来控制的,不经过nginx自然不会出现上面的问题.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root /Users/niuli/workspace/web/austoj/dist;</div><div class="line">    index  index.html index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解决方法:</strong><br>解决方法就是让其对于路由都去加载index.html这个文件.使用try_files指令,该指令会把uri当成一个文件,去根目录下寻找,找不到的话则内部重定向到配置的<code>/index.html</code>.这样配置的好处,对于静态资源try_files会直接找到后就返回,对于路由则会定向到<code>/index.html</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri /index.html;</div><div class="line">    root /Users/niuli/workspace/web/austoj/dist;</div><div class="line">    index  index.html index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-9文件上传"><a href="#3-9文件上传" class="headerlink" title="3.9文件上传"></a>3.9文件上传</h4><p>文件上传是通过ajax操作上传,使用FormData形式,主要有以下问题要解决.</p>
<ol>
<li>怎么获得input框所选中的文件(为input绑定change事件,然后获取$event,文件就是event.srcElement.files[0])</li>
<li>怎么上传到服务器?(使用formData对象,调用其append方法添加文件,再使用angular2的http组件post上去)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">uploadAvatar(file: any): <span class="built_in">Promise</span>&lt;any&gt;&#123;</div><div class="line">    <span class="keyword">let</span> formData:FormData = <span class="keyword">new</span> FormData();</div><div class="line">    formData.append(<span class="string">'avatar'</span>,file);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.post(Config.url_upload_img,formData).toPromise()</div><div class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</div><div class="line">      .catch(LogService.handleError);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>angular2项目:<br><a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;前几天刚下定决心把毕业设计改造下,因为毕业设计算是我学习的基石,学习到的东西都尽可能的在这个平台上施展,锻炼自己.改造为前后
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(五)</title>
    <link href="http://mrdear.cn/2017/04/08/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%BA%94)/"/>
    <id>http://mrdear.cn/2017/04/08/毕业设计/毕业设计周记(五)/</id>
    <published>2017-04-08T14:50:00.000Z</published>
    <updated>2017-04-08T14:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周一直在重构前端,目前登录注册+侧边栏都已经完成,在此过程熟悉了angular2的开发模式,不得不佩服这些前端大神们,搞出来ng2这种类似后端写法的框架,下周进度会更加快,希望下周重构完成.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>等待完成:</p>
<p>1.前端页面的重构</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周一直在重构前端,目前登录注册+侧边栏都已经完成,在此过程熟悉了angular2的开发模式,不得不佩服这些前端大神们,搞出来ng2这种类似后端写法的框架,下周进度会更加快,希望下周重构完成.&lt;/p&gt;
&lt;p&gt;前端项目地址: &lt;a href=&quot;https://github.c
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(四)</title>
    <link href="http://mrdear.cn/2017/04/03/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://mrdear.cn/2017/04/03/毕业设计/毕业设计周记(四)/</id>
    <published>2017-04-03T13:50:00.000Z</published>
    <updated>2017-04-03T23:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周注册流程等都写完了,开始重构前端页面,最终选择使用angular2来重构,其类似后端的写法以及typescript语法对js的修正使得其很容易上手.这周任务主要是在重构中熟悉angular的写法.到五月份的话不知道能不能重构完,尽力而为了.</p>
<p>测试地址:  <a href="http://oj.mrdear.cn/" target="_blank" rel="external">http://oj.mrdear.cn/</a>    服务器比价渣,速度比较慢</p>
<p>测试账号:   1015315668@qq.com    密码: 111111</p>
<p>等待完成:</p>
<p>1.前端页面的重构</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周注册流程等都写完了,开始重构前端页面,最终选择使用angular2来重构,其类似后端的写法以及typescript语法对js的修正使得其很容易上手.这周任务主要是在重构中熟悉angular的写法.到五月份的话不知道能不能重构完,尽力而为了.&lt;/p&gt;
&lt;p&gt;测试地址:  
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>redis学习记录(四)-SpringDataRedis分析</title>
    <link href="http://mrdear.cn/2017/03/29/linux/redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E5%9B%9B)-SpringDataRedis%E5%88%86%E6%9E%90/"/>
    <id>http://mrdear.cn/2017/03/29/linux/redis学习记录(四)-SpringDataRedis分析/</id>
    <published>2017-03-29T10:50:00.000Z</published>
    <updated>2017-03-30T01:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习记录-四-SpringDataRedis分析"><a href="#redis学习记录-四-SpringDataRedis分析" class="headerlink" title="redis学习记录(四)-SpringDataRedis分析"></a>redis学习记录(四)-SpringDataRedis分析</h1><p>标签（空格分隔）： redis</p>
<hr>
<p><a href="http://www.jianshu.com/p/da69edda2a43" target="_blank" rel="external">Redis学习记录(一)–入门知识</a><br><a href="http://www.jianshu.com/p/c3b8180af944p/da69edda2a43" target="_blank" rel="external">Redis学习记录(二)–使用Jedis连接</a><br><a href="http://mrdear.cn/2017/03/26/linux/redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%28%E4%B8%89%29-redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis学习记录(三)-redis中的数据结构</a></p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring Data Redis是对redis客户端(如jedis)的高度封装,支持多种客户端,因其高抽象,所以在某一个客户端不支持更新的时候可以容易切换到其他客户端.</p>
<p>本文是在Spring boot 1.5.2版本下测试.</p>
<p>需要引入架包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--spring boot start--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>在Spring Boot下默认使用jedis作为客户端,并在包<code>org.springframework.boot.autoconfigure.data.redis</code>下,提供自动配置类<code>RedisProperties</code>,<code>RedisAutoConfiguration</code>等.</p>
<p>根据<code>RedisProperties</code>可以定位到可配置的属性,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># Redis数据库索引（默认为0）</div><div class="line">spring.redis.database=0</div><div class="line"># Redis服务器地址</div><div class="line">spring.redis.host=115.159.185.14</div><div class="line"># Redis服务器连接端口</div><div class="line">spring.redis.port=6379</div><div class="line"># Redis服务器连接密码（默认为空）</div><div class="line">spring.redis.password=</div><div class="line"># 连接池最大连接数（使用负值表示没有限制）</div><div class="line">spring.redis.pool.max-active=8</div><div class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</div><div class="line">spring.redis.pool.max-wait=-1</div><div class="line"># 连接池中的最大空闲连接</div><div class="line">spring.redis.pool.max-idle=8</div><div class="line"># 连接池中的最小空闲连接</div><div class="line">spring.redis.pool.min-idle=0</div><div class="line"># 连接超时时间（毫秒）</div><div class="line">spring.redis.timeout=2000</div></pre></td></tr></table></figure></p>
<p>在application.properties中配置即可,另外还有<code>Sentinel</code>和<code>Cluster</code>说明支持分布式和集群,博主研究不多就不瞎说这个了.</p>
<p>自动配置主要在<code>RedisAutoConfiguration</code>中,该类会提供三个bean:</p>
<ol>
<li>JedisConnectionFactory : jedis连接控制工厂</li>
<li>RedisTemplate<object, object=""> : redis操作入口</object,></li>
<li>StringRedisTemplate : redis操作入口</li>
</ol>
<p>那么就开始入口学习.</p>
<hr>
<h3 id="3-RedisTemplate"><a href="#3-RedisTemplate" class="headerlink" title="3.RedisTemplate"></a>3.RedisTemplate<k, v=""></k,></h3><p>RedisTemplate是操作的入口.该类继承了<code>RedisAccessor</code>,可以通过其拿到redis连接,实现了<code>RedisOperations</code>接口,获得了操作redis的能力,如下图所示:<br><img src="http://ac-HSNl7zbI.clouddn.com/rUB5pG7qryosXsqkMNQ1u52FgHMVMwAX7OeVM3jy.jpg" alt=""></p>
<h4 id="3-1-Test-case"><a href="#3-1-Test-case" class="headerlink" title="3.1 Test case"></a>3.1 Test case</h4><p>那么具体操作过程是怎么样子的呢?写一个简单的测试去跟踪代码,如下代码,往redis中设置key为ping的字串.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span>(classes = Application.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConnectTest</span> </span>&#123;</div><div class="line">  <span class="meta">@Resource</span></div><div class="line">  <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSetAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">    redisTemplate.opsForValue().set(<span class="string">"ping"</span>,<span class="string">"pong"</span>);</div><div class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">"ping"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行之后查看redis数据库,你会发现很奇怪的事情,如下图,代码中存入的是ping,但是到redis中后却是一堆字符+ping,这个原因是什么呢?接着跟踪代码.<br><img src="http://ac-HSNl7zbI.clouddn.com/9O9oRCxhlph8oRYL6YirrY192jaYIOHAlGXAUemJ.jpg" alt=""></p>
<h4 id="3-2-XXXOperations"><a href="#3-2-XXXOperations" class="headerlink" title="3.2 XXXOperations"></a>3.2 XXXOperations<k, v=""></k,></h4><p>上述代码的第一步先获取到了<code>ValueOperations</code>,在<code>RedisTemplate</code>中同样还有其他<code>XXXOperations</code>,根据官方文档,这些接口是针对redis的每一种命令的操作.如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">接口</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ValueOperations</td>
<td style="text-align:left">Redis string (or value) operations</td>
</tr>
<tr>
<td style="text-align:left">ListOperations</td>
<td style="text-align:left">Redis list operations</td>
</tr>
<tr>
<td style="text-align:left">SetOperations</td>
<td style="text-align:left">Redis set operations</td>
</tr>
<tr>
<td style="text-align:left">ZSetOperations</td>
<td style="text-align:left">Redis zset (or sorted set) operations</td>
</tr>
<tr>
<td style="text-align:left">HashOperations</td>
<td style="text-align:left">Redis hash operations</td>
</tr>
<tr>
<td style="text-align:left">HyperLogLogOperations</td>
<td style="text-align:left">Redis HyperLogLog operations like (pfadd, pfcount,…​)</td>
</tr>
<tr>
<td style="text-align:left">GeoOperations</td>
<td style="text-align:left">Redis geospatial operations like GEOADD, GEORADIUS,…​)</td>
</tr>
<tr>
<td style="text-align:left">BoundValueOperations</td>
<td style="text-align:left">Redis string (or value) key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundListOperations</td>
<td style="text-align:left">Redis list key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundSetOperations</td>
<td style="text-align:left">Redis set key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundZSetOperations</td>
<td style="text-align:left">Redis zset (or sorted set) key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundHashOperations</td>
<td style="text-align:left">Redis hash key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundGeoOperations</td>
<td style="text-align:left">Redis key bound geospatial operations.</td>
</tr>
</tbody>
</table>
<p>其中<code>BoundXXXOperations</code>是在key已知的情况下使用,其所有操作都是建立在有一个<code>certain key</code>的前提.可以看下源码就能明白了.</p>
<h4 id="3-3-XXXSerializer"><a href="#3-3-XXXSerializer" class="headerlink" title="3.3 XXXSerializer"></a>3.3 XXXSerializer</h4><p>那测试代码中第一步是获取了string类型的redis操作入口,然后执行set方法设置键和值,接着分析set方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = rawValue(value);</div><div class="line">	execute(<span class="keyword">new</span> ValueDeserializingRedisCallback(key) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</div><div class="line">			connection.set(rawKey, rawValue);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现<code>rawKey()</code>方法和<code>rawValue()</code>方法对key和value进行了一次序列化操作.该序列化使用的类为RedisTemplate中的<code>XXXSerializer</code>,那么回到RedisTemplate,在<code>afterPropertiesSet()</code>方法中有以下初始化方法,默认使用的序列化方式为<code>JdkSerializationRedisSerializer</code>,也就是ObjectInputStream和ObjectOutputStream写入和读取.这也是写入到redis中却在redis数据库通过”ping”访问不到的原因.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">			defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</div><div class="line">					classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (enableDefaultSerializer) &#123;</div><div class="line">			<span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				keySerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				valueSerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				hashKeySerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				hashValueSerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>那么SpringDataRedis支持哪些序列化呢?从官网可以看到:<br>StringRedisSerializer: string类型序列化,也是最常用的类型<br>JdkSerializationRedisSerializer: jdk默认序列化<br>OxmSerializer : xml格式<br>JacksonJsonRedisSerializer : json格式</p>
<p>通过手动注入RedisTemplate,更改所选择的序列化方式.另外Spring提供了最常使用的<code>StringRedisTemplate</code>,实现了<code>StringRedisSerializer</code>序列化方式.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">	RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">	setKeySerializer(stringSerializer);</div><div class="line">	setValueSerializer(stringSerializer);</div><div class="line">	setHashKeySerializer(stringSerializer);</div><div class="line">	setHashValueSerializer(stringSerializer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更改成<code>StringRedisTemplate</code>,再次执行,正常了.<br><img src="http://ac-HSNl7zbI.clouddn.com/3PAtzJjJHXquNpAVgWJI0OVh8pJWDhVEl3FbD571.jpg" alt=""></p>
<h4 id="3-4-总结过程"><a href="#3-4-总结过程" class="headerlink" title="3.4 总结过程"></a>3.4 总结过程</h4><ol>
<li>获取RedisTemplate</li>
<li>获取操作入口XXXOperations</li>
<li>使用RedisSerializer序列化key和value</li>
<li>获取conn连接</li>
<li>执行命令</li>
</ol>
<h3 id="4-发布与订阅"><a href="#4-发布与订阅" class="headerlink" title="4.发布与订阅"></a>4.发布与订阅</h3><p>发布与订阅过程需要发布者,订阅者,以及把两者连在一起的桥梁.那么在SpringRedis中怎么实现呢?<br>订阅者:里面有一个处理方法即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listen</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Listen.class);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMsg</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">    logger.info(<span class="string">"reciver msg :"</span> + message);</div><div class="line">    latch.countDown();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getLatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> latch;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发布者:XXXRedisTemplate.convertAndSend(chanel,msg)即作为发布者存在.</p>
<p>连接桥梁:RedisMessageListenerContainer,该container监听Redis的消息,分发给各自的监听者.关键代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注入消息容器</div><div class="line">   * <span class="doctag">@param</span> jedisConnectionFactory jedis连接池</div><div class="line">   * <span class="doctag">@param</span> listenerAdapter 监听适配器</div><div class="line">   * <span class="doctag">@return</span> bean</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory jedisConnectionFactory,</span></span></div><div class="line">      MessageListenerAdapter listenerAdapter)&#123;</div><div class="line">    RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</div><div class="line">    container.setConnectionFactory(jedisConnectionFactory);</div><div class="line">    <span class="comment">//绑定监听者与信道的管理</span></div><div class="line">    container.addMessageListener(listenerAdapter,<span class="keyword">new</span> PatternTopic(<span class="string">"java"</span>));</div><div class="line">    <span class="keyword">return</span> container;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MessageListenerAdapter <span class="title">adapter</span><span class="params">(Listen listen)</span></span>&#123;</div><div class="line">    <span class="comment">//指定监听者和监听方法</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(listen,<span class="string">"handleMsg"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPublish</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  stringRedisTemplate.convertAndSend(<span class="string">"java"</span>,<span class="string">"hello world"</span>);</div><div class="line">  listen.getLatch().await();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/yhidqhoWBD7Un7XLH6WQYjIEl82Ve0R2jzCEzMrn.jpg" alt=""></p>
<h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h3><p>对于事务的操作是通过SessionCallback实现,该接口保证其内部所有操作都是在同一个Session中的,在最后exec的时候执行全部操作.关键代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</div><div class="line">execute(<span class="keyword">this</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMulti</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> isThrow = <span class="keyword">false</span>;</div><div class="line">   List&lt;Object&gt; result = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     result = stringRedisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;List&lt;Object&gt;&gt;() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span></span></div><div class="line">           DataAccessException &#123;</div><div class="line">         operations.multi();</div><div class="line">         ValueOperations&lt;String,String&gt; ops = operations.opsForValue();</div><div class="line">         ops.set(<span class="string">"ping1"</span>,<span class="string">"pong1"</span>);</div><div class="line">         ops.set(<span class="string">"ping2"</span>,<span class="string">"pong2"</span>);</div><div class="line">         <span class="keyword">if</span> (isThrow)&#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"测试异常"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> operations.exec();</div><div class="line">       &#125;</div><div class="line">     &#125;);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">     e.printStackTrace();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   System.out.println(result);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="6-管道"><a href="#6-管道" class="headerlink" title="6.管道"></a>6.管道</h3><p>直接引用官方案例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pop a specified number of items from a queue</span></div><div class="line">List&lt;Object&gt; results = stringRedisTemplate.executePipelined(</div><div class="line">  <span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">      StringRedisConnection stringRedisConn = (StringRedisConnection)connection;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; batchSize; i++) &#123;</div><div class="line">        stringRedisConn.rPop(<span class="string">"myqueue"</span>);</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>还有脚本执行等,在官方文档中都有案例,这里就不复制粘贴了,如有错误请指出,不胜感激.</p>
<p>参考文档:</p>
<p><a href="http://docs.spring.io/spring-data/redis/docs/1.8.1.RELEASE/reference/html/#redis:template" target="_blank" rel="external">http://docs.spring.io/spring-data/redis/docs/1.8.1.RELEASE/reference/html/#redis:template</a></p>
<p>github:</p>
<p><a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis学习记录-四-SpringDataRedis分析&quot;&gt;&lt;a href=&quot;#redis学习记录-四-SpringDataRedis分析&quot; class=&quot;headerlink&quot; title=&quot;redis学习记录(四)-SpringDataRedis分析&quot;&gt;&lt;/
    
    </summary>
    
      <category term="redis" scheme="http://mrdear.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://mrdear.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习记录(三)-redis中的数据结构</title>
    <link href="http://mrdear.cn/2017/03/26/linux/redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://mrdear.cn/2017/03/26/linux/redis学习记录(三)-redis中的数据结构/</id>
    <published>2017-03-26T13:50:00.000Z</published>
    <updated>2017-03-27T14:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习记录-三-redis中的数据结构"><a href="#redis学习记录-三-redis中的数据结构" class="headerlink" title="redis学习记录(三)-redis中的数据结构"></a>redis学习记录(三)-redis中的数据结构</h1><p>标签（空格分隔）： redis</p>
<hr>
<p><a href="http://www.jianshu.com/p/da69edda2a43" target="_blank" rel="external">Redis学习记录(一)–入门知识</a>o<br><a href="http://www.jianshu.com/p/c3b8180af944p/da69edda2a43" target="_blank" rel="external">Redis学习记录(二)–使用Jedis连接</a></p>
<p>redis有五种数据类型,string,list,set,hash,sort set,不同场景使用不同数据结构的前提是了解每一种数据结构.那么结构图片是最佳的了解方式,图片来自慕课网.</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是的key-&gt;value类型的存储,可以存储字符串类型和数值类型,可对数值类型是可以增加减少,对string类型可以追加内容.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/FLiCD6qvq5cgURt9pK4GsmHAfikXMkTaTk0jH42D.jpg" alt=""></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是列表,也就是一个key-&gt;多个value,可以支持双端队列,栈来操作,因此越靠近两端其查找速度越快,端点的复杂度查找为O(1),同时队列有阻塞操作,也就是可以当成阻塞队列使用.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/C66VGUQUQU36HG1VirdktiwGCsuch427TKeM9Mx8.jpg" alt=""></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set为无序,且不重复的集合,且提供O(1)复杂度度的快速查找.set集合支持集合的并,交,差操作,因为无序性,因此也提供迭代方法.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/eYnj2QzNgnS3IxzfR74ODXYREXCAwLrFAqmNCvDD.jpg" alt=""></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash类型适合存储对象,相比前面的string,所带来的优势是可以使用一个key查出该下面所有的键值对,并且可以单独对某一属性更改,如图所示:</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/9EqPsIkU1iQeoMzRBYGGIEIPYvpQarWbgyADBehR.jpg" alt=""></p>
<h3 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h3><p>可排序的集合,如图所示存在score排名分数,隐藏属性rank排名,0为最小.注意对sort set来说value是唯一性的,而不是score,如果两个score相同,则按照value的字典序排序.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/3TBmsR4b8tGDoUvX3tlo1pHMuTTDnJOXAT5H0S9g.jpg" alt=""></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h4><p>计数器:redis的incr操作是原子性的,因此可以应对高并发,如网站要求每个用户获取验证码后60秒内不得再次获取,那么第一次获取的时候用incr给该用户设置key,过期时间为60秒,如果结果等于1则为第一次请求,那么第二次获取时比较决定是否操作频繁.</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>list的优势的有序性,两端插入复杂度为O(1),那么对于<strong>最近文章列表</strong>等类似需求是最佳解决方案,维护一个定长的列表,每次插入后执行trim操作.</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>set的优势是唯一性,O(1)的查找查找复杂度,并且支持差并集,那么二度好友问题就迎刃而解了.</p>
<h4 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h4><p>hash非常适合存储对象,不同的键为对象的特征,值为特征值,那么比string好的就是修改不需要每次都修改一个整串,而可以选择修改某一指定键值.</p>
<h4 id="sort-set-1"><a href="#sort-set-1" class="headerlink" title="sort set"></a>sort set</h4><p>sort set可排序特性使其很容易解决排行榜类应用,但是要注意值需要存储不变的属性,因为值要求唯一性,score可不唯一.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis学习记录-三-redis中的数据结构&quot;&gt;&lt;a href=&quot;#redis学习记录-三-redis中的数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis学习记录(三)-redis中的数据结构&quot;&gt;&lt;/a&gt;redis学习记录(三)-red
    
    </summary>
    
      <category term="redis" scheme="http://mrdear.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://mrdear.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(三)</title>
    <link href="http://mrdear.cn/2017/03/25/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://mrdear.cn/2017/03/25/毕业设计/毕业设计周记(三)/</id>
    <published>2017-03-25T13:50:00.000Z</published>
    <updated>2017-03-26T13:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>3.26更新</strong><br>周末把竞赛支持也写好了,但是总觉得和自己想要的不太一样了,前端太乏力,因此下周开始重构前端,采用VUE写成一个单页逻辑应用.希望不会耽误太多时间.</p>
<hr>
<p>花了一下午的时间把服务器重装了,所有实例包括mysql,redis,nginx都跑在docker中,项目也是跑在docker中,目前来看效果很不错,对服务器的利用率比之前高太多了.</p>
<p>部署的OJ漏洞挺多的,体验上也没怎么优化,尤其是注册流程,问题多多,接下来要优化代码,优化这个流程.</p>
<p>竞赛方面的支持,因为上周公司出了几个大活动,一直比较忙,而没去做,本周也继续做竞赛方面支持.</p>
<p>因此目前进度:</p>
<ol>
<li>服务器部署全部docker化</li>
<li>线上可以直接判题</li>
</ol>
<p>测试地址:  <a href="http://oj.mrdear.cn/" target="_blank" rel="external">http://oj.mrdear.cn/</a>    服务器比价渣,速度比较慢</p>
<p>测试账号:   1015315668@qq.com    密码: 111111</p>
<p>等待完成:</p>
<p>1.竞赛的支持<br>2.注册流程优化</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;3.26更新&lt;/strong&gt;&lt;br&gt;周末把竞赛支持也写好了,但是总觉得和自己想要的不太一样了,前端太乏力,因此下周开始重构前端,采用VUE写成一个单页逻辑应用.希望不会耽误太多时间.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;花了一下午的时间把服务器重装了,所有实例包括my
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ERP叛逃者(转)</title>
    <link href="http://mrdear.cn/2017/03/19/%E9%9A%8F%E8%B0%88/ERP%E5%8F%9B%E9%80%83%E8%80%85/"/>
    <id>http://mrdear.cn/2017/03/19/随谈/ERP叛逃者/</id>
    <published>2017-03-19T10:21:00.000Z</published>
    <updated>2017-04-21T01:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ERP叛逃者-转"><a href="#ERP叛逃者-转" class="headerlink" title="ERP叛逃者(转)"></a>ERP叛逃者(转)</h1><p>标签（空格分隔）： 随谈</p>
<hr>
<blockquote>
<p>作者:alswl<br>原文链接:<a href="https://blog.alswl.com/2011/04/erp-defectors/" target="_blank" rel="external">https://blog.alswl.com/2011/04/erp-defectors/</a></p>
</blockquote>
<p>一篇对于毕业生很有指导意义的文章,踏入职场,面临的第一个选择就是工作,第一份工作可能并不如你所期望的那样,那么你真正想要什么呢?文章会给你答案.</p>
<hr>
<p>大四实习时候，跑去驻厂开发，当时主管跟我说”我们做的是企业信息化软件”。毕业之后找工作，进入一家国内还算有名的ERP公司，做ERPII产品（CRM/工作流/ 电子商务平台等ERP软件附属产品）的开发和二次开发。</p>
<p>在这一年半的时间里，我学习了一些行业知识，熟悉了公司自己的开发模式、框架和工具。浑浑噩噩的直到某一天，我发现我写代码没有键盘飞扬的感觉。我惶恐，我感觉我遇到 瓶颈停止成长了。我开始思索我这种状况的产生，我重新翻开曾经看的糊里糊涂的《人月神话》，研读阿朱的《走出软件作坊》，尝试找到问题和解决办法。</p>
<p>我回想我工作之后做的事情：我负责的是从顾问那里拿到伪SQL+伪代码，然后将它们在公司的框架上面实现起来，再手工完成功能性测试。我做一个极端的假设：如果早50 年，ERP公司给用户提供解决方案可以是在纸上提出，根本不需要电脑。所以ERP的本质是对业务的梳理，规范化的引导，让企业高效整合资源充分发挥产能的公司。这与我 想象的IT公司完全不一样，我所希望的IT公司能够追求极致，创造用户喜欢的，快速响应用户需求，扩展性强的产品。如果具备这些元素，会很快被同类公司超越。</p>
<p>可是公司立足于市场近30年，绝对不是这么不堪，她有自己的核心竞争力：标准的业务流程，强大的顾问和实施团队，本土化的产品。</p>
<p>我比较了知名互联网公司、创业型IT公司和传统管理软件行业的区别，惊讶的发现，原来，计算机科学与技术专业毕业的我，不在IT公司，在一家服务咨询公司！！！我把这 个想法和主管进行交流，主管也认同我们提供的是service而不是soft。</p>
<p>我简单比较了互联网企业和传统行业软件企业的差异。</p>
<h3 id="目标人群不一样"><a href="#目标人群不一样" class="headerlink" title="目标人群不一样"></a>目标人群不一样</h3><p>行业软件：企业用户</p>
<p>互联网产品：个人用户更多，也有企业用户</p>
<p>由于给企业用户进行定制，导致内部封闭现象严重，更新周期漫长。另外，企业用户可以强制要求用户使用某种操作方式或者某种环境，比如我就是要让你用IE6，你不用IE 6系统出现问题，那是你的原因。而互联网产品就面对所有网民，必须考虑到标准问题。</p>
<p>另外，企业用户更换系统平台频率低，系统一旦投入使用，需要经过几年的使用，才会可能考虑更换，其依赖性比互联网产品高出个数量级。由于互联网的开放性，互联网用户很 容易在不同产品之间进行更换。</p>
<h3 id="盈利点不一样"><a href="#盈利点不一样" class="headerlink" title="盈利点不一样"></a>盈利点不一样</h3><p>互联网：吸引用户使用，所以用户体验，速度是需要考虑的，依赖用户使用情况（VIP制度、广告收入）盈利。</p>
<p>行业软件：卖给产品和服务给用户，功能符合用户需要，顾问实施精准，依赖销售产品+服务盈利。</p>
<p>盈利点造成行业软件未必会把用户体验、速度这些相对次要的问题放在首位考虑，而是考虑先解决实际问题，满足用户需要。</p>
<h3 id="核心竞争力"><a href="#核心竞争力" class="headerlink" title="核心竞争力"></a>核心竞争力</h3><p>行业软件最依赖的核心竞争力是对某个行业的了解，比如阿朱所在的明源专注于房地产，金蝶用友各有所擅长的行业。并不是他们不想在别的行业挣钱，而是对应行业的顾问极难 培养（行业/领域专家）。</p>
<p>互联网产品的核心竞争力就更多样化，Web2.0时代可以是用户关系，用户基数（腾讯，现在的人人），也可以是某一款特别大众需要的产品（淘宝，搜索引擎，书签服务） ，又或是核心技术（Google），这些核心竞争力会在发展过程中相互转换，相互渗透。</p>
<p>互联网产品的特性是快，这个快是表象，本质是在于互联网产品要充分挖掘用户需求，不断满足现有要求，并预测引领用户需求趋势，这也是创新精神具体体现。由于同质化严重 ，竞争白热化，导致互联网产品纷纷涌现，给人一种爆炸的感觉。其实，一款好的互联网产品从有创意到磨砺成熟，是需要经过一段还算长的时间的。（除非是搞搞微创新，大家 都知道怎么做，没什么核心竞争力，只是拼模拟速度了）</p>
<p>我在想清楚这些之后，发现ERP不是我的归宿，互联网才是我追寻的方向。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ERP叛逃者-转&quot;&gt;&lt;a href=&quot;#ERP叛逃者-转&quot; class=&quot;headerlink&quot; title=&quot;ERP叛逃者(转)&quot;&gt;&lt;/a&gt;ERP叛逃者(转)&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 随谈&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;作者:als
    
    </summary>
    
      <category term="经验" scheme="http://mrdear.cn/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="选择" scheme="http://mrdear.cn/tags/%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(二)</title>
    <link href="http://mrdear.cn/2017/03/18/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://mrdear.cn/2017/03/18/毕业设计/毕业设计周记(二)/</id>
    <published>2017-03-18T14:50:00.000Z</published>
    <updated>2017-03-18T14:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周学习docker之后,建立起docker的判题环境,目前已成功判题,前端部分也打通.目前支持语言C,C++,Java,后续会添加更多语言支持.接下来的任务是整理代码,重构部分逻辑代码,还有竞赛判题的支持.预计下周完成.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/M4V64IgxeMaWtWlUVumAWBvLrUh9VBT1rfWnLuKF.jpg" alt=""></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/Yd4SAenh4N3THhsau4GxNdxKE4XnpiTRqfsvhpkk.jpg" alt=""></p>
<p>因此目前进度:</p>
<ol>
<li>WEB端和Judge端打通,近期部署到自己的服务器上,以便展示.</li>
</ol>
<p>等待完成:</p>
<p>1.竞赛的支持<br>2.代码重构,一些体验上的逻辑优化</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周学习docker之后,建立起docker的判题环境,目前已成功判题,前端部分也打通.目前支持语言C,C++,Java,后续会添加更多语言支持.接下来的任务是整理代码,重构部分逻辑代码,还有竞赛判题的支持.预计下周完成.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://a
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习记录(三)-构建非跨平台项目编译环境</title>
    <link href="http://mrdear.cn/2017/03/12/docker/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-%E6%9E%84%E5%BB%BA%E9%9D%9E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://mrdear.cn/2017/03/12/docker/Docker学习记录(三)-构建非跨平台项目编译环境/</id>
    <published>2017-03-12T07:21:00.000Z</published>
    <updated>2017-04-02T02:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录-三-构建非跨平台项目编译环境"><a href="#Docker学习记录-三-构建非跨平台项目编译环境" class="headerlink" title="Docker学习记录(三)-构建非跨平台项目编译环境"></a>Docker学习记录(三)-构建非跨平台项目编译环境</h1><p>标签（空格分隔）： docker</p>
<hr>
<blockquote>
<p>个人独立博客: <a href="http://mrdear.cn">http://mrdear.cn</a></p>
</blockquote>
<p>因为毕业设计的问题所以去学了docker,本文描述这个问题解决的过程.</p>
<hr>
<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>在毕业设计AUSTOJ中,判题端使用JNI方式调用C++来编译和执行代码,得到输出结果,Java端进行结果对比.然而该C++代码在mac下无法编译,总是会报错,JNI也会出问题.另外该子模块在mac下无法使用maven打包,所以打包也需要放在docker中.<br>因此docker需要环境 java maven gcc g++ make</p>
<h2 id="2-构建编译环境"><a href="#2-构建编译环境" class="headerlink" title="2.构建编译环境"></a>2.构建编译环境</h2><p>编写dockerfile文件,该文件的maven包我是从本机复制进去的,同样你也可以从外网下载.<br>Dockerfile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#构建judger端需要的环境,方便本地测试</div><div class="line">#基于java8环境</div><div class="line">FROM java:8</div><div class="line"></div><div class="line">#维护人信息</div><div class="line">MAINTAINER quding niudear@foxmail.com</div><div class="line">#更新源</div><div class="line">RUN apt-get update</div><div class="line">#gcc g++ make安装</div><div class="line">RUN apt-get install -y gcc-4.9</div><div class="line">RUN apt-get install -y g++-4.9</div><div class="line">RUN apt-get install -y build-essential</div><div class="line"></div><div class="line">#配置mvn环境</div><div class="line">ADD apache-maven-3.3.9.tar.gz /usr/local</div><div class="line">ENV M2_HOME /usr/local/apache-maven-3.3.9</div><div class="line">ENV PATH $PATH:$JAVA_HOME/bin:$M2_HOME/bin</div><div class="line"></div><div class="line">#jni环境</div><div class="line">RUN cp $JAVA_HOME/include/linux/jawt_md.h $JAVA_HOME/include/</div><div class="line">RUN cp $JAVA_HOME/include/linux/jni_md.h $JAVA_HOME/include/</div></pre></td></tr></table></figure></p>
<p>构建命令:<br><code>docker build -t dev .</code></p>
<h2 id="3-挂载运行"><a href="#3-挂载运行" class="headerlink" title="3.挂载运行"></a>3.挂载运行</h2><p>运行时需要挂载本项目到docker中,该挂载是映射,因此本地和docker任意位置改变项目中文件都会反映在真实项目中,这也是想要的结果.<br>挂载命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -ti -p 50013:50013  -v /Users/niuli/workspace/git/AUSTOJ2/:/AUSTOJ2 </div><div class="line">-v /Users/niuli/workspace/git/testcase/:/austoj/testcase dev</div></pre></td></tr></table></figure></p>
<p>该命令以交互模式启动一个docker容器,同时绑定docker的50013端口到此容器的50013,因为我的项目使用的是50013端口.另外我挂载了本项目目录AUSTOJ2和测试数据目录分别到docker的/AUSTOJ2目录和/austoj/testcase目录.</p>
<p>那么启动之后如下所示:<br><img src="http://ac-HSNl7zbI.clouddn.com/sVRm9T6RaAgcL0tqAX7vGz0kaTVDT21kJbSSokIA.jpg" alt=""></p>
<p>ok,到此编译环境搞定,可以随心所欲的编译启动该子模块,并且还能实时反映到本机目录下</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/y020GeCL2UrSuASyDaYbvWs0XF3LWRYqRbej5pAB.jpg" alt=""></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/bOKHInF9SpgHTSmr361EhU2geUFRjKW1yPwHap6s.jpg" alt=""></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/JXVXNAq7Q6JtPc9QhKzJAdu1h3HskLriYhruA1tY.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker学习记录-三-构建非跨平台项目编译环境&quot;&gt;&lt;a href=&quot;#Docker学习记录-三-构建非跨平台项目编译环境&quot; class=&quot;headerlink&quot; title=&quot;Docker学习记录(三)-构建非跨平台项目编译环境&quot;&gt;&lt;/a&gt;Docker学习记录
    
    </summary>
    
      <category term="docker" scheme="http://mrdear.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="http://mrdear.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习记录(二)-Dockerfile创建镜像</title>
    <link href="http://mrdear.cn/2017/03/10/docker/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)-Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <id>http://mrdear.cn/2017/03/10/docker/Docker学习记录(二)-Dockerfile创建镜像/</id>
    <published>2017-03-10T13:21:00.000Z</published>
    <updated>2017-04-02T02:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录-二-Dockerfile创建镜像"><a href="#Docker学习记录-二-Dockerfile创建镜像" class="headerlink" title="Docker学习记录(二)-Dockerfile创建镜像"></a>Docker学习记录(二)-Dockerfile创建镜像</h1><p>标签（空格分隔）： docker</p>
<hr>
<p>本文学习Dcokerfile的基本命令,并且创建一个支持ssh服务的镜像.</p>
<hr>
<h2 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h2><h3 id="1-1基本案例"><a href="#1-1基本案例" class="headerlink" title="1.1基本案例"></a>1.1基本案例</h3><p>dockerfile可以说是docker的描述符,该文件定义了docker镜像的所能拥有哪些东西.基本格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">第一行指定该镜像基于的基础镜像(必须)</div><div class="line">FROM java:8</div><div class="line"></div><div class="line">维护者信息</div><div class="line">MAINTAINER quding  niudear@foxmail.com</div><div class="line"></div><div class="line">镜像操作指令</div><div class="line">RUN echo $JAVA_HOME</div><div class="line"></div><div class="line">启动时操作的命令</div><div class="line"></div><div class="line">CMD ./usr/sbin/nginx</div></pre></td></tr></table></figure></p>
<p>该文件说明从Java8这个基础镜像创建一个新的镜像,输出Java路径,启动成功则启动nginx服务,这也是一个Dockerfile需要包含的操作步骤.</p>
<h3 id="1-2指令详解"><a href="#1-2指令详解" class="headerlink" title="1.2指令详解"></a>1.2指令详解</h3><p><strong>1.FROM</strong>：格式为 <code>FROM &lt;image&gt;</code>或<code>FROM&lt;image&gt;:&lt;tag&gt;</code>第一条指令必须是FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。</p>
<p><strong>2.MAINTAINER</strong>：格式为MAINTAIER<name>，指定维护者信息。</name></p>
<p><strong>3.RUN</strong>：格式为<code>RUN &lt;command&gt;</code>或者<code>RUN [“executable”，“param1”，“param2”]</code>。前者将在shell终端中运行的命令，即/bin/sh–c；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现，例如<code>RUN[“/bin/bash”，“-c”，“echohello”]</code>。每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\来换行。这实际上就是在容器构建时需要执行哪些指令，例如容器构建时需要下拉代码，但是默认启动的容器中是没有Git指令的，就需要下载，可以执行：<code>RUN apt-get install -y git</code>，然后<code>RUN git clonexxxx</code></p>
<p><strong>4.CMD</strong>：指定容器启动后执行的命令<br>命令格式为:<br>sh格式: CMD &lt;命令&gt;<br>exec格式:CMD [“可执行文件”,”参数1”,”参数2”]<br>一般都是早就写好的脚本或者启动一个服务，例如：<code>CMD[“/run.sh”]</code>。注意：如果Dockerfile中指定了多条命令，只有最后一条会被执行。如果用户启动时候加了运行的命令，则会覆盖掉CMD指定的指令。</p>
<p>这里有一个问题,很多时候我们想要docker一直在后台运行,但是往往docker启动后就停止.原因就在于此.<br>比如执行<code>CMD serice mysql start</code>,那么翻译过来的话是<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;serice mysql start&quot;]</code>,那么对于docker来说CMD主进程为sh,那么sh执行完该命令就结束,所以导致docker停止.所以要改成直接启动文件形式<code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;&quot;daemon off;]</code>,指定前台运行.</p>
<p><strong>5.EXPOSE</strong>：告诉Docker服务端容器需要暴露的端口号，供互联系统使用。在启动容器时需要通过-P（注意是大写），Docker主机会自动分配一个端口转发到指定的端口；使用-p，则可以具体指定哪个本地端口映射过来。<br>例如：我在elasticsearch镜像的Dockerfile中指定了暴露出9200和9300端口，我可以在Dockerfile中写：<code>EXPOSE 9200 9300</code></p>
<p><strong>6.ENV</strong>：创建的时候给容器中加上个需要的环境变量。指定一个值，为后续的RUN指令服务</p>
<p><strong>7.COPY</strong>：复制本地的文件或目录到容器中。目标路径不存在时，会自动创建。</p>
<p><strong>8.ENTRYPOINT</strong>：配置容器启动后执行的命令，并且不可被docker run 提供的参数覆盖。<br>每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效</p>
<p><strong>9.VOLUME</strong>：创建一个挂在点，可以从本机或其他容器挂载的挂载点。意思就是从容器中暴露出一部分，和外界共享这块东西，一般放数据库的数据或者是代码。在容器启动运行的时候，如果需要将volume暴露的东西和本地的一个文件夹进行映射，想要通过本地文件直接访问容器中暴露的部分，可以在运行的时候进行映射：</p>
<p><strong>10.USER</strong>：指定运行容器时的用户名或者UID，后续的RUN也会使用指定的用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。<br>要临时获取管理员权限的时候要使用gosu，不推荐使用sudo。如果不指定，容器默认是root运行。</p>
<p><strong>11.WORKDIR</strong>：定义工作目录，如果容器中没有此目录，会自动创建</p>
<p>创建指令<code>docker build 路径</code>,该命令会读取路径下的Dockerfile文件和其他文件,然后发送给服务端,由服务端创建镜像.</p>
<hr>
<h2 id="2-创建SSH服务镜像"><a href="#2-创建SSH服务镜像" class="headerlink" title="2.创建SSH服务镜像"></a>2.创建SSH服务镜像</h2><h3 id="2-1准备Java8环境"><a href="#2-1准备Java8环境" class="headerlink" title="2.1准备Java8环境"></a>2.1准备Java8环境</h3><p>后续教程需要利用到Java8环境,因此先下载一个官方的Java8镜像作为基础镜像.直接执行如下命令.可以利用之前的教程,启动容器查看下java路径.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull java:8</div></pre></td></tr></table></figure></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/sJUUIIhnu1bxyfWnYtf8VfN7W3z5NMMj7lARWGpw.jpg" alt=""></p>
<h3 id="2-2编写Dockerfile"><a href="#2-2编写Dockerfile" class="headerlink" title="2.2编写Dockerfile"></a>2.2编写Dockerfile</h3><p>ssh服务主要是openssh-server来提供,因此需要在容器中安装该服务.<br><strong>Dockerfile:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#显示该镜像是基于java8镜像</div><div class="line">FROM java:8</div><div class="line"></div><div class="line">#维护人信息</div><div class="line">MAINTAINER quding niudear@foxmail.com</div><div class="line">#更新源</div><div class="line">RUN apt-get update</div><div class="line">#安装软件</div><div class="line">RUN apt-get install -y openssh-server</div><div class="line"></div><div class="line">RUN mkdir -p /var/run/sshd</div><div class="line">RUN mkdir -p /root/.ssh</div><div class="line"></div><div class="line">#取消pam限制</div><div class="line">RUN sed -ri &apos;s/session  required   pam_loginuid.so/#session    required  pam_loginuid.so/g&apos; /etc/pam.d/sshd</div><div class="line"></div><div class="line">#复制配置文件到相应位置</div><div class="line">COPY authorized_keys /root/.ssh/authorized_keys</div><div class="line">COPY run.sh /run.sh</div><div class="line"></div><div class="line">#赋予脚本权限</div><div class="line">RUN chmod 755 /run.sh</div><div class="line"></div><div class="line">#开放端口</div><div class="line">EXPOSE 22</div><div class="line"></div><div class="line">#设置启动命令</div><div class="line"></div><div class="line">CMD [&quot;/run.sh&quot;]</div></pre></td></tr></table></figure></p>
<p><strong>run.sh</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">/usr/sbin/sshd -D</div></pre></td></tr></table></figure></p>
<p><strong>拷贝本机的id_ras</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat ~/.ssh/id_rsa.pub &gt;authorized_keys</div><div class="line">//用来免密的</div></pre></td></tr></table></figure></p>
<p><strong>执行构建</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t sshd:java .</div></pre></td></tr></table></figure></p>
<p>构建成功后使用<code>docker images</code>即可查看,然后像上篇一样启动容器,暴露出端口,再使用ssh连接,和一般linux系统就没什么差别了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker学习记录-二-Dockerfile创建镜像&quot;&gt;&lt;a href=&quot;#Docker学习记录-二-Dockerfile创建镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker学习记录(二)-Dockerfile创建镜像&quot;&gt;&lt;/a&gt;Dock
    
    </summary>
    
      <category term="docker" scheme="http://mrdear.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="http://mrdear.cn/tags/docker/"/>
    
  </entry>
  
</feed>
