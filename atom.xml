<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  <subtitle>change from today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrdear.cn/"/>
  <updated>2017-09-16T02:55:36.000Z</updated>
  <id>http://mrdear.cn/</id>
  
  <author>
    <name>Niu li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis源码分析(三)--动态Sql中的参数解析</title>
    <link href="http://mrdear.cn/2017/09/10/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)--%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>http://mrdear.cn/2017/09/10/mybatis/Mybatis源码分析(三)--参数解析/</id>
    <published>2017-09-10T03:45:04.000Z</published>
    <updated>2017-09-16T02:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis中参数解析对于开发人员来说是至关重要的,不然很容易出小问题,举个例子,假设现在方法为,当然这个是很糟糕的写法,这里只是想要搞清楚参数如何解析,项目中万万不可这样写.</p>
<h3 id="参数输入解析"><a href="#参数输入解析" class="headerlink" title="参数输入解析"></a>参数输入解析</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   //方法</div><div class="line">   User findUser(@Param("name") String name,int age,String email)</div><div class="line">   //对应xml</div><div class="line">&lt;select id="findUser" resultType="cn.mrdear.users.dao.User"&gt;</div><div class="line">	SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;age&#125; AND email = #&#123;email&#125; </div><div class="line">&lt;/select&gt;</div><div class="line">//调用参数</div><div class="line">   final User user = userMapper.findUser("quding", 18, "qq@mail.com");</div></pre></td></tr></table></figure>
<p>那么这里Mybatis会怎么解析参数呢?这个xml会构造失败不?首先是<code>MapperMethod</code>中使用<code>ParamNameResolver</code>对输入参数解析,针对上述输入参数会得到下面的结果.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<span class="comment">//获取参数类型,对于上述例子则是String,int,String</span></div><div class="line">   <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();<span class="comment">//这里获取到的则是@Param,getParameterAnnotations方法也用到了动态代理.</span></div><div class="line">   <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</div><div class="line">   <span class="keyword">int</span> paramCount = paramAnnotations.length;</div><div class="line">   <span class="comment">// get names from @Param annotations</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</div><div class="line">     <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123; <span class="comment">//过滤其内部一些特殊类型</span></div><div class="line">       <span class="comment">// skip special parameters</span></div><div class="line">       <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     String name = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</div><div class="line">       <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</div><div class="line">         hasParamAnnotation = <span class="keyword">true</span>;</div><div class="line">         name = ((Param) annotation).value();<span class="comment">//获取到'name'值</span></div><div class="line">         <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// @Param was not specified.</span></div><div class="line">       <span class="keyword">if</span> (config.isUseActualParamName()) &#123;<span class="comment">//默认为true,因此编译后参数都是args0,args1之类,因此这里获取的也是args0...</span></div><div class="line">         name = getActualParamName(method, paramIndex);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//当上面配置为false的时候这里才会使用0,1代替,因此如果未开启则会报错</span></div><div class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="comment">// use the parameter index as the name ("0", "1", ...)</span></div><div class="line">         <span class="comment">// gcode issue #71</span></div><div class="line">         name = String.valueOf(map.size());<span class="comment">//上述都没的话则世界使用map的index.</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     map.put(paramIndex, name);</div><div class="line">   &#125;</div><div class="line">   names = Collections.unmodifiableSortedMap(map);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>那么执行完毕后对于上述例子,names里面如下图所示,由于<code>config.isUseActualParamName()</code>为true,所以#{0}这种写法这里并不支持,而且也不建议这种写法,无可读性.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504965737.png?imageMogr2/thumbnail/!120p" alt=""><br>接下来执行<code>method.convertArgsToSqlCommandParam(args)</code>获取到实际输入的参数,对于上面例子我获取到的是个Map集合,如下图所示,对于单一实体例如User那么获取到的就是该实体.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505017418.png?imageMogr2/thumbnail/!120p" alt=""><br>再看我所用的sql写法,那么这里只能获取到name的值,sql处理时就会报错.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;age&#125; AND email = #&#123;email&#125;</div></pre></td></tr></table></figure></p>
<p><strong>由此可见针对多参数的输入</strong>,最佳解决方案是用<code>@Param</code>注解,其次为使用Map集合包裹参数,这样的话<code>method.convertArgsToSqlCommandParam(args)</code>得到的则是该Map集合.</p>
<h3 id="动态sql渲染解析"><a href="#动态sql渲染解析" class="headerlink" title="动态sql渲染解析"></a>动态sql渲染解析</h3><p>上述流程能得到所有的输入参数,那么接下来就是对sql的解析,下面把我们的sql变得复杂一些.(不要讨论sql的意义…这里只是分析参数如何解析)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//mapper接口</div><div class="line">  User findUser(@Param("name") String name, @Param("user") User user,@Param("ids") List&lt;Long&gt; ids);</div><div class="line">//xml</div><div class="line">    &lt;select id="findUser" resultType="cn.mrdear.users.dao.User"&gt;</div><div class="line">		SELECT * FROM user WHERE username = #&#123;name&#125; AND age = #&#123;user.age&#125; AND email = #&#123;user.email&#125;</div><div class="line">		OR id in</div><div class="line">		&lt;foreach collection="ids" item="item" open="(" close=")" separator=","&gt;</div><div class="line">			#&#123;item&#125;</div><div class="line">		&lt;/foreach&gt;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>按照上述流程Mybatis解析出来的输入参数如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505020777.png?imageMogr2/thumbnail/!100p" alt=""></p>
<p>接下进入<code>DefaultSqlSession</code>的处理中,在其中有如下方法会多参数进一步判断,可以看出对于单一参数为<code>Collection</code>或者<code>Array</code>时Mybatis都会给默认命名方案.(这里是在3.3.0之前的版本只会处理List)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</div><div class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</div><div class="line">    map.put(<span class="string">"collection"</span>, object);</div><div class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</div><div class="line">      map.put(<span class="string">"list"</span>, object);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> map;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</div><div class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</div><div class="line">    map.put(<span class="string">"array"</span>, object);</div><div class="line">    <span class="keyword">return</span> map;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> object;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到了接下来转到执行器,使用<code>DynamicContext</code>构造动态sql所需要的上下文,对其构造函数分析<br>执行到这里的话参数只有三种情况</p>
<ol>
<li>null,无任何参数传入</li>
<li>Map类型，对于多参数,或者参数本身就是map再或者输入单一参数集合类型,数组类型都会转换为map</li>
<li>单一POJO类型.<br>Mybatis这里要做的就是把参数的各种形式尽可能都放在<code>ContextMap</code>中,该<code>ContextMap</code>是绑定了Ognl的,方便Ognl直接从其中获取到值.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</div><div class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</div><div class="line">    <span class="comment">//对于单个输入数据直接保存在ContentMap中</span></div><div class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//输入参数形式为 _parameter  : parameterObject</span></div><div class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</div><div class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1505023031.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h4><p>SqlNode是动态Sql解析和完善<code>ContextMap</code>的地方,对于我上述sql会转换为其三个子类,相关解析方法都在其内部.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505027107.png?imageMogr2/thumbnail/!70p" alt=""><br>解析后的sql如下图<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = ? <span class="keyword">AND</span> age = ? <span class="keyword">AND</span> email = ?</div><div class="line">		<span class="keyword">OR</span> <span class="keyword">id</span> <span class="keyword">in</span> (  ?, ?, ?)</div></pre></td></tr></table></figure></p>
<p>此时<code>ContextMap</code>如下,其中有<code>_frch_item_2</code>这种形式的参数,这是Mybatis对foreach解析后所生成的键,便于填充数据,具体可以看<code>ForeachSqlNode</code><br><img src="http://oobu4m7ko.bkt.clouddn.com/1505027407.png?imageMogr2/thumbnail/!100p" alt=""><br>那么接下来要做的事情就是一一设置进去这些值.</p>
<h4 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h4><p>顾名思义,其提供<code>void setParameters(PreparedStatement ps)</code>对于sql参数设置的处理.分析下<code>DefaultParameterHandler</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</div><div class="line">   ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</div><div class="line">   List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</div><div class="line">   <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">//parameterMappings存储着要设置进去的值类型等信息</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</div><div class="line">       ParameterMapping parameterMapping = parameterMappings.get(i);</div><div class="line">       <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</div><div class="line">         Object value;</div><div class="line">         String propertyName = parameterMapping.getProperty();</div><div class="line">         <span class="comment">//AdditionalParameter是从ContextMap中copy到的,其没有的话说明是_parameter里面的值.</span></div><div class="line">         <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></div><div class="line">           value = boundSql.getAdditionalParameter(propertyName);</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</div><div class="line">           value = <span class="keyword">null</span>;</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</div><div class="line">           value = parameterObject;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">//获取_parameter里面的值.</span></div><div class="line">           MetaObject metaObject = configuration.newMetaObject(parameterObject);</div><div class="line">           <span class="comment">//其内部是一个递归实现获取.</span></div><div class="line">           value = metaObject.getValue(propertyName);</div><div class="line">         &#125;</div><div class="line">           <span class="comment">//typeHandle的处理</span></div><div class="line">         TypeHandler typeHandler = parameterMapping.getTypeHandler();</div><div class="line">         JdbcType jdbcType = parameterMapping.getJdbcType();</div><div class="line">         <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</div><div class="line">           jdbcType = configuration.getJdbcTypeForNull();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">           typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</div><div class="line">         &#125; <span class="keyword">catch</span> (TypeException e) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</div><div class="line">         &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>那么看<code>MetaObject</code>的递归获取,递归是针对参数为<code>user.username</code>这样的话会先从<code>_parameter</code>中找到user,然后再调用user 的getUsername()方法获取到结果.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">  PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</div><div class="line">  <span class="comment">//hasNext判断user.username这种类型</span></div><div class="line">  <span class="keyword">if</span> (prop.hasNext()) &#123;</div><div class="line">    MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</div><div class="line">    <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//递归获取</span></div><div class="line">      <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> objectWrapper.get(prop);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么针对上面的例子,这里先是去boundSql中的addtionParameters中获取参数,该参数一般是sql解析时动态生成的,比如foreach生成的_frch_xx,获取不到的话再去原始的ParamsObject中获取,该处的解析为递归形式了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505526788.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mybatis的SQL解析总体流程如下:</p>
<ol>
<li>构造ParamtersMap,保存输入参数.</li>
<li>构造ContextMap,为OGNL解析提供数据.</li>
<li>读取xml.使用SqlSource与SqlNode解析xml中的sql,设置参数值到boundSql的addtionParameters中,其为ContextMap的一个副本.</li>
<li>根据<code>boundSql.parameterMappings</code>获取到参数,从<code>addtionParameters</code>与<code>ParamtersMap</code>中读取参数设置到<code>PreparedStatement</code>中</li>
<li>执行sql<br>本文只分析了总体流程,其中有很多细节都忽略了,如遇到问题再看也不迟.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mybatis中参数解析对于开发人员来说是至关重要的,不然很容易出小问题,举个例子,假设现在方法为,当然这个是很糟糕的写法,这里只是想要搞清楚参数如何解析,项目中万万不可这样写.&lt;/p&gt;
&lt;h3 id=&quot;参数输入解析&quot;&gt;&lt;a href=&quot;#参数输入解析&quot; class=&quot;he
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(二)--Sqlsession的执行流程</title>
    <link href="http://mrdear.cn/2017/09/09/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)--Sqlsession%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://mrdear.cn/2017/09/09/mybatis/Mybatis源码分析(二)--Sqlsession的执行流程/</id>
    <published>2017-09-09T11:49:52.000Z</published>
    <updated>2017-09-14T14:58:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇Mapper动态代理中发现Mybatis会对Mapper接口的方法转向<code>mapperMethod.execute(sqlSession, args)</code>,那么该篇就学习Mybatis对于sql的执行总体流程,文章不会涉及很多细节点,重点学习其设计以及这样做的理由.</p>
<hr>
<h3 id="SqlCommand"><a href="#SqlCommand" class="headerlink" title="SqlCommand"></a>SqlCommand</h3><p><code>SqlCommand</code>是<code>MapperMethod</code>的一个内部类,其封装着要执行sql的id(xml的namespace+方法名)与类型(select,insert等),这些都是从<code>MappedStatement</code>中获取到,<code>MappedStatement</code>是mybatis初始化读取xml时所构造的对象,具体可以参考之前的文章.对于一个确定的Mapper接口中方法来说这个是确定的值.还有这里有些人认为是命令模式,我认为不是,这里只是该方法对应sql的唯一标识的体现,从下面代码Mybatis对其的使用来看,也不是命令模式具有的行为,而对于命令的执行实际上是<code>sqlSession</code>来执行的,而命令模式的要求是命令中封装委托对象,调用其excute()把任务交给委托执行的对象.<br><strong>Mybatis对sqlCommand的使用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object result;</div><div class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</div><div class="line">      <span class="keyword">case</span> INSERT: &#123;</div><div class="line">    	Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> UPDATE: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      ...............</div></pre></td></tr></table></figure></p>
<h3 id="MethodSignature与ParamNameResolver"><a href="#MethodSignature与ParamNameResolver" class="headerlink" title="MethodSignature与ParamNameResolver"></a>MethodSignature与ParamNameResolver</h3><p><code>MethodSignature</code>也是<code>MapperMethod</code>中的一个内部类对象,其封装着该方法的详细信息,比如返回值类型,参数值类型等,分析该类可以得到Mybatis支持的返回类型有集合,Map,游标等各式各样,还支持自定义结果映射器.<br><code>ParamNameResolver</code>是用于方法参数名称解析并重命名的一个类,在Mybatis的xml中使用<code>#{0},#{id}</code>或者注解<code>@Param()</code>等写法都是合法的,为什么合法这个类就是解释,具体的分析过程因为跨度比较长,后面专用一篇文章来分析.</p>
<h3 id="INSERT-UPDATE-DELETE的结果处理"><a href="#INSERT-UPDATE-DELETE的结果处理" class="headerlink" title="INSERT,UPDATE,DELETE的结果处理"></a>INSERT,UPDATE,DELETE的结果处理</h3><p>对于这三种方法的执行,Mybatis会用<code>rowCountResult()</code>方法包裹结果,从源码中可以很清楚的看出来Mybatis只支持返回void,Integer,Long,Boolean类型的值,<strong>默认是int类型,这里建议数量查询使用int</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> Object result;</div><div class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</div><div class="line">    result = <span class="keyword">null</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</div><div class="line">    result = rowCount;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</div><div class="line">    result = (<span class="keyword">long</span>)rowCount;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</div><div class="line">    result = rowCount &gt; <span class="number">0</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() + <span class="string">"' has an unsupported return type: "</span> + method.getReturnType());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Select的处理"><a href="#Select的处理" class="headerlink" title="Select的处理"></a>Select的处理</h3><p>Select是最复杂的处理,其拥有多样的返回值类型,从源码中可以发现Mybatis支持自定义结果映射器,集合返回,Map返回,游标返回以及单条返回.具体该方法是属于哪一种类型在<code>MethodSignature</code>中都有定义,这里不多叙述.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SELECT:</div><div class="line">       <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</div><div class="line">         executeWithResultHandler(sqlSession, args);</div><div class="line">         result = <span class="keyword">null</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</div><div class="line">         result = executeForMany(sqlSession, args);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</div><div class="line">         result = executeForMap(sqlSession, args);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</div><div class="line">         result = executeForCursor(sqlSession, args);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">         Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">         result = sqlSession.selectOne(command.getName(), param);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>上述流程之后,SQL的执行就转交给<code>SqlSession</code>,这里会设置参数,去数据库查询,映射结果,可谓是Mybatis的核心.<code>SqlSession</code>下有如下四大对象.</p>
<ol>
<li>ParameterHandler: 处理参数设置问题</li>
<li>ResultHandler: 结果处理</li>
<li>StatementHandler: 负责连接数据库,执行sql</li>
<li>Executor: 对上述过程的调度组织.</li>
</ol>
<h3 id="Executor的桥接设计模式"><a href="#Executor的桥接设计模式" class="headerlink" title="Executor的桥接设计模式"></a>Executor的桥接设计模式</h3><p><code>Exexutor</code>是一种一对多的模式,所谓的一是对于调用方Client,其任务就是调度执行sql,获取结果返回,所谓的多是其实现可以有多种,比如Mybatis的<code>SimpleExecutor</code>,<code>ReuseExecutor</code>,<code>BatchExecutor</code>其实现这个功能的方式都有些差异,Mybatis在这里的实现就是采用了桥接设计模式,具体结构如下图.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504971925.png?imageMogr2/thumbnail/!100p" alt=""><br><strong>关于桥接模式或者其他设计模式可以参考此链接</strong><a href="https://github.com/me115/design_patterns/blob/master/structural_patterns/bridge.rst" target="_blank" rel="external">design_patterns</a><br>因为对于调用方来说只关心接口,因此这里提供<code>Exexutor</code>接口,对于内部多种实现把公共的部分比如缓存处理提取出来作为抽象类<code>BaseExecutor</code>,抽象类具有抽象方法与具体方法,那么最适合作为执行模板.其不同的内容定义为抽象方法,由其子类<code>SimpleExecutor</code>,<code>ReuseExecutor</code>等来实现.这一分支可以视作模板设计模式.<br>另外是一个<code>CachingExecutor</code>,Mybatis会在xml中根据配置<code>cacheEnabled</code>来初始化该类,默认为true,那么该类的作用也就是二级缓存.作为桥接类,其对其他的Executor进行调度,并缓存其结果,解耦接口与实现类之间的联系.</p>
<p>那么问题就来了</p>
<ul>
<li>桥接模式是怎么体现的?<blockquote>
<p>桥接模式主要是针对接口与实现类的桥接,按理说接口与实现类是属于强耦合的关系,那么使用桥接模式的话就可以去除这种耦合,桥接类中随时可以更换该接口的实现类,比如这里的<code>CacheingExecutor</code>其本身目的是二级缓存,但是二级缓存是针对<code>Executor</code>下的多个实现类,那么这里做下桥接则是一种很优雅的解决方式.</p>
</blockquote>
</li>
<li>二级缓存为什么不用插件形式来实现,反而用桥接模式来实现呢?<blockquote>
<p>这个问题估计需要我分析完插件设计后才能回答,也可能是其本身设计的问题.占坑.</p>
</blockquote>
</li>
<li><code>BaseExecutor</code>是一种怎样的设计?<blockquote>
<p>这里是很明显的模板设计,那么这里就要谈对抽象类以及接口的理解,个人认为抽象类与接口的不同之处在于接口定义的是协议,一般对外使用,抽象类定义的是过程,也就是模板,这也是抽象类中非抽象方法与抽象方法共存的优势.</p>
</blockquote>
</li>
</ul>
<p>除去上述问题,接下来的执行流程是很清晰的<br><img src="http://oobu4m7ko.bkt.clouddn.com/1505400024.png?imageMogr2/thumbnail/!100p" alt=""></p>
<h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    BoundSql boundSql = ms.getBoundSql(parameter);<span class="comment">//获取sql,此时还都是?占位符状态的sql    </span></div><div class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); <span class="comment">//获取缓存key,根据id,sql,分页参数计算</span></div><div class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);<span class="comment">//跳到下面方法执行</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</div><div class="line">    <span class="keyword">if</span> (closed) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//queryStack用于延时加载,暂时未研究,若配置不用缓存,则每次查询前清空一级缓存.</span></div><div class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">      clearLocalCache();</div><div class="line">    &#125;</div><div class="line">    List&lt;E&gt; list;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      queryStack++;</div><div class="line">      <span class="comment">//缓存中取出数据,具体会在缓存详解中分析,这里只需要了解具体执行过程</span></div><div class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">//针对存储过程更新参数缓存</span></div><div class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//缓存未中则去查数据库</span></div><div class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      queryStack--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这边是延迟加载的实现,不在本次分析内容中</span></div><div class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</div><div class="line">        deferredLoad.load();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// issue #601</span></div><div class="line">      deferredLoads.clear();</div><div class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</div><div class="line">        <span class="comment">// issue #482</span></div><div class="line">        clearLocalCache();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>接下来是DB的查询,DB的查询主要由其子类来实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">  List&lt;E&gt; list;</div><div class="line">  <span class="comment">//这里先放入缓存中占位符,一级缓存的实现</span></div><div class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//调用子类的方法处理,模板方法的体现</span></div><div class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    localCache.removeObject(key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//放入查询结果缓存,一级缓存的实现</span></div><div class="line">  localCache.putObject(key, list);</div><div class="line">  <span class="comment">//存储过程还需要缓存参数</span></div><div class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">    localOutputParameterCache.putObject(key, parameter);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p>按照上述模板的执行,<code>SimpleExecutor</code>是真正从数据库查询的地方,这里也能看出来模板设计模式的好处,将缓存处理与实际数据查询分离解耦,各司其职.<br>查询是要经过<code>StatementHandler</code>组织<code>ParameterHandler</code>,<code>ResultHandler</code>的处理过程,那么<code>StatementHandler</code>承担了什么样的角色?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">  Statement stmt = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Configuration configuration = ms.getConfiguration();</div><div class="line">    <span class="comment">//创建statement</span></div><div class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">    <span class="comment">//获取连接,设置参数等预处理</span></div><div class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</div><div class="line">    <span class="comment">//执行查询并映射结果</span></div><div class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    closeStatement(stmt);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>…<br>篇幅已经过长了,剩下的<code>StatementHandler</code>等也是类似的设计,不打算再继续分析了,有兴趣的同学可以自己研究一下.接下来会对一些关键点的实现分析,比如sql的解析,延迟加载的实现等.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇Mapper动态代理中发现Mybatis会对Mapper接口的方法转向&lt;code&gt;mapperMethod.execute(sqlSession, args)&lt;/code&gt;,那么该篇就学习Mybatis对于sql的执行总体流程,文章不会涉及很多细节点,重点学习其设计以
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(一)--Mapper的动态代理</title>
    <link href="http://mrdear.cn/2017/09/07/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)--Mapper%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://mrdear.cn/2017/09/07/mybatis/Mybatis源码分析(一)--Mapper的动态代理/</id>
    <published>2017-09-07T14:04:05.000Z</published>
    <updated>2017-09-14T15:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中用的最多的就是Mybatis这款半自动ORM框架,用的久却对其了解不是很深,因此打算开一系列文章对其进行解析,顺便对知识进行查漏补缺.本篇是对Mapper动态代理原理的详解.</p>
<hr>
<h3 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h3><p>为另一个对象提供一个替身或者占位符以控制对这个对象的访问.也就是说目的是控制对象形式其职责.当然也可以增强其职责,比如Spring AOP.</p>
<h3 id="代理模式类图"><a href="#代理模式类图" class="headerlink" title="代理模式类图"></a>代理模式类图</h3><p>由下图分析,代理模式所需要的角色为:</p>
<ol>
<li>对外的行为接口Subject,对于调用方Client可见</li>
<li>RealSubject真实的Subject,其包含具体的接口行为,对于Client不可见</li>
<li>代理类Proxy,其是RealSubject的替身,也可以当成对RealSubject的一层包装,对于Client不可见.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1504793889.png?imageMogr2/thumbnail/!150p" alt=""></li>
</ol>
<h3 id="JDK动态代理Example"><a href="#JDK动态代理Example" class="headerlink" title="JDK动态代理Example"></a>JDK动态代理Example</h3><p>案例采取Java的动态代理形式开发,按照上述类图定义角色<br><strong>Subject</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 反转输入的input字符串</div><div class="line">   * <span class="doctag">@param</span> input 要反转的串</div><div class="line">   * <span class="doctag">@return</span> 反转后的串</div><div class="line">   */</div><div class="line">  <span class="function">String <span class="title">reversalInput</span><span class="params">(String input)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>RealSubject</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">reversalInput</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"我是RealSubject: "</span>+input);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(input).reverse().toString();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>SubjectProxy</strong><br>该类实现了InvocationHandler,实际上是对调用的拦截,拦截后转向真实对象的调用,从而拿到正确的结果.是不是很像装饰者模式?其实也可以这样理解,设计模式之前本身就有很多关联性,不需要认定某一个行为就是单一的某个模式,从产生效果来看这里的SubjectProxy实际上就是对RealSubject的装饰,只不过这个装饰并没有添加新功能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxy</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.target = target;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    System.out.println(<span class="string">"proxy subject is "</span>+proxy.getClass());</div><div class="line">    System.out.println(<span class="string">"real subject : "</span>+ToStringBuilder.reflectionToString(target));</div><div class="line">    System.out.println(<span class="string">"method: "</span>+method);</div><div class="line">    System.out.println(<span class="string">"args: "</span>+ ToStringBuilder.reflectionToString(args));</div><div class="line">    <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Client</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    RealSubject subject = <span class="keyword">new</span> RealSubject();</div><div class="line"></div><div class="line">    Subject proxyInstance = (Subject) Proxy.newProxyInstance(</div><div class="line">        Subject.class.getClassLoader(),</div><div class="line">        <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,</div><div class="line">        <span class="keyword">new</span> SubjectProxy(subject));</div><div class="line"></div><div class="line">    System.out.println(proxyInstance.reversalInput(<span class="string">"hello world"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>输出</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proxy is class com.sun.proxy.$Proxy0</div><div class="line">target proxy: cn.mrdear.proxy.RealSubject@51016012[]</div><div class="line">method: public abstract java.lang.String cn.mrdear.proxy.Subject.reversalInput(java.lang.String)</div><div class="line">args: [Ljava.lang.Object;@29444d75[&#123;hello world&#125;]</div><div class="line">我是RealSubject: hello world</div><div class="line">dlrow olleh</div></pre></td></tr></table></figure></p>
<p><strong>分析</strong><br>1.动态代理哪里体现了动态?</p>
<blockquote>
<p>对于常规Java类变量创建要求有.java文件,然后编译成.class文件,然后虚拟机加载该.class文件,最后才能生成对象.但是对于<code>Subject proxyInstance</code>该代理类其是不存在.java文件的,也就是该对象的.class文件是动态生成的,然后虚拟机加载该class文件,创建对象.在Proxy.java中有如下代码动态生成class文件,感兴趣的话可以研究研究,这里不多深入.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Generate the specified proxy class.</div><div class="line"> */</div><div class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>2.JDK动态代理的要求</p>
<blockquote>
<p>JDK动态代理只能针对接口,如果要针对普通类则可以考虑CGLib的实现,这里不多分析.其次动态代理的要求有接口类<code>Subject</code>,<code>InvocationHandler</code>代理方法类存在,才能创建出代理对象,代理对象的执行方法都被<code>InvocationHandler</code>接口所拦截,转向真实类的执行或者你想要的操作.</p>
</blockquote>
<h3 id="Mybatis的动态Mapper"><a href="#Mybatis的动态Mapper" class="headerlink" title="Mybatis的动态Mapper"></a>Mybatis的动态Mapper</h3><p>由上面内容可以看出JDK动态代理需要接口,真实实现类,Clinet调用方,在常规的Mybatis的Mapper代理中接口就是Mapper,Client是service,那么真实的实现类是什么?显而易见这里就是Mapper代理的关键点.</p>
<h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><p>顾名思义该类是产生Mapper接口的工厂类,其内部有如下方法,由此可以看出<code>MapperProxy</code>是方法拦截的地方,那么到此动态代理所需要的必须角色都以凑齐,那么接下来分析最重要的<code>MapperProxy</code>方法拦截.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><p>该类是Mapper接口的Proxy角色,继承了<code>InvocationHandler</code>,所以具有方法拦截功能,看代码注释.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123; <span class="comment">////判断是否为object,因为其不是接口</span></div><div class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123; <span class="comment">//判断是否为接口总的默认方法,jdk8允许接口中声明默认方法.</span></div><div class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对正常Mapper请求的处理</span></div><div class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</div><div class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于正常的Mapper接口中的方法调用,mybatis都会转向到<code>MapperMethod</code>的execute方法中执行,拿到结果返回给调用方Client,整个代理过程结束.对于正常调用是有缓存的,并且该代理类是项目启动时就生成好的,对于性能影响并不是很大实用性还是很高的.</p>
<p>这里要注意下对于默认接口方法的处理<code>invokeDefaultMethod(proxy, method, args)</code>,该方法中每次都直接生成代理类,对性能是一种损耗应该不小,所以<strong>不建议在Mapper接口中写默认方法</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@UsesJava</span>7</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">    <span class="keyword">throws</span> Throwable &#123;</div><div class="line">  <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class</div><div class="line">      .getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</div><div class="line">  <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</div><div class="line">    constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</div><div class="line">  <span class="keyword">return</span> constructor</div><div class="line">      .newInstance(declaringClass,</div><div class="line">          MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</div><div class="line">              | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</div><div class="line">      .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面来看动态代理的最大的好处就是接口(不单指Java的interface,也包括CGLib的动态代理实现)与其实现类的解耦,原本接口和动态类之间是强关联状态,接口不能实例化,实现类必须实现接口的所有方法,有了动态代理之后,接口与实现类的关系并不是很大,甚至不需要实现类就可以完成调用,比如Mybatis这种形式,其并没有创建该接口的实现类,而是用一个方法拦截器转向到自己的通用处理逻辑.<br>另外就是Spring AOP的动态代理,解耦后自然可以实现对原有方法增强的同时又对其代码的零侵入性.<br>最后Mybatis的Mapper动态代理实现原理还是很清晰的,下一篇具体分析<code>MapperMethod</code>,顺便学习Mybatis的各种设计模式.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中用的最多的就是Mybatis这款半自动ORM框架,用的久却对其了解不是很深,因此打算开一系列文章对其进行解析,顺便对知识进行查漏补缺.本篇是对Mapper动态代理原理的详解.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;代理模式定义&quot;&gt;&lt;a href=&quot;#代理模式定义&quot; cla
    
    </summary>
    
      <category term="mybatis" scheme="http://mrdear.cn/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://mrdear.cn/tags/mybatis/"/>
    
      <category term="设计模式" scheme="http://mrdear.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>cnpm导致IDEA对于Angular项目提示失效</title>
    <link href="http://mrdear.cn/2017/08/26/web/Cnpm%E5%AF%BC%E8%87%B4IDEA%E5%AF%B9%E4%BA%8EAngular%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BA%E5%A4%B1%E6%95%88/"/>
    <id>http://mrdear.cn/2017/08/26/web/Cnpm导致IDEA对于Angular项目提示失效/</id>
    <published>2017-08-26T03:17:15.000Z</published>
    <updated>2017-09-02T02:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写Angular项目的时候,IDEA的提示时而有时而没有,找了好久的原因才发现是cnpm的锅.<br>对于<code>cnpm install</code>,安装的angular依赖时链接方式引入,如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717543.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>对于<code>npm install</code>,安装后的依赖时实在的文件,如下图<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717577.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>解决方案老老实实的用npm命令,觉得慢的话可以使用http代理,mac下的shadowsocks支持直接导出http代理,复制命令后粘贴到终端,即可实现终端翻墙.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1503717675.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>如果你不会翻墙,可以参考我之前写的教程  <a href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/">如何搭建属于自己的shadowsocks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写Angular项目的时候,IDEA的提示时而有时而没有,找了好久的原因才发现是cnpm的锅.&lt;br&gt;对于&lt;code&gt;cnpm install&lt;/code&gt;,安装的angular依赖时链接方式引入,如下图&lt;br&gt;&lt;img src=&quot;http://oobu4m7ko.bk
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
      <category term="idea" scheme="http://mrdear.cn/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>动漫推荐</title>
    <link href="http://mrdear.cn/2017/08/25/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"/>
    <id>http://mrdear.cn/2017/08/25/动漫/动漫推荐/</id>
    <published>2017-08-25T03:26:23.000Z</published>
    <updated>2017-08-26T03:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动漫推荐"><a href="#动漫推荐" class="headerlink" title="动漫推荐"></a>动漫推荐</h1><p>标签（空格分隔）： 动漫</p>
<hr>
<p>从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典动漫剧场版.我也不知道自己是什么风格的动漫迷,只是觉得好看,有共鸣就认为是好作品.人们总是把自己喜爱的东西推荐给别人,我也不例外,下面推荐我认为很不错的片子.(排名不分先后)</p>
<h3 id="异邦人-无皇刃谭"><a href="#异邦人-无皇刃谭" class="headerlink" title="异邦人 无皇刃谭"></a>异邦人 无皇刃谭</h3><p>2017年初来在上海实习时看的,故事很温情,对于刚到一个陌生城市打拼的青年来说很容易引起共鸣,也因此我感触颇深,异邦人都是孤独的存在,内心是挣扎的,想要找到自己的归属,然而哪里才是归属?背景音乐很赞,听起来内心有点温暖,但是又会觉得很伤感,充满了无奈</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=508793&auto=0&height=66"></iframe>

<h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>大概高一的时候第一次看了这个作品,唯美的画面,伤感的故事,再加上年少懵懂的恋爱经历,从此新海诚一生粉.回想以前是不是很多事情都可以 <code>One more time,One more chance</code></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=540968&auto=0&height=66"></iframe>

<h3 id="你看起来很好吃"><a href="#你看起来很好吃" class="headerlink" title="你看起来很好吃"></a>你看起来很好吃</h3><p>相当有趣的一部动漫,看起来完全没有负重感,从母爱,父爱,独立,自强等方面诠释了一个龙的成长.电影版是温情的结局,萌萌的画面,治愈的故事,给心情带来不一样的体验.<br>记住:哭闹的孩子 不管在哪里都会被霸王龙叼走</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=795251922&auto=0&height=66"></iframe>

<h3 id="萤火之森"><a href="#萤火之森" class="headerlink" title="萤火之森"></a>萤火之森</h3><p>无法触碰的爱情,只是梦中的憧憬,这样的动漫是提醒你,在你年轻的时候曾经心里也住着一个无法触碰的他/她.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=541381&auto=0&height=66"></iframe>

<h3 id="fate-stay-night"><a href="#fate-stay-night" class="headerlink" title="fate stay night"></a>fate stay night</h3><p>作为番剧来说最喜欢的一个系列,fate stay night也是最早出来的一部,配乐,战斗,剧情都那么引人入胜,虽然fate zero也非常不错,但是让我来选择的话还是该部更让我难忘.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=448119&auto=0&height=66"></iframe>

<h3 id="怪物之子"><a href="#怪物之子" class="headerlink" title="怪物之子"></a>怪物之子</h3><p>细田守家族系列电影,复杂成长的环境会造成我们内心的空洞,然而填补这些空洞的方式就是父母的爱,即使在你眼中认为一无是处,半吊子的父亲,在最关键的时候也会奋不顾身的化身为剑去填补你内心的黑暗,细细回想小时候学习父亲的一举一动或许是每个人都无法忘记的时刻.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26352841&auto=0&height=66"></iframe>

<h3 id="斩·赤红之瞳"><a href="#斩·赤红之瞳" class="headerlink" title="斩·赤红之瞳"></a>斩·赤红之瞳</h3><p>有点虐的番剧,几乎每个角色都是主角的设定,所以每个人角色的个性都很鲜明,也导致了每一个人物死去所带来的感染力.尤其看到结局,最初的一群角色就剩一个赤瞳了,其帮助革命军成立了新国家,然而其还要背负革命军为了革命所做的恶.该番剧有点杀红了眼,所以看的话就要做好心理准备.</p>
<h3 id="亚人"><a href="#亚人" class="headerlink" title="亚人"></a>亚人</h3><p>这两周把亚人的电影版和TV版都看了一遍,首先电影版绝对是圈钱的作品,还是直接看TV版本吧,剧情一样.整个看下来感觉亚人一部很理性的动漫,无论是主角的处事风格,还是亚人和搜查官的联合,都是利益组建了一个关系网,截止到第二季来说目前还是这样的理性,不知道后期有没有变化.能把不死这一老套的技能演绎出这么多惊心动魄的故事场景的估计也只有亚人了吧.另外这动漫也透漏出政府只是比较大的土匪头子而已.</p>
<h3 id="犬夜叉剧场版"><a href="#犬夜叉剧场版" class="headerlink" title="犬夜叉剧场版"></a>犬夜叉剧场版</h3><p>犬夜叉是儿时的回忆,尤其是其四个剧场版,小时候最喜欢看<code>天下霸道之剑</code>这一部,犬夜叉相比火影之类动漫的优点是其有一条爱情线,犬夜叉与阿离(我喜欢台版的这个翻译),犬夜叉与桔梗这之间复杂但却互相信任的关系.最喜欢的人物莫过于桔梗,其只是想过上普通的生活,然而命运却让其至死也无法得到想要的生活,悲情人物总能引起观看者的同情.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=463673252&auto=0&height=66"></iframe>









]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动漫推荐&quot;&gt;&lt;a href=&quot;#动漫推荐&quot; class=&quot;headerlink&quot; title=&quot;动漫推荐&quot;&gt;&lt;/a&gt;动漫推荐&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 动漫&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典
    
    </summary>
    
      <category term="动漫" scheme="http://mrdear.cn/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://mrdear.cn/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习记录(一)--环境部署</title>
    <link href="http://mrdear.cn/2017/08/19/%E8%BF%90%E7%BB%B4/Zookeeper%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)--%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>http://mrdear.cn/2017/08/19/运维/Zookeeper学习记录(一)--环境部署/</id>
    <published>2017-08-19T01:34:10.000Z</published>
    <updated>2017-08-19T02:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>zk在公司系统中承担着一个很重要的角色,因此作为开发有必要了解关于zk的一些知识,推荐文档资料<a href="http://www.majunwei.com/category/201612011952003333/" target="_blank" rel="external">Zookeeper文档目录</a>.</p>
<hr>
<h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><p>zk的安装很简单,只需要下载修改配置启动即可,本文主要是用Docker方式安装,直接上Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># Version 0.0.1</div><div class="line">FROM java:8</div><div class="line">MAINTAINER quding mrdear.cn </div><div class="line"></div><div class="line">#修改源信息</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse&quot; &gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse&quot;&gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse&quot;&gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN echo &quot;APT::Get::AllowUnauthenticated 1 ;&quot; &gt;&gt; /etc/apt/apt.conf</div><div class="line"></div><div class="line">#更新源,并安装vim</div><div class="line">RUN apt-get update</div><div class="line">RUN apt install vim -y</div><div class="line"></div><div class="line">ENV ZOOKEEPER_VERSION 3.4.9</div><div class="line"></div><div class="line"># 下载zk</div><div class="line">RUN wget -q http://mirror.vorboss.net/apache/zookeeper/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;.tar.gz</div><div class="line"></div><div class="line"># 安装</div><div class="line">RUN tar -xvf zookeeper-$&#123;ZOOKEEPER_VERSION&#125;.tar.gz -C /opt</div><div class="line"></div><div class="line"># 配置zoo.cfg</div><div class="line">RUN mv /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/conf/zoo_sample.cfg /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/conf/zoo.cfg</div><div class="line">ENV ZK_HOME /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;</div><div class="line"></div><div class="line">RUN sed  -i &quot;s|/tmp/zookeeper|$ZK_HOME/data|g&quot; $ZK_HOME/conf/zoo.cfg; mkdir $ZK_HOME/data</div><div class="line"></div><div class="line">EXPOSE 2181 2888 3888</div><div class="line"></div><div class="line">WORKDIR /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;</div><div class="line">VOLUME [&quot;/opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/conf&quot;, &quot;/opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/data&quot;]</div><div class="line"></div><div class="line">CMD bash /opt/zookeeper-$&#123;ZOOKEEPER_VERSION&#125;/bin/zkServer.sh start-foreground</div></pre></td></tr></table></figure></p>
<p>build之后,启动该docker image,暴露出2181端口,然后使用zkClient.sh连接即可操作.</p>
<h3 id="多机部署"><a href="#多机部署" class="headerlink" title="多机部署"></a>多机部署</h3><p>多机部署主要参考文章<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html" target="_blank" rel="external">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a>.下面说下注意事项.</p>
<h4 id="注意端口配置"><a href="#注意端口配置" class="headerlink" title="注意端口配置"></a>注意端口配置</h4><p><strong>initLimit</strong>：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000=10 秒<br><strong>syncLimit</strong>：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2</em>2000=4 秒<br><strong>server.A=B：C：D</strong>：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p>
<h4 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h4><p>zk是主从复制形式,那么只要在leader节点中插入一个node,然后去salve中查看该node是否存在即可.</p>
<h3 id="如何连接"><a href="#如何连接" class="headerlink" title="如何连接?"></a>如何连接?</h3><p>zk的安装目录下bin中有zkCli.sh,该工具格式为<code>zkCli.sh -server host:port</code>,使用其可以对zk进行增删改查,具体命令使用参数<code>-?</code>即可翻阅.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zk在公司系统中承担着一个很重要的角色,因此作为开发有必要了解关于zk的一些知识,推荐文档资料&lt;a href=&quot;http://www.majunwei.com/category/201612011952003333/&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="运维" scheme="http://mrdear.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="zookeeper" scheme="http://mrdear.cn/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>OpenVZ的VPS加速指南</title>
    <link href="http://mrdear.cn/2017/08/13/%E5%B7%A5%E5%85%B7/OpenVZ%E7%9A%84VPS%E5%8A%A0%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    <id>http://mrdear.cn/2017/08/13/工具/OpenVZ的VPS加速指南/</id>
    <published>2017-08-13T14:39:05.000Z</published>
    <updated>2017-08-13T15:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现理论"><a href="#实现理论" class="headerlink" title="实现理论"></a>实现理论</h3><p>OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较好的方案是Google BBR加速,为了在OpenVZ架构上使用必须借助UML这一子linux系统.</p>
<p>所谓的UML全称为User Mode Linux,允许用户在Linux中以一个进程的方式再运行一个lInux,那么就很容易实现我们所需要的加速架构,原理是在UML中启动Shadowsocks,然后访问该Shadowsocks实现加速.</p>
<h3 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h3><p>拿来主义原则,给出原博主链接<a href="https://www.91yun.co/archives/5345" target="_blank" rel="external">OpenVZ的UML+BBR加速一键包</a>,按照文章描述步骤配置即可,在这里做一些额外的补充.</p>
<p><strong>宿主机请求转发</strong><br>一键脚本配置完毕后其是运行在UML主机里面的程序,其内网相对宿主机ip为<code>10.0.0.2</code>,但我们只能访问到宿主机,需要如下命令转发,其中端口<code>8888</code>改成你的ss配置的端口即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -i venet0 -p tcp --dport 8888 -j DNAT --to-destination 10.0.0.2</div><div class="line">iptables -t nat -A PREROUTING -i venet0 -p udp --dport 8888 -j DNAT --to-destination 10.0.0.2</div></pre></td></tr></table></figure>
<p>接下来像以往一样访问即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现理论&quot;&gt;&lt;a href=&quot;#实现理论&quot; class=&quot;headerlink&quot; title=&quot;实现理论&quot;&gt;&lt;/a&gt;实现理论&lt;/h3&gt;&lt;p&gt;OpenVZ架构的VPS加速选择比较少,不然KVM方便,除去双边加速比如FinalSpeed等软件后可用选择并不多,其中比较
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建属于自己的shadowsocks</title>
    <link href="http://mrdear.cn/2017/08/07/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84shadowsocks/"/>
    <id>http://mrdear.cn/2017/08/07/工具/如何搭建属于自己的shadowsocks/</id>
    <published>2017-08-07T15:19:01.000Z</published>
    <updated>2017-08-07T16:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shadowsocks是什么"><a href="#shadowsocks是什么" class="headerlink" title="shadowsocks是什么?"></a>shadowsocks是什么?</h3><p>能看到这篇文章的人大概对这个都有些了解,可以理解为一个代理隧道,通过其可以代理到指定的vps服务器,然后服务器去获取到你所访问的内容再返回给你.<br>如果你把服务器当做跳板机的话,那么shadowsocks就是你与跳板机之间的关联.</p>
<h3 id="vps服务器的选择"><a href="#vps服务器的选择" class="headerlink" title="vps服务器的选择"></a>vps服务器的选择</h3><p>vps服务器有很多,这里推荐下搬瓦工KVM架构的机器,推荐理由便宜,可靠,支持支付宝.</p>
<blockquote>
<p>不介意可以使用我的邀请链接: <a href="https://bandwagonhost.com/aff.php?aff=17639" target="_blank" rel="external">https://bandwagonhost.com/aff.php?aff=17639</a></p>
</blockquote>
<p>注册后选择最便宜款的KVM架构,重要的事情说三遍,KVM架构,KVM架构,KVM架构.至于好处是可以使用锐速,能让你的shadowsocks更加快.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120173.png?imageMogr2/thumbnail/!70p" alt=""><br>接下来是选择付款方案,一般选择$19.9的年付,三四个小伙伴一起用,平摊这个费用的话,就相当划算了.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120257.png?imageMogr2/thumbnail/!70p" alt=""><br>买完后会进去类似的管理后台,选择一键安装即可.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120362.png?imageMogr2/thumbnail/!70p" alt=""><br>到这里,vps服务端的shadowsocks就部署完毕了.接下来是客户端连接.</p>
<h3 id="shadowsocks客户端"><a href="#shadowsocks客户端" class="headerlink" title="shadowsocks客户端"></a>shadowsocks客户端</h3><p>在github上有各个平台的客户端<a href="https://github.com/shadowsocks" target="_blank" rel="external">https://github.com/shadowsocks</a>,windows一般用<code>shadowsocks-windows</code>,mac用<code>ShadowsocksX-NG</code>,linux则用<code>shadowsocks-qt5</code>,下载对应客户端,配置好vps生成的shadowsocks端口和密码,启用即可,其主要作为一个本地服务器,其他应用软件通过其余vps服务器通信.</p>
<p><strong>如何访问?</strong><br>浏览器安装插件<a href="https://switchyomega.com/" target="_blank" rel="external">switchyomega</a>,该插件会代理浏览器的请求链接,根据规则列表决定该链接是否要使用shadowsocks代理.<br>首先新建一个代理模式,该模式下所有请求都会走shadowsocks.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502120910.png?imageMogr2/thumbnail/!70p" alt=""><br>其次建立一个自动情景切换模式,该模式会根据配置的规则自动选择对应的情景模式来处理.该模式主要分为三部分,第一部分是用户自定义,比如图片中我指定匹配<code>*.github.com</code>的连接走的是ss情景模式.<br>第二部分是规则列表,我配置的为<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>,该文件中是被墙的一些地址,这些地址都走ss情景模式,其余的都是直接连接.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1502121104.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>接下来就可以访问google了.</p>
<h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p>锐速安装教程: <a href="https://github.com/91yun/serverspeeder" target="_blank" rel="external">https://github.com/91yun/serverspeeder</a><br>Google BBR : <a href="https://teddysun.com/489.html" target="_blank" rel="external">https://teddysun.com/489.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;shadowsocks是什么&quot;&gt;&lt;a href=&quot;#shadowsocks是什么&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks是什么?&quot;&gt;&lt;/a&gt;shadowsocks是什么?&lt;/h3&gt;&lt;p&gt;能看到这篇文章的人大概对这个都有些了解,
    
    </summary>
    
      <category term="vps" scheme="http://mrdear.cn/categories/vps/"/>
    
    
      <category term="shadowsocks" scheme="http://mrdear.cn/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>maven仓库清理脚本</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://mrdear.cn/2017/07/29/工具/maven仓库清理脚本/</id>
    <published>2017-07-29T14:40:15.000Z</published>
    <updated>2017-07-29T14:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.<br>没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.</p>
<p>附上清理脚本,实际上就是递归遍历文件夹然后判断文件更新时间,对比后决定是否要删除.首次清理后仓库从1.5G变为650M,清爽了不少.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> shutil</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="comment"># maven仓库地址</span></div><div class="line">mvnHome = <span class="string">"/Users/niuli/.m2/repository"</span></div><div class="line"><span class="comment"># 删除该日期前的文件以及文件夹</span></div><div class="line">deleteDateBefore = datetime(<span class="number">2017</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listPathAndClean</span><span class="params">(pathContext)</span>:</span></div><div class="line">    pathDir = os.listdir(pathContext)</div><div class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> pathDir:</div><div class="line">        filepath = os.path.join(pathContext, filename)</div><div class="line">        currentTimeFile = datetime.fromtimestamp(os.path.getmtime(filepath))</div><div class="line"></div><div class="line">        <span class="comment"># 对比时间</span></div><div class="line">        <span class="keyword">if</span> deleteDateBefore &gt; currentTimeFile:</div><div class="line">            print(<span class="string">"filePath:"</span>+filepath+<span class="string">"-----updatetime:"</span>+str(currentTimeFile))</div><div class="line">            print(<span class="string">'delete this'</span>)</div><div class="line">            <span class="keyword">if</span> (os.path.isdir(filepath)):</div><div class="line">                shutil.rmtree(filepath)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                os.remove(filepath)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">            </div><div class="line">        <span class="comment"># 不到期的则深入遍历</span></div><div class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</div><div class="line">            listPathAndClean(filepath)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(deleteDateBefore)</div><div class="line">    print(<span class="string">'start list should delete path'</span>)</div><div class="line">    listPathAndClean(mvnHome)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中本地maven仓库随着项目增多会变得越来越大,看着心烦,于是想着清理.&lt;br&gt;没有发现很好的清理策略,只能从文件以及文件夹修改时间上入手,修改时间小于指定时间的文件夹以及文件都给删除,循环清理几次后仓库应该就干净了.&lt;/p&gt;
&lt;p&gt;附上清理脚本,实际上就是递归遍历文件
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven子模块打包后拷贝目标文件到父模块</title>
    <link href="http://mrdear.cn/2017/07/29/%E5%B7%A5%E5%85%B7/Maven%E5%AD%90%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%90%8E%E6%8B%B7%E8%B4%9D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%B0%E7%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>http://mrdear.cn/2017/07/29/工具/Maven子模块打包后拷贝目标文件到父模块/</id>
    <published>2017-07-29T07:15:56.000Z</published>
    <updated>2017-07-29T07:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>看着这个标题一定想怎么会有这么奇怪的需求….<br>嗯,我也认为这个是很奇怪的需求,但实际上确实存在.</p>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近对公司一个大项目进行整改,该项目是写在一个模块下,也就是一个Maven项目,因此打算把其更改为Maven多模块项目.目录结构的变化如下:<br>原目录结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buy</div><div class="line">   ---src</div><div class="line">       ---main</div><div class="line">       ---test</div><div class="line">   ---conf</div></pre></td></tr></table></figure></p>
<p>更改后的为,也就是按照业务分为三个部分,其中gateway是打包的入口,不含有业务逻辑,其引用其他两个模块.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">buy</div><div class="line">   ---buy-shop</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---buy-course</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---buy-gateway</div><div class="line">        ---src</div><div class="line">        ---main</div><div class="line">        ---test</div><div class="line">   ---conf</div></pre></td></tr></table></figure></p>
<p>那么自然而然打包后生成的buy.war就到了<code>buy-gateway/target</code>这个目录下,对于<code>master</code>分支的代码是生成在<code>buy/target</code>目录下,这样就倒是线上的自动化打包失效,首先保证master能打包成功就不能更改线上的配置,因此需要把<code>buy-gateway/target/buy.war</code>打包成功后拷贝到<code>buy/target/buy.war</code>,保证线上打包脚本的运行.</p>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案是<code>maven-dependency-plugin</code>这款插件,该插件有copy功能,可以自由选择target目录下的任意文件拷贝(要注意该插件不同版本配置是有差异的,如果一直不成功就要检查下配置)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">artifactItems</span>&gt;</span></div><div class="line">                        <span class="comment">&lt;!--把target目录下的war拷贝到buy/target下--&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">artifactItem</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">type</span>&gt;</span>$&#123;project.packaging&#125;<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">overWrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWrite</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.parent.build.directory&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">destFileName</span>&gt;</span>buy.war<span class="tag">&lt;/<span class="name">destFileName</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">artifactItem</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">artifactItems</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>该模块可以用于各种资源的拷贝,因此不要局限于war包</p>
<p><strong>备注</strong>:<br>maven中常见的变量 <a href="http://qiaolevip.iteye.com/blog/1816652" target="_blank" rel="external">maven常用配置的变量</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看着这个标题一定想怎么会有这么奇怪的需求….&lt;br&gt;嗯,我也认为这个是很奇怪的需求,但实际上确实存在.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近对公司一
    
    </summary>
    
      <category term="maven" scheme="http://mrdear.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://mrdear.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>病态的开发模式</title>
    <link href="http://mrdear.cn/2017/07/28/%E9%9A%8F%E8%B0%88/%E7%97%85%E6%80%81%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://mrdear.cn/2017/07/28/随谈/病态的面向对象开发/</id>
    <published>2017-07-28T04:51:50.000Z</published>
    <updated>2017-07-28T06:06:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对象吗?</p>
<p>我苦恼于这个问题,不清楚自己做的事情有什么意义,每次需求最重要的部分就是建立表了,然后”重复性”的写各个层次,顶多用点设计模式在service,strategy,factory等之上,这种开发使我产生了厌烦的情绪,我想这个应该不是所谓的面向对象.</p>
<p>查询一些资料,发现疑惑的不止我一个,我得知<code>贫血模型</code>这一关键词,所谓的贫血模型指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。也就是目前大多数Java项目使用的结构,这样的结构决定了实现之前必须要先设计表结构.那么这和面向对象就没什么关联了.</p>
<p>与<code>贫血模型</code>相对应,充血模型也就是所谓的面向对象形式,我还没有去用过,不敢枉加主观看法,随着搜索我发现了DDD即领域驱动设计这一充血模型的实现,打算好好看看.</p>
<p>无论怎么样,我认为Java WEB目前的开发形式是有点小问题的</p>
<p>希望后续的学习能够解决我的疑问.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转正后接手越来越多的需求,从表结构设计,到编码实现DO与Dao,Domian与Repository,DTO与Service,VO与API,看起来挺美好的,但是无论对于DO还是Domain还是DTO或着VO来说其只是数据的承载,在各个层次中传输的一种DTO形式.那么这是面向对
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="面向对象" scheme="http://mrdear.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于老项目替换dubbo的一点经验</title>
    <link href="http://mrdear.cn/2017/07/23/dubbo/%E5%85%B3%E4%BA%8E%E8%80%81%E9%A1%B9%E7%9B%AE%E6%9B%BF%E6%8D%A2dubbo%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%8F%E9%AA%8C/"/>
    <id>http://mrdear.cn/2017/07/23/dubbo/关于老项目替换dubbo的一点经验/</id>
    <published>2017-07-23T01:07:41.000Z</published>
    <updated>2017-07-23T01:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司一直以来使用内部编写的一个rpc框架,简称old_rpc这套RPC框架,由于历史原因,old_rpc存在如下缺点.</p>
<ol>
<li>old_rpc已经很久没人维护了,因此出了错误很难定位到具体的原因.</li>
<li>old_rpc本身只是RPC框架,随着项目的增多各个项目之间的依赖关系已经很复杂了,需要一套支持服务治理的解决方案.</li>
<li>old_rpc缺乏监控平台,对于动态部署,增加机器或者减少机器都比较麻烦.</li>
<li>…<br>这些缺点已经严重影响到线上稳定性,本文就dubbox替换掉old_rpc方案做的一个调研,对工作量,替换后的稳定性做一个评估,以供大家参考.</li>
</ol>
<h3 id="替换要求"><a href="#替换要求" class="headerlink" title="替换要求"></a>替换要求</h3><ol>
<li>支持平滑上线,也就是说替换后依然支持现有的测试系统,发布系统.</li>
<li>替换必须尽可能小的缩小对业务的影响,代码层面上来看就是业务处理代码中不应该有替换的代码</li>
<li>短期内需要支持dubbox与old_rpc两套方案,并且两套方案可以快速切换,防止替换后线上出现不可预料的问题.</li>
</ol>
<h3 id="替换思路"><a href="#替换思路" class="headerlink" title="替换思路"></a>替换思路</h3><ol>
<li>saturn作为服务提供者,替换比较简单,只需要在原有基础上,增加dubbo协议的Service.</li>
<li>vienna作为消费者,使用dubbo协议引入dubbo的service</li>
<li>vienna增加断路器配置,对于repo层引入的service,dubbox作为主service,old_rpc作为备份service,当主service调用失败则自动切换到备份service进行重试,此过程需要有监控.</li>
</ol>
<h3 id="dubbox"><a href="#dubbox" class="headerlink" title="dubbox"></a>dubbox</h3><ul>
<li>github: <a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a><br>clone下来后使用<code>mvn package -DskipTests</code>,会打包该项目,生成主要的<strong>dubbo.jar</strong>,以及管理平台<strong>dubbo-admin.war</strong>,监控平台<strong>dubbo-simple-monitor.tar.gz</strong>.我已经把相关jar,deploy到公司的nexus上了.mvn的pom中直接引入如下依赖,这里需要去除Spring依赖,dubbox是基于Spring3开发的,强制引入会与现有项目产生冲突.<br>另外dubbox添加了kryo和FST序列化支持,以及多种新特性,使用的话均需要引入相应的jar,具体参考项目的github.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</div><div class="line">           &lt;version&gt;2.8.4&lt;/version&gt;</div><div class="line">           &lt;exclusions&gt;</div><div class="line">               &lt;exclusion&gt;</div><div class="line">                   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">                   &lt;artifactId&gt;*&lt;/artifactId&gt;</div><div class="line">               &lt;/exclusion&gt;</div><div class="line">           &lt;/exclusions&gt;</div><div class="line">       &lt;/dependency&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="zk注册中心"><a href="#zk注册中心" class="headerlink" title="zk注册中心"></a>zk注册中心</h4><p>dubbo的注册如下所示:<br><img src="http://oobu4m7ko.bkt.clouddn.com/1500736706.png?imageMogr2/thumbnail/!100p" alt=""><br>实际操作下来,第三层还会有<code>routers</code>,<code>configurators</code>节点,当在dubbo-admin平台操作该service时,比如倍权,该操作会存在在这些节点中.</p>
<h4 id="服务提供者saturn"><a href="#服务提供者saturn" class="headerlink" title="服务提供者saturn"></a>服务提供者saturn</h4><p>saturn作为服务提供者,其任务是抛出新的dubbo服务RPC接口.在引入上述pom后,需要做少量的配置.</p>
<h5 id="dubbo基本配置"><a href="#dubbo基本配置" class="headerlink" title="dubbo基本配置"></a>dubbo基本配置</h5><p>因此demo只测试能否实现,每一个配置的详细内容并未研究,详细可以参考官方文档配置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注册中心配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">    registryConfig.setAddress(<span class="string">"115.159.185.14:2181"</span>);</div><div class="line">    registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">    <span class="keyword">return</span> registryConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 当前应用配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">application</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</div><div class="line">    applicationConfig.setName(<span class="string">"saturn"</span>);</div><div class="line">    <span class="keyword">return</span> applicationConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 监控配置,监控需要dubbo-monitor</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MonitorConfig <span class="title">monitorConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    MonitorConfig mc = <span class="keyword">new</span> MonitorConfig();</div><div class="line">    mc.setProtocol(<span class="string">"registry"</span>);</div><div class="line">    <span class="keyword">return</span> mc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 提供者监控服务</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</div><div class="line">    providerConfig.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> providerConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 消费者监控</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReferenceConfig <span class="title">referenceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    ReferenceConfig rc = <span class="keyword">new</span> ReferenceConfig();</div><div class="line">    rc.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * RPC协议配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocol</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</div><div class="line">    protocolConfig.setPort(<span class="number">20880</span>);</div><div class="line">    <span class="keyword">return</span> protocolConfig;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h5><p>服务的提供利用的是<code>ServiceBean</code>包裹,形成该bean的代理类,可以写一个通用的配置函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通用service配置类</div><div class="line"> * <span class="doctag">@param</span> saturnService 对应服务</div><div class="line"> * <span class="doctag">@return</span> dubbo服务</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ServiceBean&lt;T&gt; <span class="title">configService</span><span class="params">(T saturnService)</span> </span>&#123;</div><div class="line">  ServiceBean&lt;T&gt; serviceBean = <span class="keyword">new</span> ServiceBean&lt;&gt;();</div><div class="line">  serviceBean.setProxy(<span class="string">"javassist"</span>);</div><div class="line">  serviceBean.setVersion(<span class="string">"1.0"</span>);</div><div class="line">  serviceBean.setInterface(saturnService.getClass().getInterfaces()[<span class="number">0</span>].getName());</div><div class="line">  serviceBean.setRef(saturnService);</div><div class="line">  serviceBean.setTimeout(<span class="number">2000</span>);</div><div class="line">  serviceBean.setRetries(<span class="number">3</span>);</div><div class="line">  <span class="keyword">return</span> serviceBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我想要抛出IUserService这个服务,只需要如下几行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServiceBean&lt;IUserService&gt; <span class="title">userServiceExport</span><span class="params">(IUserService userService)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> configService(userService);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此提供者配置完毕.</p>
<h4 id="服务消费者vienna-无断路器版本"><a href="#服务消费者vienna-无断路器版本" class="headerlink" title="服务消费者vienna(无断路器版本)"></a>服务消费者vienna(无断路器版本)</h4><p>vienna作为服务消费者与提供者一样也需要基本的dubbo配置,两者配置几乎一模一样.</p>
<h5 id="dubbo基本配置-1"><a href="#dubbo基本配置-1" class="headerlink" title="dubbo基本配置"></a>dubbo基本配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfig</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注册中心</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">    registryConfig.setAddress(<span class="string">"115.159.185.14:2181"</span>);</div><div class="line">    registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">    registryConfig.setTimeout(<span class="number">60000</span>);<span class="comment">// vienna不知道为什么链接zk很慢</span></div><div class="line">    <span class="keyword">return</span> registryConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 应用信息,计算依赖关系</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">application</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</div><div class="line">    applicationConfig.setName(<span class="string">"vienna"</span>);</div><div class="line">    <span class="keyword">return</span> applicationConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 监控中心地址</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MonitorConfig <span class="title">monitorConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    MonitorConfig mc = <span class="keyword">new</span> MonitorConfig();</div><div class="line">    mc.setProtocol(<span class="string">"registry"</span>);</div><div class="line">    <span class="keyword">return</span> mc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 提供者监控服务</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</div><div class="line">    providerConfig.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> providerConfig;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 消费者监控</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReferenceConfig <span class="title">referenceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    ReferenceConfig rc = <span class="keyword">new</span> ReferenceConfig();</div><div class="line">    rc.setMonitor(monitorConfig());</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 协议配置,自身无提供者的话可以不配置</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocol</span><span class="params">()</span> </span>&#123;</div><div class="line">    ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</div><div class="line">    protocolConfig.setPort(<span class="number">20880</span>);</div><div class="line">    <span class="keyword">return</span> protocolConfig;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="配置消费者"><a href="#配置消费者" class="headerlink" title="配置消费者"></a>配置消费者</h5><p>消费者是用<code>ReferenceBean</code>类来代理的,可以像提供者那样写一个通用的处理方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基本配置类</div><div class="line"> * <span class="doctag">@param</span> serviceReference 接口</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ReferenceBean&lt;T&gt; <span class="title">configReference</span><span class="params">(Class&lt;T&gt; serviceReference)</span> </span>&#123;</div><div class="line">  ReferenceBean&lt;T&gt; ref = <span class="keyword">new</span> ReferenceBean&lt;&gt;();</div><div class="line">  ref.setVersion(<span class="string">"1.0"</span>);</div><div class="line">  ref.setInterface(serviceReference);</div><div class="line">  ref.setTimeout(<span class="number">2000</span>);</div><div class="line">  ref.setRetries(<span class="number">3</span>);</div><div class="line">  ref.setCheck(<span class="keyword">false</span>);</div><div class="line">  ref.setLoadbalance(<span class="string">"roundrobin"</span>);</div><div class="line">  <span class="keyword">return</span> ref;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么引用服务也就只需要几行代码即可,为了更好的与old_rpc服务区分对于dubbo引入的服务都加上dubbo前缀命名.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = <span class="string">"dubboUserService"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ReferenceBean&lt;IUserService&gt; <span class="title">userService</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> configReference(IUserService.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="替换old-rpc"><a href="#替换old-rpc" class="headerlink" title="替换old_rpc"></a>替换old_rpc</h5><p>无断路器版本替换就很简单了,找到引用该服务的地方,在Spring注入时为其选择注入dubbo服务即可.问题是一旦该服务出现了问题,那么需要手动切换回old_rpc服务.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Resource</span></div><div class="line"> <span class="keyword">private</span> IUserService dubboUserService;</div></pre></td></tr></table></figure></p>
<h4 id="服务消费者vienna-断路器版本"><a href="#服务消费者vienna-断路器版本" class="headerlink" title="服务消费者vienna(断路器版本)"></a>服务消费者vienna(断路器版本)</h4><p>断路器本身是做服务降级,防止系统因一个服务出问题而产生雪崩效应,对于当前系统的两套RPC方案可以利用这一点把要替换掉的old_rpc作为降级服务,当dubboService出现异常时可以立即去调取old_rpc的服务,从而保证系统的健壮性.</p>
<h5 id="断路器要求"><a href="#断路器要求" class="headerlink" title="断路器要求"></a>断路器要求</h5><ol>
<li>业务代码无侵入,可以使用方法级别的注解控制该方法是否走断路器.稳定后可以直接删除,不留痕迹.</li>
<li>支持自动熔断,自动恢复</li>
<li>有支持集群的监控服务,方便排查出现问题的服务.</li>
</ol>
<h5 id="断路器依赖"><a href="#断路器依赖" class="headerlink" title="断路器依赖"></a>断路器依赖</h5><p>对于上述要求,符合条件,又经得起生产考验的大概只有hystrix了,github地址为 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a>,pom依赖如下,主要是核心服务包,注解包,监控包.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.12&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.12&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>实现思路与feign对hystrix的包装很相像,以UserRepo为例,UserRepo中引入了userService服务,那么要自动切换则需要两个UserRepo,一个是引用了dubbox的dubboUserService,一个是引用了old_rpc的old_rpcUserService.断路器是方法级别的监控,使用AOP可以轻松地拦截UserRepo中每一个方法的执行,在执行时使用hystrix包装,执行失败时再使用另一个UserRepo重新执行该方法.<br>上述流程有几个要点:</p>
<ol>
<li>需要通过引用dubbo服务的UserRepo获取到引入old_rpc的UserRepo</li>
<li>需要获取到UserRepo中全部的public方法,方便二次调用.</li>
<li>可以从UserRepo中得到断路器的配置,比如分组,线程池等信息.</li>
</ol>
<h5 id="增强Repo功能"><a href="#增强Repo功能" class="headerlink" title="增强Repo功能"></a>增强Repo功能</h5><p>上述的几个要点需要在UserRepo中附加的功能使用一个接口来抽象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDubboRepoProxy</span> <span class="keyword">extends</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取使用dubbo服务调用的Repo</div><div class="line">   */</div><div class="line">  <span class="function">IDubboRepoProxy <span class="title">getDubboRepo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取当前类所有的public方法</div><div class="line">   * <span class="doctag">@return</span> 键与值都是该方法</div><div class="line">   */</div><div class="line">  <span class="function">Map&lt;Method, Method&gt; <span class="title">getAllPublicMethods</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 得到断路器的配置</div><div class="line">   */</div><div class="line">  HystrixCommand.<span class="function">Setter <span class="title">getHystrixSetter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了让实现类更少的写代码,再为其定义一个抽象类,该抽象类主要负责接口功能的实现,其中<code>initOtherRepo</code>作为抽象方法,需要子类来实现,也就是初始化备份的Repo.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRepoProxyImpl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDubboRepoProxy</span>&gt; <span class="keyword">implements</span> <span class="title">IDubboRepoProxy</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Getter</span></div><div class="line">  <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">  <span class="meta">@Setter</span></div><div class="line">  <span class="keyword">private</span> T otherRepo;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Map&lt;Method, Method&gt; publicMethodMap = Maps.newHashMap();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> HystrixCommand.Setter setter;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> IDubboRepoProxy <span class="title">getDubboRepo</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> otherRepo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, Method&gt; <span class="title">getAllPublicMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> publicMethodMap;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">getHystrixSetter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> setter;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//init repo</span></div><div class="line">    initOtherRepo();</div><div class="line">    <span class="comment">//init method</span></div><div class="line">    Class&lt;? extends IDubboRepoProxy&gt; old_rpcClass = <span class="keyword">this</span>.otherRepo.getClass();</div><div class="line">    <span class="keyword">for</span> (Method method : old_rpcClass.getDeclaredMethods()) &#123;</div><div class="line">      publicMethodMap.put(method, method);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//init setter</span></div><div class="line">    setter = HystrixCommand.Setter</div><div class="line">        .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="keyword">this</span>.getClass().getName()))</div><div class="line">        .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="keyword">this</span>.getClass().getSimpleName()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initOtherRepo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = applicationContext;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="使用AOP动态切换"><a href="#使用AOP动态切换" class="headerlink" title="使用AOP动态切换"></a>使用AOP动态切换</h5><p>上述接口与抽象类会赋予UserRepo我们想要的功能.接下来就是AOP拦截.因为断路器是方法级别的操作,因此该AOP只拦截方法,为了更好的配置增加一个AOP专用注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该注解修饰的方法会被AOP拦截</span></div><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoDubboAspect &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>然后写具体的拦截器.该拦截器责任就是按部就班的执行之前的思路.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoDubboAspectImpl</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AutoDubboAspectImpl.class);</div><div class="line"></div><div class="line">  <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.duitang.context.dubbo.AutoDubboAspect)"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoDubboAspect</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//环绕通知</span></div><div class="line">  <span class="meta">@Around</span>(<span class="string">"autoDubboAspect()"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">autoCheck</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">//要执行的主repo</span></div><div class="line">    IDubboRepoProxy target = (IDubboRepoProxy) pjp.getTarget();</div><div class="line">    <span class="comment">//备用repo</span></div><div class="line">    IDubboRepoProxy otherRepo = target.getDubboRepo();</div><div class="line">    <span class="comment">//该repo中所有方法</span></div><div class="line">    Map&lt;Method, Method&gt; methods = target.getAllPublicMethods();</div><div class="line">    <span class="comment">//断路器执行</span></div><div class="line">    HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(</div><div class="line">        target.getHystrixSetter()) &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">return</span> pjp.proceed();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</div><div class="line">          <span class="comment">//异常直接抛出</span></div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 备用降级方案</div><div class="line">       */</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</div><div class="line">        logger.error(<span class="string">"start getFallback,this exception is &#123;&#125;"</span>, <span class="keyword">this</span>.getFailedExecutionException());</div><div class="line">        logger.error(<span class="string">"start getFallback"</span>, pjp.getSignature().toLongString());</div><div class="line">        MethodSignature signature = (MethodSignature) pjp.getSignature();</div><div class="line">        <span class="comment">//获取执行方法</span></div><div class="line">        Method method = methods.get(signature.getMethod());</div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//使用备用repo执行该方法</span></div><div class="line">          <span class="keyword">return</span> method.invoke(otherRepo, pjp.getArgs());</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</div><div class="line">          logger.error(<span class="string">"getFallback error,&#123;&#125;"</span>,e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> hystrixCommand.execute();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此准备工作算是结束,下面是真正的替换.</p>
<h5 id="开始替换old-rpc服务"><a href="#开始替换old-rpc服务" class="headerlink" title="开始替换old_rpc服务"></a>开始替换old_rpc服务</h5><p>因为准备的充分,那么替换就变得相当简单了.首先为UserRepo增强功能,也就是继承抽象类<code>DubboRepoProxyImpl</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class UserRepo extends DubboRepoProxyImpl&lt;UserRepo&gt;</div></pre></td></tr></table></figure></p>
<p>然后实现<code>initOtherRepo</code>方法,该方法主要是从Spring容器中获取到old_rpc的服务,然后再初始化一个UserRepo.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initOtherRepo</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != getContext()) &#123;</div><div class="line">     IUserService userService = getContext().getBean(<span class="string">"userService"</span>, IUserService.class);</div><div class="line">     IRelationshipService relationshipService = getContext().getBean(<span class="string">"relationshipService"</span>,</div><div class="line">         IRelationshipService.class);</div><div class="line">     IUserInterestsService userInterestsService = getContext().getBean(<span class="string">"userInterestsService"</span>,</div><div class="line">         IUserInterestsService.class);</div><div class="line">     IFriendRecomendService friendRecomendService = getContext().getBean(<span class="string">"friendRecomendService"</span>,</div><div class="line">         IFriendRecomendService.class);</div><div class="line">     <span class="comment">//备用old_rpc服务</span></div><div class="line">     UserRepo userRepo = <span class="keyword">new</span> UserRepo(userService, <span class="keyword">this</span>.appealAccountService, <span class="keyword">this</span>.datasourceService,</div><div class="line">         relationshipService, <span class="keyword">this</span>.lifeArtistService, userInterestsService, <span class="keyword">this</span>.jedisPersist, friendRecomendService);</div><div class="line">     <span class="keyword">this</span>.setOtherRepo(userRepo);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>最后为想要实现短路功能的方法加上注解.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoDubboAspect</span></div><div class="line"><span class="function"><span class="keyword">public</span> BaseUser <span class="title">findBasicInfo</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="消费者无法从zk中获取提供者信息"><a href="#消费者无法从zk中获取提供者信息" class="headerlink" title="消费者无法从zk中获取提供者信息?"></a>消费者无法从zk中获取提供者信息?</h4><p>这种情况大多数都是因为配置时两方信息不一致导致,可以去dubbo-admin平台检查提供者完整的url,再与日志中消费者引用的url做个比较,定位到问题.</p>
<h4 id="zk连接超时"><a href="#zk连接超时" class="headerlink" title="zk连接超时"></a>zk连接超时</h4><p>zk是我在自己服务器上部署的,在vienna项目中配置了外网地址,在prism环境中启动后总是出现zk连接超时,后来测试要连上zk大概需要20秒左右,索性把超时时间配置为60秒,解决,具体原因未知.</p>
<h4 id="saturn中配置zk注册服务后测试案例无法跑通"><a href="#saturn中配置zk注册服务后测试案例无法跑通" class="headerlink" title="saturn中配置zk注册服务后测试案例无法跑通"></a>saturn中配置zk注册服务后测试案例无法跑通</h4><p>这个问题是我在saturn配置了测试环境的zk,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registry</span><span class="params">()</span> </span>&#123;</div><div class="line">  RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</div><div class="line">  registryConfig.setAddress(<span class="string">"10.1.4.10:2181"</span>);</div><div class="line">  registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</div><div class="line">  <span class="keyword">return</span> registryConfig;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是jenkins打包时,测试案例一直失败,大概要打包10多分钟,问题有点莫名其妙,在测试时避免Spring引入该bean即可解决.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体过程是比较顺利的,下篇再记录dubbo-admin与dubbo-monitor,以及hystrix-dashborad的搭建.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;公司一直以来使用内部编写的一个rpc框架,简称old_rpc这套RPC框架,由于历史原因,old_rpc存在如下缺点.&lt;/p&gt;
&lt;ol&gt;
&lt;
    
    </summary>
    
      <category term="服务治理" scheme="http://mrdear.cn/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
      <category term="dubbo" scheme="http://mrdear.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(四) -- JSON Web Token实践(下)</title>
    <link href="http://mrdear.cn/2017/06/30/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E5%9B%9B)%20--%20JSON%20Web%20Token%E5%AE%9E%E8%B7%B5(%E4%B8%8B)/"/>
    <id>http://mrdear.cn/2017/06/30/spring/Spring Security学习记录(四) -- JSON Web Token实践(下)/</id>
    <published>2017-06-30T10:19:22.000Z</published>
    <updated>2017-07-08T02:20:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>接着上篇的内容,了解了JWT Token后,发现这东西就是一个可信的用户信息存储方式,那么可信的话就可以省去验证这个步骤,只有当需要用户的详细信息时候才会去DB中查询用户的详细信息.那么现在的流程就是<br><code>用户请求 -&gt; Spring Security通过token把tokenUser设置到上下文中 -&gt; Spring Security Token以及权限验证 -&gt; 具体的业务接口 -&gt; 需要详细信息则根据用户id去DB中获取</code><br>那么就会有以下几个问题.</p>
<h4 id="token在什么时候生成"><a href="#token在什么时候生成" class="headerlink" title="token在什么时候生成?"></a>token在什么时候生成?</h4><p>这个在登录接口中生成,登录后token放入用户id,用户权限等基础信息,以供验证使用.</p>
<h4 id="token签名的密钥该使用什么"><a href="#token签名的密钥该使用什么" class="headerlink" title="token签名的密钥该使用什么?"></a>token签名的密钥该使用什么?</h4><p>这个我也不太清楚,写死一个密钥感觉很不安全,我的想法是使用用户的密码的密文作为签名密钥,这样当用户更改密码的时候原token都是失效.<br>这样做有个缺点,用户密码的密文每次获取需要查询DB,势必会造成DB的压力,可以考虑加缓存,但要考虑缓存挂掉的情况下对DB的压力.</p>
<h4 id="token该怎么较少被盗后的损失"><a href="#token该怎么较少被盗后的损失" class="headerlink" title="token该怎么较少被盗后的损失?"></a>token该怎么较少被盗后的损失?</h4><p>token既然被系统认为是可信的信息集合,那么就需要有相应的超时机制,超时机制是为了防止token被盗用后的损失也只能在一段时间内,就和session超时机制是一样的用处.</p>
<h4 id="如何解决SSO"><a href="#如何解决SSO" class="headerlink" title="如何解决SSO?"></a>如何解决SSO?</h4><p>SSO需要借助cookie或者localStorge,把token放在顶级域名中,这样的话子系统都能使用到,也就完成的SSO机制.<br>对于多域名,那要解决的问题就是如何跨域设置cookie了</p>
<h4 id="如何解决CSRF"><a href="#如何解决CSRF" class="headerlink" title="如何解决CSRF?"></a>如何解决CSRF?</h4><p>CSRF产生的原因是对方使用了你的Cookie也就是使用了你的认证信息,那么的话获取token这一步就不能依赖token,所以把cookie存在cookie中,然后请求时放入header中,解析时从header中获取token信息.</p>
<hr>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="JWT签名与验签"><a href="#JWT签名与验签" class="headerlink" title="JWT签名与验签"></a>JWT签名与验签</h4><p>首先POM引入依赖包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接着定义一个简单的用户,用作存储在上下文中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUserDTO</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Long id;</div><div class="line">  <span class="keyword">private</span> String username;</div><div class="line">  <span class="keyword">private</span> String email;</div><div class="line">  <span class="keyword">private</span> String avatar;</div><div class="line">  <span class="keyword">private</span> List&lt;String&gt; roles;</div><div class="line">  <span class="comment">//省略get set</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着实现jwt<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 从用户中创建一个jwt Token</div><div class="line">   * <span class="doctag">@param</span> userDTO 用户</div><div class="line">   * <span class="doctag">@return</span> token</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(TokenUserDTO userDTO)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Jwts.builder()</div><div class="line">        .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + VALIDITY_TIME_MS))</div><div class="line">        .setSubject(userDTO.getUsername())</div><div class="line">        .claim(<span class="string">"id"</span>, userDTO.getId())</div><div class="line">        .claim(<span class="string">"avatar"</span>, userDTO.getAvatar())</div><div class="line">        .claim(<span class="string">"email"</span>, userDTO.getEmail())</div><div class="line">        .claim(<span class="string">"roles"</span>, userDTO.getRoles())</div><div class="line">        .signWith(SignatureAlgorithm.HS256, secret)</div><div class="line">        .compact();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 从token中取出用户</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> TokenUserDTO <span class="title">parse</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">    Claims claims = Jwts.parser()</div><div class="line">        .setSigningKey(secret)</div><div class="line">        .parseClaimsJws(token)</div><div class="line">        .getBody();</div><div class="line">    TokenUserDTO userDTO = <span class="keyword">new</span> TokenUserDTO();</div><div class="line">    userDTO.setId(NumberUtils.toLong(claims.getId()));</div><div class="line">    userDTO.setAvatar(claims.get(<span class="string">"avatar"</span>,String.class));</div><div class="line">    userDTO.setUsername(claims.get(<span class="string">"username"</span>,String.class));</div><div class="line">    userDTO.setEmail(claims.get(<span class="string">"email"</span>,String.class));</div><div class="line">    userDTO.setRoles((List&lt;String&gt;) claims.get(<span class="string">"roles"</span>));</div><div class="line">    <span class="keyword">return</span> userDTO;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Spring-Security过滤"><a href="#Spring-Security过滤" class="headerlink" title="Spring Security过滤"></a>Spring Security过滤</h4><p>上述流程中Spring Security所承担的角色是验证token+保存token解析出来的用户到<code>SecurityContextHolder</code>中,弄清楚角色那么实现就很简单了.看之前的过滤器链,<br>蓝色框内包含跨站攻击检测与用户信息获取校验,因为用的是jwt所以这些都可以省略掉,替换为解析并验证token,然后设置解析后的用户到上下文中.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1499046528.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>首先<code>SecurityContextHolder</code>中存储的是<code>Authentication</code>对象,所以需要在TokenUser基础封装一层认证用户.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Spring Security中存放的认证用户</div><div class="line"> * <span class="doctag">@author</span> Niu Li</div><div class="line"> * <span class="doctag">@since</span> 2017/6/28</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUserAuthentication</span> <span class="keyword">implements</span> <span class="title">Authentication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3730332217518791533L</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> TokenUserDTO userDTO;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Boolean authentication = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TokenUserAuthentication</span><span class="params">(TokenUserDTO userDTO, Boolean authentication)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.userDTO = userDTO;</div><div class="line">    <span class="keyword">this</span>.authentication = authentication;</div><div class="line">  &#125;</div><div class="line">    <span class="comment">//这里的权限是FilterSecurityInterceptor做权限验证使用</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getRoles().stream()</div><div class="line">        .map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getDetails</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getUsername();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> authentication;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.authentication = isAuthenticated;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> userDTO.getUsername();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后实现验签方法,验签是从header中取出相应的token,验签成功后返回一个<code>Authentication</code>的对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 验签</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Authentication&gt; <span class="title">verifyToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String token = request.getHeader(AUTH_HEADER_NAME);</div><div class="line">  <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; !token.isEmpty())&#123;</div><div class="line">    <span class="keyword">final</span> TokenUserDTO user = parse(token.trim());</div><div class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> TokenUserAuthentication(user, <span class="keyword">true</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Optional.empty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后实现验证Token的过滤器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  jwt token验证类,验证成功后设置进去SecurityContext中</div><div class="line"> * <span class="doctag">@author</span> Niu Li</div><div class="line"> * <span class="doctag">@since</span> 2017/6/28</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VerifyTokenFilter</span><span class="params">(JwtTokenUtil jwtTokenUtil)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.jwtTokenUtil = jwtTokenUtil;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Optional&lt;Authentication&gt; authentication = jwtTokenUtil.verifyToken(request);</div><div class="line">      log.debug(<span class="string">"VerifyTokenFilter result: &#123;&#125;"</span>,authentication.orElse(<span class="keyword">null</span>));</div><div class="line">      SecurityContextHolder.getContext().setAuthentication(authentication.orElse(<span class="keyword">null</span>));</div><div class="line">      filterChain.doFilter(request,response);</div><div class="line">    &#125; <span class="keyword">catch</span> (JwtException e) &#123;</div><div class="line">      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</div><div class="line">      <span class="comment">//可以在这里指定重定向还是返回错误接口示例</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置下Spring Security,主要就是关闭一些不用的过滤器,实现自己的验证过滤器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">  <span class="meta">@Resource</span></div><div class="line">  <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 在此配置不过滤的请求</div><div class="line">   */</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//每一个请求对应一个空的filter链,这里一般不要配置过多,</span></div><div class="line">    <span class="comment">// 因为查找处是一个for循环,过多就导致每个请求都需要循环一遍直到找到</span></div><div class="line">    web.ignoring().antMatchers(<span class="string">"/"</span>,<span class="string">"/login"</span>,<span class="string">"/favicon.ico"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 在此配置过滤链</div><div class="line">   */</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    http</div><div class="line">        .authorizeRequests()</div><div class="line">        <span class="comment">//角色定义,Spring Security会在其前面自动加上ROLE_,因此存储权限的时候也要加上ROLE_ADMIN</span></div><div class="line">        .antMatchers(<span class="string">"/detail"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</div><div class="line">        .anyRequest().permitAll().and()</div><div class="line">        <span class="comment">//异常处理,可以再此使用entrypoint来定义错误输出</span></div><div class="line">        .exceptionHandling().and()</div><div class="line">        <span class="comment">//不需要session来控制,所以这里可以去掉</span></div><div class="line">        .securityContext().securityContextRepository(<span class="keyword">new</span> NullSecurityContextRepository()).and()</div><div class="line">        <span class="comment">//开启匿名访问</span></div><div class="line">        .anonymous().and()</div><div class="line">        <span class="comment">//退出登录自己来控制</span></div><div class="line">        .logout().disable()</div><div class="line">        <span class="comment">//因为没用到cookies,所以关闭cookies</span></div><div class="line">        .csrf().disable()</div><div class="line">        <span class="comment">//验证token</span></div><div class="line">        .addFilterBefore(<span class="keyword">new</span> VerifyTokenFilter(jwtTokenUtil),</div><div class="line">            UsernamePasswordAuthenticationFilter.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做的话,验证就需要在相应的代码中,或者对指定链接使用Spring Security的权限验证.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该链接尝试获取登录用户,返回该认证用户的信息,请求该链接需要在header中放入x-authorization: token</div><div class="line"> */</div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/detail"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> TokenUserDTO <span class="title">userDetail</span><span class="params">()</span> </span>&#123;</div><div class="line">  Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</div><div class="line">  <span class="keyword">if</span> (Objects.isNull(authentication)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (TokenUserDTO) authentication.getDetails();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">.antMatchers(<span class="string">"/detail"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>这样的话就实现了jwt验证,SSO问题也就是token传输的问题,使用cookie就可以了,客户端去请求时从cookie中加载token,然后放入到header中,对这里的代码没影响.</p>
<hr>
<blockquote>
<p>github地址: <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;接着上篇的内容,了解了JWT Token后,发现这东西就是一个可信的用户信息存储方式,那么可信的话就可以省去验证这个步骤,只有当需要用户的详
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(三) -- JSON Web Token实践(上)</title>
    <link href="http://mrdear.cn/2017/06/26/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)%20--%20JSON%20Web%20Token%E5%AE%9E%E8%B7%B5(%E4%B8%8A)/"/>
    <id>http://mrdear.cn/2017/06/26/spring/Spring Security学习记录(三) -- JSON Web Token实践(上)/</id>
    <published>2017-06-26T08:36:33.000Z</published>
    <updated>2017-08-08T14:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>JWT实际上与Spring Security没多大关系,本文打算使用Spring Security配合JWT这种方式完成用户的认证和授权.</p>
<hr>
<p>JSON Web Token(JWT),是一个开放安全的行业标准,用于多个系统之间传递安全可靠的信息.关于其解释可以参考博文:<br><a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="external">JSON Web Token - 在Web应用间安全地传递信息</a><br>因为原作者写的很详细,这里就只说下个人认为比较重要的问题.</p>
<h3 id="JWT是什么样子的结构"><a href="#JWT是什么样子的结构" class="headerlink" title="JWT是什么样子的结构?"></a>JWT是什么样子的结构?</h3><p>JSON Web Token说到底也是一串token,其形式分三段,看下图,<strong>红色</strong>的为Header,指定token类型与签名类型,<strong>紫色</strong>的为请求体,存储用户id等关键信息,最后<strong>蓝色</strong>的为签名,保证整个信息的完整性,可靠性.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498469217.png?imageMogr2/thumbnail/!70p" alt=""><br>其中playload中可以</p>
<ul>
<li>iss: 该JWT的签发者</li>
<li>sub: 该JWT所面向的用户</li>
<li>aud: 接收该JWT的一方</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li>iat(issued at): 在什么时候签发的</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
<h3 id="JWT是一个怎样的流程"><a href="#JWT是一个怎样的流程" class="headerlink" title="JWT是一个怎样的流程?"></a>JWT是一个怎样的流程?</h3><ol>
<li>客户端使用账户密码请求登录接口</li>
<li>登录成功后返回JWT</li>
<li>客户端再次请求其他接口时带上JWT</li>
<li>服务端接收到JWT后验证签名的有效性.</li>
</ol>
<h3 id="JWT解决了什么问题"><a href="#JWT解决了什么问题" class="headerlink" title="JWT解决了什么问题?"></a>JWT解决了什么问题?</h3><p><strong>token被劫持</strong><br>一开始理解很容易陷入一个误区,比如有人会问对于JWT来说,jwt被劫持了的话,那么对方就可以伪造请求,这东西怎么能保证安全呢?<br>这里问题是没理解好JWT,JWT解决的是认证与授权的问题,上述劫持或者类似的中间人攻击是JWT不可避免的,也是其他认证与授权方式不可避免的,想避免可以使用HTTPS,或者签发jwt的时候记录下Client的ip地址,这些就和JWT没关系了.</p>
<p><strong>与Session的区别</strong><br>session实际上是基于cookie来传输的,最重要的session信息是存储在服务器的,所以服务器每次可以通过cookie中的sessionId获取到当前会话的用户,对于单台服务器这样做没问题,但是对于多台就涉及到共享session的问题了,而且认证用户的增多,session会占用大量的服务器内存.<br>那么jwt是存储在客户端的,服务器不需要存储jwt,jwt里面有用户id,服务器拿到jwt验证后可以获得用户信息.也就实现了session的功能,但是相比session,jwt是无状态的,其不与任何机器绑定,只要签名秘钥足够的安全就能保证jwt的可靠性.</p>
<h3 id="JWT下服务端认为什么样子的请求是可信的"><a href="#JWT下服务端认为什么样子的请求是可信的" class="headerlink" title="JWT下服务端认为什么样子的请求是可信的?"></a>JWT下服务端认为什么样子的请求是可信的?</h3><p>对于服务端来说,无法确定下一个请求是哪一个用户,哪一个终端发出,所以其需要一些信息定位到该用户或者该机器,对于JWT来说其Playload里面存储着UserId,那么服务端接收到Token后对其进行签名验证,验证成功,则认为其是<strong>可信的</strong>,然后通过UserId从DB或者Cache中查询出来用户信息.</p>
<h3 id="为什么JWT能保证信息传输的安全可靠"><a href="#为什么JWT能保证信息传输的安全可靠" class="headerlink" title="为什么JWT能保证信息传输的安全可靠?"></a>为什么JWT能保证信息传输的安全可靠?</h3><p>比如现在有token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eyJhbGciOiJIUzI1NiJ9.</div><div class="line">eyJleHAiOjE0OTg0ODIxNTQsInN1YiI6InF1ZGluZyIsInVzZXJJZCI6IjEwMzc5NDAxIiwicm9sZSI6ImFkbWluIn0.</div><div class="line">-YFTYJ6FLlIQqD4G3hYcWvYlYE8H9eAA2369WEcJFVY</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Header</div><div class="line">&#123;</div><div class="line">  "alg": "HS256"</div><div class="line">&#125;</div><div class="line">Playload</div><div class="line">&#123;</div><div class="line">  "exp": 1498482154,</div><div class="line">  "sub": "quding",</div><div class="line">  "userId": "10379401",</div><div class="line">  "role": "admin"</div><div class="line">&#125;</div><div class="line">Sign</div><div class="line">YFTYJ6FLlIQqD4G3hYcWvYlYE8H9eAA2369WEcJFVY</div></pre></td></tr></table></figure>
<p>假设我的playload被其他人劫持了,其他人把userId修改为他自己的,比如123456,但是其没有签名的秘钥,所以他就没法生成签名.<br>服务端收到该Token后,会用先Base64解码出来相应的信息,然后重新生成sign,使用该sign与客户端传来的Sign进行对比,一样则证明没被修改,也就是可信的请求,否则拒绝该请求.</p>
<p>下一篇开始实战.</p>
<blockquote>
<p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JWT实际上与Spring Security没多大关系,本文打算使用Spring Security配合JWT这种方式完成用户的认证和授权.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JSON Web Token(JWT),是一个开放安全的行业标准,用于多个系统之间传递安全可靠的信息.关于其解
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(二) -- Spring Security的Filter</title>
    <link href="http://mrdear.cn/2017/06/22/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%20--%20Spring%20Security%E7%9A%84Filter/"/>
    <id>http://mrdear.cn/2017/06/22/spring/Spring Security学习记录(二) -- Spring Security的Filter/</id>
    <published>2017-06-22T14:03:37.000Z</published>
    <updated>2017-08-08T14:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇学习了Spring Security是如何拦截请求,并把请求转向到Filter链的,该篇就主要学习下这些Filter链的节点的作用.</p>
<hr>
<p>下面是之前配置的内容,本文也是对这些内容 的执行分析.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:http-basic</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="1-Filter链的由来"><a href="#1-Filter链的由来" class="headerlink" title="1.Filter链的由来"></a>1.Filter链的由来</h3><p>由上文可知每一个<code>security:http</code>标签实际上对应的是一个<code>SecurityFilterChain</code>的类,也就是一条Filter链,可以通过其http属性指明其作用的URL,否则作用域全部的URL,如下配置,该security:http会产生一个对/login下的所有请求Filter链.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/login/**"</span>&gt;</span></div><div class="line">    ******</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>打个断点可以很清楚的看到该Filter链<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498283386.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h3 id="2-SecurityContextPersistenceFilter"><a href="#2-SecurityContextPersistenceFilter" class="headerlink" title="2.SecurityContextPersistenceFilter"></a>2.SecurityContextPersistenceFilter</h3><p>该类在所有的Filter之前,是从<code>SecurityContextRepository</code>中取出用户认证信息,默认实现类为<code>HttpSessionSecurityContextRepository</code>,其会从Session中取出已认证用户的信息,提高效率,避免每一次请求都要查询用户认证信息.<br>取出之后会放入<code>SecurityContextHolder</code>中,以便其他filter使用,该类使用ThreadLocal存储用户认证信息,保证了线程之间的信息隔离,最后再finally中清除该信息.<br>可以配置http的<code>security-context-repository-ref</code>属性来自己控制获取到已认证用户信息的方式,比如使用redis存储session等.</p>
<h3 id="3-WebAsyncManagerIntegrationFilter"><a href="#3-WebAsyncManagerIntegrationFilter" class="headerlink" title="3.WebAsyncManagerIntegrationFilter"></a>3.WebAsyncManagerIntegrationFilter</h3><p>提供了对securityContext和WebAsyncManager的集成,其会把SecurityContext设置到异步线程中,使其也能获取到用户上下文认证信息.</p>
<h3 id="4-HeaderWriterFilter"><a href="#4-HeaderWriterFilter" class="headerlink" title="4.HeaderWriterFilter"></a>4.HeaderWriterFilter</h3><p>其会往该请求的Header中添加相应的信息,在http标签内部使用<code>security:headers</code>来控制.</p>
<h3 id="5-CsrfFilter"><a href="#5-CsrfFilter" class="headerlink" title="5.CsrfFilter"></a>5.CsrfFilter</h3><p>Csrf,跨站请求伪造,了解不是很深,只知道B网站使用A网站的可信Cookie发起请求,从而完成认证,伪造出正当请求.<br>验证方式是通过客户端传来的token与服务端存储的token进行对比,来判断是否为伪造请求,有兴趣的可以查看源代码研究下.</p>
<h3 id="6-LogoutFilter"><a href="#6-LogoutFilter" class="headerlink" title="6.LogoutFilter"></a>6.LogoutFilter</h3><p>匹配URL,默认为<code>/logout</code>,匹配成功后则用户退出,清除认证信息.</p>
<h3 id="7-UsernamePasswordAuthenticationFilter"><a href="#7-UsernamePasswordAuthenticationFilter" class="headerlink" title="7.UsernamePasswordAuthenticationFilter"></a>7.UsernamePasswordAuthenticationFilter</h3><p>登录认证过滤器,默认是对<code>/login</code>的POST请求进行认证,首先该方法会先调用<code>attemptAuthentication</code>尝试认证获取一个<code>Authentication</code>的认证对象,然后通过<code>sessionStrategy.onAuthentication</code>执行持久化,也就是保存认证信息,转向下一个Filter,最后调用<code>successfulAuthentication</code>执行认证后事件.</p>
<p><strong>attemptAuthentication</strong><br>该方法是认证的主要方法,认证是委托配置的<code>authentication-manager</code>-&gt;<code>authentication-provider</code>进行.<br>比如对于该Demo配置的为如下,则默认使用的manager为<code>ProviderManager</code>,使用的provider为<code>DaoAuthenticationProvider</code>,userDetailService为<code>InMemoryUserDetailsManager</code>也就是从内存中获取用户认证信息,也就是下面xml配置的user与admin信息.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>认证基本流程为<code>UserDeatilService</code>根据用户名获取到认证用户的信息,然后通过<code>UserDetailsChecker.check</code>对用户进行状态校验,最后通过<code>additionalAuthenticationChecks</code>方法对用户进行密码校验成功后完成认证.返回一个认证对象.</p>
<p>都是面向接口编程,所以用户可以很轻松的扩展自己的验证方式.</p>
<h3 id="8-DefaultLoginPageGeneratingFilter"><a href="#8-DefaultLoginPageGeneratingFilter" class="headerlink" title="8.DefaultLoginPageGeneratingFilter"></a>8.DefaultLoginPageGeneratingFilter</h3><p>当请求为登录请求时,生成简单的登录页面返回</p>
<h3 id="9-BasicAuthenticationFilter"><a href="#9-BasicAuthenticationFilter" class="headerlink" title="9.BasicAuthenticationFilter"></a>9.BasicAuthenticationFilter</h3><p>Http Basci认证的支持,该认证会把用户名密码使用base64编码后放入header中传输,如下所示,认证成功后会把用户信息放入<code>SecurityContextHolder</code>中.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</div></pre></td></tr></table></figure></p>
<h3 id="10-RequestCacheAwareFilter"><a href="#10-RequestCacheAwareFilter" class="headerlink" title="10.RequestCacheAwareFilter"></a>10.RequestCacheAwareFilter</h3><p>恢复被打断的请求,具体未研究</p>
<h3 id="11-SecurityContextHolderAwareRequestFilter"><a href="#11-SecurityContextHolderAwareRequestFilter" class="headerlink" title="11.SecurityContextHolderAwareRequestFilter"></a>11.SecurityContextHolderAwareRequestFilter</h3><p>针对Servlet api不同版本做的一些包装</p>
<h3 id="12-AnonymousAuthenticationFilter"><a href="#12-AnonymousAuthenticationFilter" class="headerlink" title="12.AnonymousAuthenticationFilter"></a>12.AnonymousAuthenticationFilter</h3><p>当<code>SecurityContextHolder</code>中认证信息为空,则会创建一个匿名用户存入到<code>SecurityContextHolder</code>中</p>
<h3 id="13-SessionManagementFilter"><a href="#13-SessionManagementFilter" class="headerlink" title="13.SessionManagementFilter"></a>13.SessionManagementFilter</h3><p>与登录认证拦截时作用一样,持久化用户登录信息,可以保存到session中,也可以保存到cookie或者redis中.</p>
<h3 id="14-ExceptionTranslationFilter"><a href="#14-ExceptionTranslationFilter" class="headerlink" title="14.ExceptionTranslationFilter"></a>14.ExceptionTranslationFilter</h3><p>异常拦截,其处在Filter链后部分,只能拦截其后面的节点并且着重处理<code>AuthenticationException</code>与<code>AccessDeniedException</code>两个异常.</p>
<h3 id="15-FilterSecurityInterceptor"><a href="#15-FilterSecurityInterceptor" class="headerlink" title="15.FilterSecurityInterceptor"></a>15.FilterSecurityInterceptor</h3><p>主要是授权验证,方法为<code>beforeInvocation</code>,在其中调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</div><div class="line">				.getAttributes(object);</div></pre></td></tr></table></figure></p>
<p>获取到所配置资源访问的授权信息,对于上述配置,获取到的则为<code>hasRole(&#39;ROLE_USER&#39;)</code>,然后根据<code>SecurityContextHolder</code>中存储的用户信息来决定其是否有权限,没权限则返回403,具体想了解可以关注<code>HttpConfigurationBuilder.createFilterSecurityInterceptor()</code>方法,分析其创建流程加载了哪些数据,或者分析<code>SecurityExpressionOperations</code>的子类,其是权限鉴定的实现方法.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个认证授权流程如下图所示,图是网上盗的<br><img src="http://oobu4m7ko.bkt.clouddn.com/1498318805.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>因为是学习方面,使用的不是很多,如有错误请指出,以防误人子弟.<br>简单来说,作为用户需要关心的地方是</p>
<ol>
<li>登录验证<code>UsernamePasswordAuthenticationFilter</code></li>
<li>访问验证<code>BasicAuthenticationFilter</code></li>
<li>权限验证<code>FilterSecurityInterceptor</code><br>下一篇则讲述利用这三个验证实现JWT验证.</li>
</ol>
<p>关于这些过滤器更详细的内容可参考博客: <a href="http://www.iteye.com/blogs/subjects/spring_security" target="_blank" rel="external">http://www.iteye.com/blogs/subjects/spring_security</a></p>
<blockquote>
<p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇学习了Spring Security是如何拦截请求,并把请求转向到Filter链的,该篇就主要学习下这些Filter链的节点的作用.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是之前配置的内容,本文也是对这些内容 的执行分析.&lt;br&gt;&lt;figure class=&quot;highlight
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security学习记录(一) -- 初识Spring Security</title>
    <link href="http://mrdear.cn/2017/06/19/spring/Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%20--%20Spring%20Security%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%20--%20%E5%88%9D%E8%AF%86Spring%20Security/"/>
    <id>http://mrdear.cn/2017/06/19/spring/Spring Security学习记录(一) -- Spring Security学习记录(一) -- 初识Spring Security/</id>
    <published>2017-06-19T06:08:25.000Z</published>
    <updated>2017-08-08T14:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Security是什么"><a href="#Spring-Security是什么" class="headerlink" title="Spring Security是什么?"></a>Spring Security是什么?</h3><p>Spring Security是一套认证授权框架,支持认证模式如<code>HTTP BASIC 认证头 (基于 IETF RFC-based 标准)</code>,<code>HTTP Digest 认证头 ( IETF RFC-based 标准)</code>,<code>Form-based authentication (用于简单的用户界面)</code>,<code>OpenID 认证</code>等,Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制.</p>
<h3 id="使用Spring-Security"><a href="#使用Spring-Security" class="headerlink" title="使用Spring Security"></a>使用Spring Security</h3><p>Spring Security3之后提供了Java Config的配置方式,但是我觉得xml方式比较容易理解其整体结构,所以本文都是基于xml配置的,在github上该项目会提供Java Config方式作为对比.</p>
<h4 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">     &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</div><div class="line"> &lt;/parent&gt;</div><div class="line"></div><div class="line"> &lt;dependencies&gt;</div><div class="line">     &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</div><div class="line">     &lt;/dependency&gt;</div><div class="line">     &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">     &lt;/dependency&gt;</div><div class="line"> &lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>由于使用了Spring Boot,所以需要使用<code>@EnableWebSecurity</code>注解启用Spring Security,并指明其配置文件为classpath下的<code>spring-security.xml</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="meta">@ImportResource</span>(locations = <span class="string">"classpath:spring-security.xml"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><p>在<code>spring-security.xml</code>中引入官方提供的命名空间,然后简单配置下,该配置大概意思是对所有请求的url拦截,必须有User权限的用户才能访问.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</div><div class="line">		http://www.springframework.org/schema/security</div><div class="line">		http://www.springframework.org/schema/security/spring-security.xsd"&gt;</div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">security:http</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:http-basic</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">authorities</span>=<span class="string">"ROLE_USER, ROLE_ADMIN"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>该页面为Spring Security自动生成的登录页面,当我们访问任何连接都会被重定向到该登录页面,输入<code>user:123456</code>登录后才能有权限访问.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1497854910.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>上述是一个简单的Demo,分析则是从这个Demo深入浅出.<br><strong>1.Spring Security是如何拦截请求的?</strong><br>传统的xml配置都会在web.xml里面配置如下过滤器.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看出入口点就是该类,该类会从Spring容器中读取名称为<code>springSecurityFilterChain</code>的一个Filter实例,从而获取到对应代理的Filter.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);</div><div class="line">	<span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</div><div class="line">		delegate.init(getFilterConfig());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> delegate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在doFilter方法中调用该委托的filter,也就实现的拦截请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeDelegate</span><span class="params">(</span></span></div><div class="line">		Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</div><div class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">	delegate.doFilter(request, response, filterChain);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2. Spring Security拦截请求后是如何处理的?</strong><br>打断点可以发现<code>DelegatingFilterProxy</code>实际上代理的是<code>FilterChainProxy</code>这个类,该类中有<code>private List&lt;SecurityFilterChain&gt; filterChains;</code>全局变量,那么<code>SecurityFilterChain</code>为何物?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityFilterChain</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(HttpServletRequest request)</span></span>;</div><div class="line"></div><div class="line">	<span class="function">List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以判断SecurityFilterChain是一套规则所对应的Filter链集合.再看源码<code>getFilters</code>,该方法会根据规则(也就是配置中的<code>security:http</code>标签)获取一个SecurityFilterChain中的一套对应规则的filter链.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</div><div class="line">		<span class="keyword">if</span> (chain.matches(request)) &#123;</div><div class="line">			<span class="keyword">return</span> chain.getFilters();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后在<code>doFilterInternal</code>方法中创建一个<code>VirtualFilterChain</code>类,调用其<code>doFilter</code>方法.<code>VirtualFilterChain</code>这个类很有意思,该类继承了<code>FilterChain</code>类,那么其就拥有了转交请求到指定filter的能力,另外其还拥有一套filter链<code>List&lt;Filter&gt; additionalFilters;</code>,那么这个类就控制了整个Spring Security的执行流程,那么它是怎么实现的呢?<br>开始我以为是一个循环,然而看了源码才发现自己太low了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      currentPosition++;</div><div class="line">Filter nextFilter = additionalFilters.get(currentPosition - <span class="number">1</span>);</div><div class="line">nextFilter.doFilter(request, response, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p><code>currentPosition</code>与<code>additionalFilters</code>都是全局变量,其在调用filter链的时候每次都把自己本身在<code>doFilter</code>传值过去,每一个Filter链节点执行完毕后再返回<code>VirtualFilterChain</code>的<code>doFilter</code>方法,开启下一个节点执行.其结构如下面代码所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(IAChain chain)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IAClass</span> <span class="keyword">implements</span> <span class="title">IA</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(IAChain chain)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"i am IAClass"</span>);</div><div class="line">      chain.doSomeThing();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">IAChain</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IAChainClass</span> <span class="keyword">implements</span> <span class="title">IAChain</span></span>&#123;</div><div class="line"></div><div class="line">    List&lt;IA&gt; IAChains = <span class="keyword">new</span> ArrayList&lt;IA&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IAChainClass</span><span class="params">()</span> </span>&#123;</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">      IAChains.add(<span class="keyword">new</span> IAClass());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (position == IAChains.size()) &#123;</div><div class="line">        System.out.println(<span class="string">"end"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      IA ia = IAChains.get(position++);</div><div class="line">      ia.doSomeThing(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>当调用<code>iaChainClass.doSomeThing()</code>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i am IAClass</div><div class="line">i am IAClass</div><div class="line">i am IAClass</div><div class="line">end</div></pre></td></tr></table></figure></p>
<hr>
<p>调用链的实现还可以使用继承来实现,每次执行前先执行super()方法.</p>
<blockquote>
<p>github地址:  <a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
</blockquote>
<p>ok,下一章分析具体的Filter链中的节点,探究下Spring Security是如何进行用户认证与权限控制的.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring-Security是什么&quot;&gt;&lt;a href=&quot;#Spring-Security是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring Security是什么?&quot;&gt;&lt;/a&gt;Spring Security是什么?&lt;/h3&gt;&lt;p&gt;Spri
    
    </summary>
    
      <category term="Spring" scheme="http://mrdear.cn/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://mrdear.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>WEB小知识-HTTP请求对+和&amp;的处理</title>
    <link href="http://mrdear.cn/2017/05/22/web/WEB%E5%B0%8F%E7%9F%A5%E8%AF%86-HTTP%E8%AF%B7%E6%B1%82%E5%AF%B9+%E5%92%8C&amp;%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/22/web/WEB小知识-HTTP请求对+和&amp;的处理/</id>
    <published>2017-05-22T14:18:00.000Z</published>
    <updated>2017-05-22T15:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.</p>
<blockquote>
<p>对于<code>+</code>号会被编码为空格<br>对于<code>&amp;</code>也会被编码成空格</p>
</blockquote>
<p>举个例子,需要向服务端提交如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编码后的内容如下,可以发现<code>a+b</code>被转换成了<code>a b</code>导致服务端接收到后编译失败.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include%20%3Ciostream%3E%0A%0Ausing%20namespace%20std;</div><div class="line">%0A%0Aint%20main()%0A%7B%0A%20%20%20%20int%20a,b;</div><div class="line">%0A%20%20%20%20cin%20%3E%3E%20a%20%3E%3E%20b;</div><div class="line">%0A%20%20%20%20cout%20%3C%3C%20a b%20%3C%3C%20endl;</div><div class="line">%0A%20%20%20%20return%200;%0A%7D</div></pre></td></tr></table></figure></p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>使用函数<code>encodeURIComponent()</code>,该函数会把特殊字符都给转义,转义结果如下面所示,可见<code>a+b</code>转换成了<code>a%2Bb</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%<span class="number">23</span>include%<span class="number">20</span>%<span class="number">3</span>Ciostream%<span class="number">3</span>E%<span class="number">0</span>A%<span class="number">0</span>Ausing%<span class="number">20</span>namespace%<span class="number">20</span>std%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">0</span>Aint%<span class="number">20</span>main()%<span class="number">0</span>A%<span class="number">7</span>B%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span><span class="keyword">int</span>%<span class="number">20</span>a%<span class="number">2</span>Cb%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cin%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>a%<span class="number">20</span>%<span class="number">3</span>E%<span class="number">3</span>E%<span class="number">20</span>b%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>cout%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>a%<span class="number">2</span>Bb%<span class="number">20</span>%<span class="number">3</span>C%<span class="number">3</span>C%<span class="number">20</span>endl%<span class="number">3</span>B</div><div class="line">%<span class="number">0</span>A%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>return%<span class="number">200</span>%<span class="number">3</span>B%<span class="number">0</span>A%<span class="number">7</span>D</div></pre></td></tr></table></figure></p>
<p>服务端需要使用<code>URLDecoder</code>对其进行反转义,该问题到此解决.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1.问题&quot;&gt;&lt;/a&gt;1.问题&lt;/h3&gt;&lt;p&gt;在HTTP请求中如果传的参数有一些特殊字符则会被编码成空格,导致服务端获取不到响应的信息.&lt;/p&gt;
&lt;blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="bug" scheme="http://mrdear.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(二)-Stream原理</title>
    <link href="http://mrdear.cn/2017/05/20/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)-Stream%E5%8E%9F%E7%90%86/"/>
    <id>http://mrdear.cn/2017/05/20/java/Java8学习记录(二)-Stream原理/</id>
    <published>2017-05-20T11:06:51.000Z</published>
    <updated>2017-07-04T04:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一篇博文,很好的介绍了Stream的原理.本文对其进行一些补充更加详细的讲解.</p>
<blockquote>
<p>作者: 李豪<br>地址: <a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md" target="_blank" rel="external">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md</a></p>
</blockquote>
<p>需求:</p>
<blockquote>
<p>从<code>&quot;张三&quot;,&quot;李四&quot;,&quot;王二&quot;,&quot;张四五&quot;</code>中选出以<code>张</code>开头的名字,然后从再从中选出名字最长的一个,输出其长度.</p>
</blockquote>
<h3 id="1-一种直白的实现"><a href="#1-一种直白的实现" class="headerlink" title="1.一种直白的实现"></a>1.一种直白的实现</h3><p><img src="http://oobu4m7ko.bkt.clouddn.com/1497141037.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p><strong>缺点</strong>:</p>
<ol>
<li>迭代次数过多</li>
<li>频繁产生中间结果,性能无法接受</li>
</ol>
<p><strong>实际想要的效果</strong>:<br>平常的写法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(String str : strings)&#123;</div><div class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">"张"</span>))&#123;<span class="comment">// 1. filter(), 保留以张开头的字符串</span></div><div class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></div><div class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">System.out.println(longest);</div></pre></td></tr></table></figure></p>
<p>Stream的做法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Stream.of(<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王二"</span>,<span class="string">"张四五"</span>)</div><div class="line">      .filter(x -&gt; x.startsWith(<span class="string">"张"</span>))</div><div class="line">      .mapToInt(String::length)</div><div class="line">      .max()</div><div class="line">      .ifPresent(System.out::println);</div></pre></td></tr></table></figure></p>
<h3 id="2-Stream是怎么做到的"><a href="#2-Stream是怎么做到的" class="headerlink" title="2.Stream是怎么做到的?"></a>2.Stream是怎么做到的?</h3><p><strong>Stream的操作分类</strong>:</p>
<p>中间操作:返回一个新的Stream</p>
<pre><code>- 有状态 sorted(),必须等上一步操作完拿到全部元素后才可操作
- 无状态 filter(),该操作的元素不受上一步操作的影响
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream().filter(x -&gt; x.startWith(<span class="string">"张"</span>).map(x -&gt; x.length())</div><div class="line">list.stream().filter(x -&gt; x.startWith(<span class="string">"张"</span>).sorted().map(x -&gt; x.length())</div></pre></td></tr></table></figure>
<p>终端操作:返回结果</p>
<pre><code>- 短路操作findFirst(),找到一个则返回,也就是break当前的循环
- 非短路操作forEach(),遍历全部元素
</code></pre><p>以上操作决定了Stream一定是先构建完毕再执行的特点,也就是延迟执行,当需要结果(终端操作时)开始执行流水线.<br>Stream做到的是对于多次调用合并到一次迭代中处理完所有的调用方式.换句话说就是解决了上述的两个缺点.大概思路是记录下每一步的操作,然后终端操作时对其迭代依次执行每一步的操作,最后再一次循环中处理.</p>
<p><strong>问题</strong>:</p>
<ol>
<li>操作是如何记录下来的?</li>
<li>操作是如何叠加的?</li>
<li>叠加完如何执行的?</li>
<li>执行完如何收集结果的?</li>
</ol>
<hr>
<p>Stream结构示意图:</p>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1497146463.png?imageMogr2/thumbnail/!70p" alt=""></p>
<p>示例代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">data.add(<span class="string">"张三"</span>);</div><div class="line">data.add(<span class="string">"李四"</span>);</div><div class="line">data.add(<span class="string">"王三"</span>);</div><div class="line">data.add(<span class="string">"马六"</span>);</div><div class="line"></div><div class="line">data.stream()</div><div class="line">    .filter(x -&gt; x.length() == <span class="number">2</span>)</div><div class="line">    .map(x -&gt; x.replace(<span class="string">"三"</span>,<span class="string">"五"</span>))</div><div class="line">    .sorted()</div><div class="line">    .filter(x -&gt; x.contains(<span class="string">"五"</span>))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h4 id="1-操作是如何记录下来的"><a href="#1-操作是如何记录下来的" class="headerlink" title="1. 操作是如何记录下来的?"></a>1. 操作是如何记录下来的?</h4><ol>
<li>Head记录Stream起始操作</li>
<li>StatelessOp记录中间操作</li>
<li>StatefulOp记录有状态的中间操作<br>这三个操作实例化会指向其父类<code>AbstractPipeline</code>,也就是在<code>AbstractPipeline</code>中建立了双向链表</li>
</ol>
<p>对于Head<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AbstractPipeline(Spliterator&lt;?&gt; source,</div><div class="line">                 <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</div><div class="line">    <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>; <span class="comment">//首操作上一步为null    </span></div><div class="line">    <span class="keyword">this</span>.sourceSpliterator = source; <span class="comment">//数据</span></div><div class="line">    <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>; <span class="comment">//Head操作</span></div><div class="line">    <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</div><div class="line">    <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</div><div class="line">    <span class="keyword">this</span>.depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.parallel = parallel;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于其他Stage:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</div><div class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</div><div class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//双向链表的建立</span></div><div class="line">    previousStage.nextStage = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>.previousStage = previousStage;</div><div class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;        </div><div class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;        </div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</div><div class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</div><div class="line">    <span class="keyword">if</span> (opIsStateful())</div><div class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1499071580.png?imageMogr2/thumbnail/!60p" height="500" align="right"><br>调用过程如此用双向链表串联起来,每一步都得知其上一步与下一步的操作.<br> data.stream()<br> .filter(x -&gt; x.length() == 2)<br> .map(x -&gt; x.replace(“三”,”五”))<br> .sorted()<br> .filter(x -&gt; x.contains(“五”))<br> .forEach(System.out::println);</p>
<hr>
<h4 id="2-操作是如何叠加的"><a href="#2-操作是如何叠加的" class="headerlink" title="2.操作是如何叠加的?"></a>2.操作是如何叠加的?</h4><p><code>Sink&lt;T&gt;</code>接口:</p>
<ol>
<li>void begin(long size),循环开始前调用,通知每个Stage做好准备</li>
<li>void end(),循环结束时调用,依次调用每个Stage的end方法,处理结果</li>
<li>boolean cancellationRequested(),判断是否可以提前结束循环</li>
<li>void accept(T value),每一步的处理</li>
</ol>
<p>其子类之一ChainedReference:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedReference</span>&lt;<span class="title">T</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">implements</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainedReference</span><span class="params">(Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.downstream = Objects.requireNonNull(downstream);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">        downstream.begin(size);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">        downstream.end();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> downstream.cancellationRequested();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例Filter:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(predicate);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</div><div class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">                    downstream.begin(-<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</div><div class="line">                    <span class="comment">//条件成立则传递给下一个操作,也因为如此所以有状态的操作必须放到</span></div><div class="line">                    <span class="comment">//end方法里面</span></div><div class="line">                    <span class="keyword">if</span> (predicate.test(u))</div><div class="line">                        downstream.accept(u);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再例如sorted():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</div><div class="line">    list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">    list.sort(comparator);</div><div class="line">    downstream.begin(list.size());</div><div class="line">    <span class="keyword">if</span> (!cancellationWasRequested) &#123;</div><div class="line">        list.forEach(downstream::accept);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (T t : list) &#123;</div><div class="line">            <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</div><div class="line">            downstream.accept(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    downstream.end();</div><div class="line">    list = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    list.add(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1499071806.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="叠加后如何执行"><a href="#叠加后如何执行" class="headerlink" title="叠加后如何执行?"></a>叠加后如何执行?</h4><p>执行操作是由终端操作来触发的,例如foreach操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</div><div class="line">    <span class="comment">//evaluate就是开关,一旦调用就立即执行整个Stream    </span></div><div class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行前会对操作从末尾到起始反向包裹起来,得到调用链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Sink <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个Sink是终端操作所对应的Sink</span></div><div class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(sink);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</div><div class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oobu4m7ko.bkt.clouddn.com/1499071772.png?imageMogr2/thumbnail/!70p" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(wrappedSink);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</div><div class="line">        <span class="comment">//依次执行调用链</span></div><div class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</div><div class="line">        spliterator.forEachRemaining(wrappedSink);</div><div class="line">        wrappedSink.end();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        copyIntoWithCancel(wrappedSink, spliterator);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="有状态的中间操作何时执行"><a href="#有状态的中间操作何时执行" class="headerlink" title="有状态的中间操作何时执行?"></a>有状态的中间操作何时执行?</h4><p>例如sorted()操作,其依赖上一次操作的结果集,按照调用链来说结果集必须在accept()调用完才会产生.那也就说明sorted操作需要在end中,然后再重新开启调用链.</p>
<p><strong>sorted的end方法</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">     list.sort(comparator);</div><div class="line">     downstream.begin(list.size());</div><div class="line">     <span class="keyword">if</span> (!cancellationWasRequested) &#123;</div><div class="line">         list.forEach(downstream::accept);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">for</span> (T t : list) &#123;</div><div class="line">             <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</div><div class="line">             downstream.accept(t);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     downstream.end();</div><div class="line">     list = <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>那么就相当于sorted给原有操作断路了一次,然后又重新接上,再次遍历.<br><img src="http://oobu4m7ko.bkt.clouddn.com/1499071708.png?imageMogr2/thumbnail/!70p" alt=""></p>
<h4 id="如何收集到结果"><a href="#如何收集到结果" class="headerlink" title="如何收集到结果?"></a>如何收集到结果?</h4><p>foreach是不需要收集到结果的,但是对于collect这样的操作是需要拿到最终end产生的结果.end产生的结果在最后一个Sink中,这样的操作最终都会提供一个取出数据的get方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></div><div class="line">                                    Spliterator&lt;P_IN&gt; spliterator) &#123;</div><div class="line">     <span class="keyword">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如此拿到数据返回</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一篇博文,很好的介绍了Stream的原理.本文对其进行一些补充更加详细的讲解.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: 李豪&lt;br&gt;地址: &lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals/
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习记录(一)-函数式接口</title>
    <link href="http://mrdear.cn/2017/05/18/java/Java8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://mrdear.cn/2017/05/18/java/Java8学习记录(一)-函数式接口/</id>
    <published>2017-05-18T15:39:11.000Z</published>
    <updated>2017-05-20T10:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>实习前只是粗略的看了下Java8的一些基本语法,但是没有系统的学习过.在使用一段时间后决定系统的对其进行一次分析,加深对Java8函数式编程的理解,提高自己的编码技巧.另外kotlin崛起,感兴趣的朋友尝试下混编也未尝不可.</p>
<hr>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口,对于Java来说就是接口内只有一个公开方法的接口,因为使用lanbda表达式,例如<code>() -&gt; user.getName()</code>对应的调用则可能是<code>func.get()</code>,编译器会根据接口推断所属于的方法,如果有两个则无法推断.Java8提供了很多函数式接口,一般都使用注解<code>@FunctionalInterface</code>声明,有必要了解如下一些函数式接口.</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supplier<t></t></td>
<td>无</td>
<td>T</td>
<td>接收一个T类型的值</td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>T</td>
<td>无</td>
<td>处理一个T类型的值</td>
</tr>
<tr>
<td>BiConsumer<t, u=""></t,></td>
<td>T,U</td>
<td>无</td>
<td>处理T类型和U类型的值</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>T</td>
<td>boolean</td>
<td>处理T类型的值,并返回true或者false.</td>
</tr>
<tr>
<td>ToIntFunction<t></t></td>
<td>T</td>
<td>int</td>
<td>处理T类型的值,并返回int值</td>
</tr>
<tr>
<td>ToLongFunction<t></t></td>
<td>T</td>
<td>long</td>
<td>处理T类型的值,并返回long值</td>
</tr>
<tr>
<td>ToDoubleFunction<t></t></td>
<td>T</td>
<td>double</td>
<td>处理T类型的值,并返回double值</td>
</tr>
<tr>
<td>Function<t, r=""></t,></td>
<td>T</td>
<td>R</td>
<td>处理T类型的值,并返回R类型值</td>
</tr>
<tr>
<td>BiFunction<t, u,="" r=""></t,></td>
<td>T,U</td>
<td>R</td>
<td>处理T类型和U类型的值,并返回R类型值</td>
</tr>
<tr>
<td>BiFunction<t, u,="" r=""></t,></td>
<td>T,U</td>
<td>R</td>
<td>处理T类型和U类型的值,并返回R类型值</td>
</tr>
<tr>
<td>UnaryOperator<t></t></td>
<td>T</td>
<td>T</td>
<td>处理T类型值,并返回T类型值,</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T,T</td>
<td>T</td>
<td>处理T类型值,并返回T类型值</td>
</tr>
</tbody>
</table>
<p>以上的函数每一个代表的都是一种基本的操作,操作之间可以自由组合,所以才有了stream这些灵活的操作.</p>
<h3 id="Stream操作"><a href="#Stream操作" class="headerlink" title="Stream操作"></a>Stream操作</h3><p>Stream的操作是建立在函数式接口的组合上的,最好的学习方法是看Stream接口来学习.下面举一些例子来分析,假设有这样的一些初始数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; testData = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    testData.add(<span class="string">"张三"</span>);</div><div class="line">    testData.add(<span class="string">"李四"</span>);</div><div class="line">    testData.add(<span class="string">"王二"</span>);</div><div class="line">    testData.add(<span class="string">"麻子"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>filter</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div></pre></td></tr></table></figure></p>
<p>filter接收predicate函数,predicate是接收T值,返回boolean值,那么对应的引用就可以写成如下形式,意思是取集合中以’张’开头的名字.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .filter(x -&gt; x.startsWith(<span class="string">"张"</span>))</div></pre></td></tr></table></figure></p>
<p><strong>map</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</div></pre></td></tr></table></figure></p>
<p>map操作接收的是Function接口,对于Function接收T值返回R值,那map的作用就很明显是转换用的,比如下面代码,转换名称为对应的名称长度,也就是从输入String数据返回int数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .map(x -&gt; x.length())</div></pre></td></tr></table></figure></p>
<p><strong>flatMap</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</div></pre></td></tr></table></figure></p>
<p>flatMap和map都是使用Function接口,不同的是返回值flatMap限定为Stream类型.所以flatMap可以作为合并流使用,如以下代码,提取出所有的字符.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testData.stream()</div><div class="line">        .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">        .collect(Collectors.toList());</div><div class="line">        <span class="comment">//输出  [张, 三, 李, 四, 王, 二, 麻, 子]</span></div></pre></td></tr></table></figure></p>
<p><strong>peek</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div></pre></td></tr></table></figure></p>
<p>peek参数为Consumer,Consumer接收T值,无返回,那么该方法就可以作为调试不影响stream中内容的一些操作,不过由于对象都是地址引用,你再此做一些对象内容操作也是可以的.<br><strong>reduce</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Reduce比较复杂的一个接口,属于归纳性操作,看参数,第一个是U泛型,也就是输入类型的参数,最为初始值,第二个BiFunction,接收T,U参数,返回U类型参数,BinaryOperator接收U,U类型,并返回U类型.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> StringBuilder identity = <span class="keyword">new</span> StringBuilder();</div><div class="line"> StringBuilder reduce = testData.stream()</div><div class="line">     .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">     .reduce(identity, (r, x) -&gt; &#123;</div><div class="line">       r.append(x);</div><div class="line">       <span class="keyword">return</span> r;</div><div class="line">     &#125;, StringBuilder::append);</div><div class="line"> System.out.println(identity == reduce);</div><div class="line"> System.out.println(reduce.toString());</div><div class="line"> <span class="comment">//输出 true</span></div><div class="line"><span class="comment">//  张三李四王二麻子</span></div></pre></td></tr></table></figure></p>
<p>首先提供一个基本容器identity,然后两个参数r即是identity,x为每次输入参数,最后一个StringBuilder::append是并发下多个identity的合并策略.<br>再举个例子,既然reduce属于归纳性操作,那么也可以当成collect使用,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; identity = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   ArrayList&lt;String&gt; result = testData.stream()</div><div class="line">       .flatMap(x -&gt; Stream.of(x.split(<span class="string">""</span>)))</div><div class="line">       .reduce(identity, (r, x) -&gt; &#123;</div><div class="line">         r.add(x);</div><div class="line">         <span class="keyword">return</span> r;</div><div class="line">       &#125;,(r1,r2) -&gt; &#123;</div><div class="line">         r1.addAll(r2);</div><div class="line">         <span class="keyword">return</span> r1;</div><div class="line">       &#125;);</div><div class="line">   System.out.println(identity == result);</div><div class="line">   System.out.println(result);</div><div class="line">   <span class="comment">//输出 true</span></div><div class="line">   <span class="comment">//[张, 三, 李, 四, 王, 二, 麻, 子]</span></div></pre></td></tr></table></figure></p>
<h3 id="强大的collect"><a href="#强大的collect" class="headerlink" title="强大的collect"></a>强大的collect</h3><p>collect无疑是stream中最强大的操作,掌握了collect操作才能说掌握了stream.为了便于使用者,Java提供了<code>Collectors</code>类,该类提供了很多便捷的collect操作,如<code>Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>,<code>Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>等操作.这些操作最终都会调用如下构造函数构造出collector对象,因此掌握该本质是最佳的学习方式.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CollectorImpl(Supplier&lt;A&gt; supplier,</div><div class="line">                      BiConsumer&lt;A, T&gt; accumulator,</div><div class="line">                      BinaryOperator&lt;A&gt; combiner,</div><div class="line">                      Function&lt;A,R&gt; finisher,</div><div class="line">                      Set&lt;Characteristics&gt; characteristics) &#123;</div><div class="line">            <span class="keyword">this</span>.supplier = supplier;</div><div class="line">            <span class="keyword">this</span>.accumulator = accumulator;</div><div class="line">            <span class="keyword">this</span>.combiner = combiner;</div><div class="line">            <span class="keyword">this</span>.finisher = finisher;</div><div class="line">            <span class="keyword">this</span>.characteristics = characteristics;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>Supplier类似reduce中的u,接收一个元数据,BiConsumer则是操作数据,BinaryOperator并发下聚合,finisher完成时的转换操作,Set<characteristics>应该按照定义是优化一些操作中的转换.如下面的toList()操作,其finish操作为<code>castingIdentity()</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"> Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</div><div class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</div><div class="line">                                CH_ID);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></characteristics></p>
<p>再看toMap的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;</div><div class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</div><div class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</div><div class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</div><div class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</div><div class="line">    BiConsumer&lt;M, T&gt; accumulator</div><div class="line">            = (map, element) -&gt; map.merge(keyMapper.apply(element),</div><div class="line">                                          valueMapper.apply(element), mergeFunction);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Function作为转换函数提供了key和value的转换,BinaryOperator提供了重复key合并策略,mapSupplier则表示最终收集到的容器.那么使用就很简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Character, String&gt; map = testData.stream()</div><div class="line">        .collect(Collectors.toMap(x -&gt; x.charAt(<span class="number">0</span>), Function.identity()</div><div class="line">            , (v1, v2) -&gt; v2, HashMap::<span class="keyword">new</span>));</div></pre></td></tr></table></figure></p>
<p>其他还有很多方法,就不一一叙述,主要是了解这些接口,知道他所拥有的功能,以及组合的意义,即可很好的掌握Java中的函数式编程.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习前只是粗略的看了下Java8的一些基本语法,但是没有系统的学习过.在使用一段时间后决定系统的对其进行一次分析,加深对Java8函数式编程的理解,提高自己的编码技巧.另外kotlin崛起,感兴趣的朋友尝试下混编也未尝不可.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;函数式接口&quot;&gt;
    
    </summary>
    
      <category term="java" scheme="http://mrdear.cn/categories/java/"/>
    
    
      <category term="java8" scheme="http://mrdear.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java中序列化相关知识</title>
    <link href="http://mrdear.cn/2017/05/02/%E5%B7%A5%E5%85%B7/Java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://mrdear.cn/2017/05/02/工具/Java中的序列化相关知识/</id>
    <published>2017-05-02T08:00:00.000Z</published>
    <updated>2017-09-06T01:49:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天线上遇到了DTO类实现了<code>Serializable</code>接口,但是其并没有显示声明<code>serialVersionUID</code>,这样的话每次打包有改动JDK就会为其重新生成<code>serialVersionUID</code>.这就带来了不同版本之间的实体类可能反序列化不成功,线上RPC调用出现了问题.那么就深入探讨一下原因.</p>
<h3 id="Serializable的作用"><a href="#Serializable的作用" class="headerlink" title="Serializable的作用"></a>Serializable的作用</h3><p>看该类的JDK注释可以发现<code>The serialization interface has no methods or fields and serves only to identify the semantics of being serializable.</code>也就是说Serializable是一个标识接口,和<code>Cloneable</code>接口等一样的效果.<br>如下面的User类,实现了序列化接口,并使用<code>serialVersionUID</code>标识其序列化对应的ID序号.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5768430629641297769L</span>;</div><div class="line">  <span class="keyword">private</span> String nickname;</div><div class="line">  <span class="keyword">private</span> String passwd;</div><div class="line">  <span class="comment">//省略get和set</span></div></pre></td></tr></table></figure></p>
<h3 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h3><p><code>java.io.ObjectOutputStream</code>代表对象输出流,其使用writeObject()方法把对象实例转换为字节流然后写入到文件,或者用于网络传输.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  User userDO = <span class="keyword">new</span> User();</div><div class="line">  userDO.setNickname(<span class="string">"屈定"</span>);</div><div class="line">  userDO.setPasswd(<span class="string">"123456"</span>);</div><div class="line">  File file = <span class="keyword">new</span> File(<span class="string">"user.out"</span>);</div><div class="line">  ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">  outputStream.writeObject(userDO);<span class="comment">//序列化写入到文件中.</span></div><div class="line">  outputStream.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何反序列化"><a href="#如何反序列化" class="headerlink" title="如何反序列化"></a>如何反序列化</h3><p><code>java.io.ObjectInputStream</code>代表对象输入流,其使用readObject()方法读取序列化的字节,然后再转换为对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">  File file = <span class="keyword">new</span> File(base+File.separator+<span class="string">"user.out"</span>);</div><div class="line">  ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">  User user = (User) inputStream.readObject();</div><div class="line">  Assert.assertTrue(StringUtils.equals(user.getNickname(),<span class="string">"屈定"</span>));</div><div class="line">  Assert.assertTrue(StringUtils.equals(user.getPasswd(),<span class="string">"123456"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h3><p>按照上面代码,序列化和反序列化都是成功的,如果在已经序列化后,对User要作修改,增加一个email字段,再试试反序列化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5768430629641297769L</span>;</div><div class="line">    <span class="keyword">private</span> String nickname;</div><div class="line">    <span class="keyword">private</span> String passwd;</div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序会正常运行,而且这个email会被很智能的初始化为null.<br>修改<code>serialVersionUID</code>为1L再试试.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.io.InvalidClassException: cn.edu.aust.test.ObjectTest$User; local class incompatible: stream classdesc serialVersionUID = 5768430629641297769, local class serialVersionUID = 1</div></pre></td></tr></table></figure></p>
<p>报错很明显,两边类的<code>serialVersionUID</code>不一样,也就是说对于编译好的class,其<code>serialVersionUID</code>是其序列化的唯一标识,如果未显示声明JDK则会自动为其加上,换句话说<code>serialVersionUID</code>保证了对象的向上兼容,可以使用命令<code>seriserialver</code>可以查看一个class文件的<code>serialVersionUID</code>,当线上版本忘记加该字段的时候该命令还是很有用处的.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">seriserialver cn.edu.aust.test.ObjectTest\<span class="variable">$User</span> </div><div class="line">cn.edu.aust.test.ObjectTest<span class="variable">$User</span>:    private static final long serialVersionUID = 1L;</div></pre></td></tr></table></figure></p>
<p>另外需要注意反序列化因为是直接从字节流里面构造出对象,因此并不会去执行构造函数.如果你的类有在构造函数中初始值的行为,那么这里就可能得到异常.</p>
<h3 id="transient的作用"><a href="#transient的作用" class="headerlink" title="transient的作用"></a>transient的作用</h3><p>transient翻译为瞬时,也就是被其修饰的变量序列化时会忽略该字段.什么时候需要用到这个字段呢?<br>在Java中对象之间的关系会组成一个对象图,序列化的过程是对该对象图的遍历,那么反序列化也仍然是对该对象图的遍历.对于对象里面的对象就是递归过程,对于链表之类的数据结构递归的话很容易引起栈溢出,那么就可以使用<code>transient</code>忽略该字段.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天线上遇到了DTO类实现了&lt;code&gt;Serializable&lt;/code&gt;接口,但是其并没有显示声明&lt;code&gt;serialVersionUID&lt;/code&gt;,这样的话每次打包有改动JDK就会为其重新生成&lt;code&gt;serialVersionUID&lt;/code&gt;.这就带
    
    </summary>
    
      <category term="工作问题" scheme="http://mrdear.cn/categories/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="jdk" scheme="http://mrdear.cn/tags/jdk/"/>
    
  </entry>
  
</feed>
