<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  <subtitle>change from today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrdear.cn/"/>
  <updated>2017-04-10T08:59:22.000Z</updated>
  <id>http://mrdear.cn/</id>
  
  <author>
    <name>Niu li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>angular2学习记录-经验分享</title>
    <link href="http://mrdear.cn/2017/04/08/web/angular2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://mrdear.cn/2017/04/08/web/angular2学习记录-经验分享/</id>
    <published>2017-04-08T15:00:00.000Z</published>
    <updated>2017-04-10T08:59:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="angular2学习记录-经验分享"><a href="#angular2学习记录-经验分享" class="headerlink" title="angular2学习记录-经验分享"></a>angular2学习记录-经验分享</h1><p>标签（空格分隔）： web</p>
<hr>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>前几天刚下定决心把毕业设计改造下,因为毕业设计算是我学习的基石,学习到的东西都尽可能的在这个平台上施展,锻炼自己.改造为前后端分离,前端使用angular2,后端只提供接口.便于以后的维护.那么就要学习agular2了.</p>
<p><strong>这里就要说下个人观点了,安利一波</strong>:我认为每个程序员都应该有自己的一个项目,一个可以让你学习的东西能施展到上面的项目,可能该项目一开始很简单,但是随着你不断的学习,不断的把新知识运用进去,这个项目就会伴随着你的成长而丰富起来,给你带来的则是更多的实战经验.</p>
<h3 id="2-angular2简介"><a href="#2-angular2简介" class="headerlink" title="2.angular2简介"></a>2.angular2简介</h3><ol>
<li>angular2是类似全家桶组合的框架,所需要的东西几乎都包办了,所以开发起来很迅速.</li>
<li>使用TypeScript作为开发语言,对于Java和C#程序员可以快速上手,还有就是我比较喜欢强类型语言,每个变量各司其职,由其的类型来限定,开发人员也很明确知道变量的作用.</li>
<li>google和Microsoft支持</li>
<li>WebStorm对angular2的强大支持.</li>
<li>一篇安利文章<a href="http://www.infoq.com/cn/articles/why-choose-angular2/" target="_blank" rel="external">http://www.infoq.com/cn/articles/why-choose-angular2/</a></li>
</ol>
<blockquote>
<p>一些学习资料<br>ECMAScript 6入门  <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a><br>TypeScript入门   <a href="http://www.imooc.com/learn/763" target="_blank" rel="external">http://www.imooc.com/learn/763</a><br>TypeScript中文网  <a href="https://www.tslang.cn/docs/tutorial.html" target="_blank" rel="external">https://www.tslang.cn/docs/tutorial.html</a><br>慕课网1小时快速上手视频  <a href="http://www.imooc.com/learn/789" target="_blank" rel="external">http://www.imooc.com/learn/789</a><br>官方文档  <a href="https://www.angular.cn/docs/ts/latest/cli-quickstart.html" target="_blank" rel="external">https://www.angular.cn/docs/ts/latest/cli-quickstart.html</a></p>
</blockquote>
<h3 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3.遇到的问题"></a>3.遇到的问题</h3><h4 id="3-1滚动监听"><a href="#3-1滚动监听" class="headerlink" title="3.1滚动监听"></a>3.1滚动监听</h4><p>要实现页面滚动后导航栏会变色的效果,如下图(图来自我的csdn博客,没找到其他好图床)<br><img src="http://img.blog.csdn.net/20170408234307620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwNjgxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图来自我的csdn博客"></p>
<p>之前使用Jq是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    indexApp.scrollBar = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.body.scrollTop||<span class="built_in">document</span>.documentElement.scrollTop);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>不打算依赖Jq,搜了点资料发现了下面两种写法.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这种写法在TS下不会有效果.</span></div><div class="line">  isAddBackColor()&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getIsIndex())&#123;</div><div class="line">       <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">       <span class="comment">//该处使用匿名函数,而不是箭头函数.</span></div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> marginTop = <span class="built_in">document</span>.body.scrollTop|| <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        self.isBackColor = marginTop &gt; <span class="number">20</span> &amp;&amp; self.getIsIndex();</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 判断是否需要加背景色(有效果的)</div><div class="line">   * 使用isBackColor控制结果</div><div class="line">   */</div><div class="line">  isAddBackColor()&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getIsIndex())&#123;</div><div class="line">      <span class="comment">//监听事件使用箭头函数,这样ng2才会管理该变量</span></div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,() =&gt; &#123;</div><div class="line">        <span class="keyword">let</span> marginTop = <span class="built_in">document</span>.body.scrollTop|| <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        <span class="keyword">this</span>.isBackColor = marginTop &gt; <span class="number">20</span> &amp;&amp; <span class="keyword">this</span>.getIsIndex();</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>原因不明,猜想是<code>var self = this;</code>赋值操作后相当于一个全新的变量,self并不受angular管理,导致刷新的变量是self中的isBackColor.</p>
<h4 id="3-2http参数传递"><a href="#3-2http参数传递" class="headerlink" title="3.2http参数传递"></a>3.2http参数传递</h4><p>按照下面代码传参数应该是没有问题的,但是我遇到了url被编码问题,例如输入<code>1111@qq.com</code>会被转换为<code>1111%40qq.com</code>,导致服务端解析失败,找了很多原因才发现是<code>URLSearchParams</code>这个对象用错了,angular2提供了这个对象,es6里面也有一个该对象,换成ng2中对象即可,<code>import {URLSearchParams} from &quot;@angular/http&quot;;</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> urlParams = <span class="keyword">new</span> URLSearchParams();</div><div class="line">urlParams.set(<span class="string">'search'</span>,search);</div><div class="line">urlParams.set(<span class="string">'order'</span>,order);</div><div class="line">urlParams.set(<span class="string">'pageNum'</span>,pageNum.toString());</div><div class="line">urlParams.set(<span class="string">'pageSize'</span>,pageSize.toString());</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.http.get(Config.url_problem_stage + stage,&#123;<span class="attr">params</span>:urlParams&#125;).toPromise()</div><div class="line">          .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</div><div class="line">          .catch(LogService.handleError)</div></pre></td></tr></table></figure></p>
<h4 id="3-3跨域问题"><a href="#3-3跨域问题" class="headerlink" title="3.3跨域问题"></a>3.3跨域问题</h4><p>浏览器要求同源下才可请求,否则就产生跨域问题.</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a><br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名下</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/lab/a.js" target="_blank" rel="external">http://www.a.com/lab/a.js</a> <br><a href="http://www.a.com/script/b.js" target="_blank" rel="external">http://www.a.com/script/b.js</a></td>
<td>同一域名下不同文件夹</td>
<td>允许</td>
</tr>
<tr>
<td><a href="http://www.a.com:8000/a.js" target="_blank" rel="external">http://www.a.com:8000/a.js</a> <br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>同一域名，不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="https://www.a.com/b.js" target="_blank" rel="external">https://www.a.com/b.js</a></td>
<td>同一域名，不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="http://70.32.92.74/b.js" target="_blank" rel="external">http://70.32.92.74/b.js</a></td>
<td>域名和域名对应ip</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a></td>
<td>主域相同，子域不同</td>
<td>不允许</td>
</tr>
<tr>
<td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <br><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td>同一域名，不同二级域名（同上）</td>
<td>不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="external">http://www.cnblogs.com/a.js</a> <br><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td>不同域名</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p>解决方案是用nginx反向代理到不同端口,模拟同一域名下不同文件夹情况.nginx监听本地888端口,这个也是项目入口,对于带api标识的请求转到后端服务器,对于其他请求则到前端服务器.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       8888;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line"></div><div class="line">    #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">    location /api &#123;</div><div class="line">        proxy_pass   http://127.0.0.1:8080;</div><div class="line">    &#125;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass   http://127.0.0.1:4200;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-4路由问题"><a href="#3-4路由问题" class="headerlink" title="3.4路由问题"></a>3.4路由问题</h4><p>angular2的路由匹配规则是从根路由也就是<code>forRoot()</code>的这个开始.在该处匹配寻找规则.</p>
<p><strong>根路由:</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> appRoutes: Routes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">''</span>,</div><div class="line">    <span class="attr">component</span>: IndexComponent,</div><div class="line">    <span class="attr">pathMatch</span>:<span class="string">'full'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">'aust'</span>,</div><div class="line">    <span class="attr">loadChildren</span>:<span class="string">'./content/content.module#ContentAndAsideModule'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">'index'</span>,</div><div class="line">    <span class="attr">component</span>: IndexComponent,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>:<span class="string">'**'</span>,</div><div class="line">    <span class="attr">loadChildren</span>:<span class="string">'./content/content.module#ContentAndAsideModule'</span></div><div class="line">  &#125;,</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p><strong>子路由:</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> childRouter : Routes = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">''</span>,</div><div class="line">    <span class="attr">component</span>:ContentAndAsideComponent,</div><div class="line">    <span class="attr">children</span>:[</div><div class="line">      &#123;<span class="attr">path</span>:<span class="string">''</span>,<span class="attr">redirectTo</span>:<span class="string">'/index'</span>,<span class="attr">pathMatch</span>:<span class="string">'full'</span>&#125;,</div><div class="line">      &#123;<span class="attr">path</span>:<span class="string">'start'</span>,<span class="attr">component</span>:StartComponent&#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">  ];</div></pre></td></tr></table></figure></p>
<p><strong>举例:</strong><br>访问<code>/</code>,则先在根路由寻找,找到其跳转到IndexComponent,完成任务<br>访问<code>/aust</code>.则先在根路由找,发现需要到子路由里面寻找,到子路由后,在children中发现被重定向到<code>/index</code>,那么回到根路由,找到IndexComponent完成任务.<br>访问<code>/aust/start</code>,则先在根路由找,发现需要到子路由,到子路由匹配到StartComponent,完成任务.</p>
<h4 id="3-5组件通信"><a href="#3-5组件通信" class="headerlink" title="3.5组件通信"></a>3.5组件通信</h4><p>父-&gt;子:子组件使用input装饰器,接受父组件的属性,并且可使用ngOnChanges或则setter监听变化,做额外处理.<br>子-&gt;父:使用output装饰器加EventEmitter向上弹出事件到父组件,父组件监听后处理.<br>任意组件:使用service通讯(要求service单例),service提供Observable的next发布,其他组件引用service对象subscribe该发布,那么就实现了信息的流动,并且是在只要订阅了该发布的组件中都能获取.</p>
<h4 id="3-6单例"><a href="#3-6单例" class="headerlink" title="3.6单例?"></a>3.6单例?</h4><p>agular2的service是providers提供的,该组件如果引用了这个service,那么会先在自己的providers中寻找service,找不到则再向上找父组件,直到module.那么意味着每一个providers提供的是一个实例,旗下的组件都是享用这一个实例,那么怎么实现全局单例呢?很简单在根module中提供服务且其他组件不要自己providers该服务.</p>
<h4 id="3-7组件生命周期"><a href="#3-7组件生命周期" class="headerlink" title="3.7组件生命周期"></a>3.7组件生命周期</h4><p>组件生命周期看下面这张图.<br><img src="http://ac-HSNl7zbI.clouddn.com/eCsidPMfsdB3oeoAsRIPUJ0JbRBJpQcSKDq0rxcc.jpg" alt=""></p>
<hr>
<p>angular2项目:<br><a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;angular2学习记录-经验分享&quot;&gt;&lt;a href=&quot;#angular2学习记录-经验分享&quot; class=&quot;headerlink&quot; title=&quot;angular2学习记录-经验分享&quot;&gt;&lt;/a&gt;angular2学习记录-经验分享&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 
    
    </summary>
    
      <category term="web" scheme="http://mrdear.cn/categories/web/"/>
    
    
      <category term="angular" scheme="http://mrdear.cn/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(五)</title>
    <link href="http://mrdear.cn/2017/04/08/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%BA%94)/"/>
    <id>http://mrdear.cn/2017/04/08/毕业设计/毕业设计周记(五)/</id>
    <published>2017-04-08T14:50:00.000Z</published>
    <updated>2017-04-08T14:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周一直在重构前端,目前登录注册+侧边栏都已经完成,在此过程熟悉了angular2的开发模式,不得不佩服这些前端大神们,搞出来ng2这种类似后端写法的框架,下周进度会更加快,希望下周重构完成.</p>
<p>前端项目地址: <a href="https://github.com/nl101531/AUSTOJ-WEB" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ-WEB</a></p>
<p>等待完成:</p>
<p>1.前端页面的重构</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周一直在重构前端,目前登录注册+侧边栏都已经完成,在此过程熟悉了angular2的开发模式,不得不佩服这些前端大神们,搞出来ng2这种类似后端写法的框架,下周进度会更加快,希望下周重构完成.&lt;/p&gt;
&lt;p&gt;前端项目地址: &lt;a href=&quot;https://github.c
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(四)</title>
    <link href="http://mrdear.cn/2017/04/03/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://mrdear.cn/2017/04/03/毕业设计/毕业设计周记(四)/</id>
    <published>2017-04-03T13:50:00.000Z</published>
    <updated>2017-04-03T23:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周注册流程等都写完了,开始重构前端页面,最终选择使用angular2来重构,其类似后端的写法以及typescript语法对js的修正使得其很容易上手.这周任务主要是在重构中熟悉angular的写法.到五月份的话不知道能不能重构完,尽力而为了.</p>
<p>测试地址:  <a href="http://oj.mrdear.cn/" target="_blank" rel="external">http://oj.mrdear.cn/</a>    服务器比价渣,速度比较慢</p>
<p>测试账号:   1015315668@qq.com    密码: 111111</p>
<p>等待完成:</p>
<p>1.前端页面的重构</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周注册流程等都写完了,开始重构前端页面,最终选择使用angular2来重构,其类似后端的写法以及typescript语法对js的修正使得其很容易上手.这周任务主要是在重构中熟悉angular的写法.到五月份的话不知道能不能重构完,尽力而为了.&lt;/p&gt;
&lt;p&gt;测试地址:  
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>redis学习记录(四)-SpringDataRedis分析</title>
    <link href="http://mrdear.cn/2017/03/29/linux/redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E5%9B%9B)-SpringDataRedis%E5%88%86%E6%9E%90/"/>
    <id>http://mrdear.cn/2017/03/29/linux/redis学习记录(四)-SpringDataRedis分析/</id>
    <published>2017-03-29T10:50:00.000Z</published>
    <updated>2017-03-30T01:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习记录-四-SpringDataRedis分析"><a href="#redis学习记录-四-SpringDataRedis分析" class="headerlink" title="redis学习记录(四)-SpringDataRedis分析"></a>redis学习记录(四)-SpringDataRedis分析</h1><p>标签（空格分隔）： redis</p>
<hr>
<p><a href="http://www.jianshu.com/p/da69edda2a43" target="_blank" rel="external">Redis学习记录(一)–入门知识</a><br><a href="http://www.jianshu.com/p/c3b8180af944p/da69edda2a43" target="_blank" rel="external">Redis学习记录(二)–使用Jedis连接</a><br><a href="http://mrdear.cn/2017/03/26/linux/redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%28%E4%B8%89%29-redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis学习记录(三)-redis中的数据结构</a></p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring Data Redis是对redis客户端(如jedis)的高度封装,支持多种客户端,因其高抽象,所以在某一个客户端不支持更新的时候可以容易切换到其他客户端.</p>
<p>本文是在Spring boot 1.5.2版本下测试.</p>
<p>需要引入架包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--spring boot start--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>在Spring Boot下默认使用jedis作为客户端,并在包<code>org.springframework.boot.autoconfigure.data.redis</code>下,提供自动配置类<code>RedisProperties</code>,<code>RedisAutoConfiguration</code>等.</p>
<p>根据<code>RedisProperties</code>可以定位到可配置的属性,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># Redis数据库索引（默认为0）</div><div class="line">spring.redis.database=0</div><div class="line"># Redis服务器地址</div><div class="line">spring.redis.host=115.159.185.14</div><div class="line"># Redis服务器连接端口</div><div class="line">spring.redis.port=6379</div><div class="line"># Redis服务器连接密码（默认为空）</div><div class="line">spring.redis.password=</div><div class="line"># 连接池最大连接数（使用负值表示没有限制）</div><div class="line">spring.redis.pool.max-active=8</div><div class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</div><div class="line">spring.redis.pool.max-wait=-1</div><div class="line"># 连接池中的最大空闲连接</div><div class="line">spring.redis.pool.max-idle=8</div><div class="line"># 连接池中的最小空闲连接</div><div class="line">spring.redis.pool.min-idle=0</div><div class="line"># 连接超时时间（毫秒）</div><div class="line">spring.redis.timeout=2000</div></pre></td></tr></table></figure></p>
<p>在application.properties中配置即可,另外还有<code>Sentinel</code>和<code>Cluster</code>说明支持分布式和集群,博主研究不多就不瞎说这个了.</p>
<p>自动配置主要在<code>RedisAutoConfiguration</code>中,该类会提供三个bean:</p>
<ol>
<li>JedisConnectionFactory : jedis连接控制工厂</li>
<li>RedisTemplate<object, object=""> : redis操作入口</object,></li>
<li>StringRedisTemplate : redis操作入口</li>
</ol>
<p>那么就开始入口学习.</p>
<hr>
<h3 id="3-RedisTemplate"><a href="#3-RedisTemplate" class="headerlink" title="3.RedisTemplate"></a>3.RedisTemplate<k, v=""></k,></h3><p>RedisTemplate是操作的入口.该类继承了<code>RedisAccessor</code>,可以通过其拿到redis连接,实现了<code>RedisOperations</code>接口,获得了操作redis的能力,如下图所示:<br><img src="http://ac-HSNl7zbI.clouddn.com/rUB5pG7qryosXsqkMNQ1u52FgHMVMwAX7OeVM3jy.jpg" alt=""></p>
<h4 id="3-1-Test-case"><a href="#3-1-Test-case" class="headerlink" title="3.1 Test case"></a>3.1 Test case</h4><p>那么具体操作过程是怎么样子的呢?写一个简单的测试去跟踪代码,如下代码,往redis中设置key为ping的字串.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span>(classes = Application.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConnectTest</span> </span>&#123;</div><div class="line">  <span class="meta">@Resource</span></div><div class="line">  <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSetAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">    redisTemplate.opsForValue().set(<span class="string">"ping"</span>,<span class="string">"pong"</span>);</div><div class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">"ping"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行之后查看redis数据库,你会发现很奇怪的事情,如下图,代码中存入的是ping,但是到redis中后却是一堆字符+ping,这个原因是什么呢?接着跟踪代码.<br><img src="http://ac-HSNl7zbI.clouddn.com/9O9oRCxhlph8oRYL6YirrY192jaYIOHAlGXAUemJ.jpg" alt=""></p>
<h4 id="3-2-XXXOperations"><a href="#3-2-XXXOperations" class="headerlink" title="3.2 XXXOperations"></a>3.2 XXXOperations<k, v=""></k,></h4><p>上述代码的第一步先获取到了<code>ValueOperations</code>,在<code>RedisTemplate</code>中同样还有其他<code>XXXOperations</code>,根据官方文档,这些接口是针对redis的每一种命令的操作.如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">接口</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ValueOperations</td>
<td style="text-align:left">Redis string (or value) operations</td>
</tr>
<tr>
<td style="text-align:left">ListOperations</td>
<td style="text-align:left">Redis list operations</td>
</tr>
<tr>
<td style="text-align:left">SetOperations</td>
<td style="text-align:left">Redis set operations</td>
</tr>
<tr>
<td style="text-align:left">ZSetOperations</td>
<td style="text-align:left">Redis zset (or sorted set) operations</td>
</tr>
<tr>
<td style="text-align:left">HashOperations</td>
<td style="text-align:left">Redis hash operations</td>
</tr>
<tr>
<td style="text-align:left">HyperLogLogOperations</td>
<td style="text-align:left">Redis HyperLogLog operations like (pfadd, pfcount,…​)</td>
</tr>
<tr>
<td style="text-align:left">GeoOperations</td>
<td style="text-align:left">Redis geospatial operations like GEOADD, GEORADIUS,…​)</td>
</tr>
<tr>
<td style="text-align:left">BoundValueOperations</td>
<td style="text-align:left">Redis string (or value) key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundListOperations</td>
<td style="text-align:left">Redis list key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundSetOperations</td>
<td style="text-align:left">Redis set key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundZSetOperations</td>
<td style="text-align:left">Redis zset (or sorted set) key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundHashOperations</td>
<td style="text-align:left">Redis hash key bound operations</td>
</tr>
<tr>
<td style="text-align:left">BoundGeoOperations</td>
<td style="text-align:left">Redis key bound geospatial operations.</td>
</tr>
</tbody>
</table>
<p>其中<code>BoundXXXOperations</code>是在key已知的情况下使用,其所有操作都是建立在有一个<code>certain key</code>的前提.可以看下源码就能明白了.</p>
<h4 id="3-3-XXXSerializer"><a href="#3-3-XXXSerializer" class="headerlink" title="3.3 XXXSerializer"></a>3.3 XXXSerializer</h4><p>那测试代码中第一步是获取了string类型的redis操作入口,然后执行set方法设置键和值,接着分析set方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = rawValue(value);</div><div class="line">	execute(<span class="keyword">new</span> ValueDeserializingRedisCallback(key) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</div><div class="line">			connection.set(rawKey, rawValue);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现<code>rawKey()</code>方法和<code>rawValue()</code>方法对key和value进行了一次序列化操作.该序列化使用的类为RedisTemplate中的<code>XXXSerializer</code>,那么回到RedisTemplate,在<code>afterPropertiesSet()</code>方法中有以下初始化方法,默认使用的序列化方式为<code>JdkSerializationRedisSerializer</code>,也就是ObjectInputStream和ObjectOutputStream写入和读取.这也是写入到redis中却在redis数据库通过”ping”访问不到的原因.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">			defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</div><div class="line">					classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (enableDefaultSerializer) &#123;</div><div class="line">			<span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				keySerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				valueSerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				hashKeySerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</div><div class="line">				hashValueSerializer = defaultSerializer;</div><div class="line">				defaultUsed = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>那么SpringDataRedis支持哪些序列化呢?从官网可以看到:<br>StringRedisSerializer: string类型序列化,也是最常用的类型<br>JdkSerializationRedisSerializer: jdk默认序列化<br>OxmSerializer : xml格式<br>JacksonJsonRedisSerializer : json格式</p>
<p>通过手动注入RedisTemplate,更改所选择的序列化方式.另外Spring提供了最常使用的<code>StringRedisTemplate</code>,实现了<code>StringRedisSerializer</code>序列化方式.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">	RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">	setKeySerializer(stringSerializer);</div><div class="line">	setValueSerializer(stringSerializer);</div><div class="line">	setHashKeySerializer(stringSerializer);</div><div class="line">	setHashValueSerializer(stringSerializer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更改成<code>StringRedisTemplate</code>,再次执行,正常了.<br><img src="http://ac-HSNl7zbI.clouddn.com/3PAtzJjJHXquNpAVgWJI0OVh8pJWDhVEl3FbD571.jpg" alt=""></p>
<h4 id="3-4-总结过程"><a href="#3-4-总结过程" class="headerlink" title="3.4 总结过程"></a>3.4 总结过程</h4><ol>
<li>获取RedisTemplate</li>
<li>获取操作入口XXXOperations</li>
<li>使用RedisSerializer序列化key和value</li>
<li>获取conn连接</li>
<li>执行命令</li>
</ol>
<h3 id="4-发布与订阅"><a href="#4-发布与订阅" class="headerlink" title="4.发布与订阅"></a>4.发布与订阅</h3><p>发布与订阅过程需要发布者,订阅者,以及把两者连在一起的桥梁.那么在SpringRedis中怎么实现呢?<br>订阅者:里面有一个处理方法即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listen</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Listen.class);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMsg</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">    logger.info(<span class="string">"reciver msg :"</span> + message);</div><div class="line">    latch.countDown();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getLatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> latch;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发布者:XXXRedisTemplate.convertAndSend(chanel,msg)即作为发布者存在.</p>
<p>连接桥梁:RedisMessageListenerContainer,该container监听Redis的消息,分发给各自的监听者.关键代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注入消息容器</div><div class="line">   * <span class="doctag">@param</span> jedisConnectionFactory jedis连接池</div><div class="line">   * <span class="doctag">@param</span> listenerAdapter 监听适配器</div><div class="line">   * <span class="doctag">@return</span> bean</div><div class="line">   */</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory jedisConnectionFactory,</span></span></div><div class="line">      MessageListenerAdapter listenerAdapter)&#123;</div><div class="line">    RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</div><div class="line">    container.setConnectionFactory(jedisConnectionFactory);</div><div class="line">    <span class="comment">//绑定监听者与信道的管理</span></div><div class="line">    container.addMessageListener(listenerAdapter,<span class="keyword">new</span> PatternTopic(<span class="string">"java"</span>));</div><div class="line">    <span class="keyword">return</span> container;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> MessageListenerAdapter <span class="title">adapter</span><span class="params">(Listen listen)</span></span>&#123;</div><div class="line">    <span class="comment">//指定监听者和监听方法</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(listen,<span class="string">"handleMsg"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPublish</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  stringRedisTemplate.convertAndSend(<span class="string">"java"</span>,<span class="string">"hello world"</span>);</div><div class="line">  listen.getLatch().await();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/yhidqhoWBD7Un7XLH6WQYjIEl82Ve0R2jzCEzMrn.jpg" alt=""></p>
<h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h3><p>对于事务的操作是通过SessionCallback实现,该接口保证其内部所有操作都是在同一个Session中的,在最后exec的时候执行全部操作.关键代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</div><div class="line">execute(<span class="keyword">this</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMulti</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> isThrow = <span class="keyword">false</span>;</div><div class="line">   List&lt;Object&gt; result = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     result = stringRedisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;List&lt;Object&gt;&gt;() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span></span></div><div class="line">           DataAccessException &#123;</div><div class="line">         operations.multi();</div><div class="line">         ValueOperations&lt;String,String&gt; ops = operations.opsForValue();</div><div class="line">         ops.set(<span class="string">"ping1"</span>,<span class="string">"pong1"</span>);</div><div class="line">         ops.set(<span class="string">"ping2"</span>,<span class="string">"pong2"</span>);</div><div class="line">         <span class="keyword">if</span> (isThrow)&#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"测试异常"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> operations.exec();</div><div class="line">       &#125;</div><div class="line">     &#125;);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">     e.printStackTrace();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   System.out.println(result);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="6-管道"><a href="#6-管道" class="headerlink" title="6.管道"></a>6.管道</h3><p>直接引用官方案例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pop a specified number of items from a queue</span></div><div class="line">List&lt;Object&gt; results = stringRedisTemplate.executePipelined(</div><div class="line">  <span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line">      StringRedisConnection stringRedisConn = (StringRedisConnection)connection;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; batchSize; i++) &#123;</div><div class="line">        stringRedisConn.rPop(<span class="string">"myqueue"</span>);</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>还有脚本执行等,在官方文档中都有案例,这里就不复制粘贴了,如有错误请指出,不胜感激.</p>
<p>参考文档:</p>
<p><a href="http://docs.spring.io/spring-data/redis/docs/1.8.1.RELEASE/reference/html/#redis:template" target="_blank" rel="external">http://docs.spring.io/spring-data/redis/docs/1.8.1.RELEASE/reference/html/#redis:template</a></p>
<p>github:</p>
<p><a href="https://github.com/nl101531/JavaWEB" target="_blank" rel="external">https://github.com/nl101531/JavaWEB</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis学习记录-四-SpringDataRedis分析&quot;&gt;&lt;a href=&quot;#redis学习记录-四-SpringDataRedis分析&quot; class=&quot;headerlink&quot; title=&quot;redis学习记录(四)-SpringDataRedis分析&quot;&gt;&lt;/
    
    </summary>
    
      <category term="redis" scheme="http://mrdear.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://mrdear.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习记录(三)-redis中的数据结构</title>
    <link href="http://mrdear.cn/2017/03/26/linux/redis%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://mrdear.cn/2017/03/26/linux/redis学习记录(三)-redis中的数据结构/</id>
    <published>2017-03-26T13:50:00.000Z</published>
    <updated>2017-03-27T14:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习记录-三-redis中的数据结构"><a href="#redis学习记录-三-redis中的数据结构" class="headerlink" title="redis学习记录(三)-redis中的数据结构"></a>redis学习记录(三)-redis中的数据结构</h1><p>标签（空格分隔）： redis</p>
<hr>
<p><a href="http://www.jianshu.com/p/da69edda2a43" target="_blank" rel="external">Redis学习记录(一)–入门知识</a>o<br><a href="http://www.jianshu.com/p/c3b8180af944p/da69edda2a43" target="_blank" rel="external">Redis学习记录(二)–使用Jedis连接</a></p>
<p>redis有五种数据类型,string,list,set,hash,sort set,不同场景使用不同数据结构的前提是了解每一种数据结构.那么结构图片是最佳的了解方式,图片来自慕课网.</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是的key-&gt;value类型的存储,可以存储字符串类型和数值类型,可对数值类型是可以增加减少,对string类型可以追加内容.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/FLiCD6qvq5cgURt9pK4GsmHAfikXMkTaTk0jH42D.jpg" alt=""></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是列表,也就是一个key-&gt;多个value,可以支持双端队列,栈来操作,因此越靠近两端其查找速度越快,端点的复杂度查找为O(1),同时队列有阻塞操作,也就是可以当成阻塞队列使用.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/C66VGUQUQU36HG1VirdktiwGCsuch427TKeM9Mx8.jpg" alt=""></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set为无序,且不重复的集合,且提供O(1)复杂度度的快速查找.set集合支持集合的并,交,差操作,因为无序性,因此也提供迭代方法.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/eYnj2QzNgnS3IxzfR74ODXYREXCAwLrFAqmNCvDD.jpg" alt=""></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash类型适合存储对象,相比前面的string,所带来的优势是可以使用一个key查出该下面所有的键值对,并且可以单独对某一属性更改,如图所示:</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/9EqPsIkU1iQeoMzRBYGGIEIPYvpQarWbgyADBehR.jpg" alt=""></p>
<h3 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h3><p>可排序的集合,如图所示存在score排名分数,隐藏属性rank排名,0为最小.注意对sort set来说value是唯一性的,而不是score,如果两个score相同,则按照value的字典序排序.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/3TBmsR4b8tGDoUvX3tlo1pHMuTTDnJOXAT5H0S9g.jpg" alt=""></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h4><p>计数器:redis的incr操作是原子性的,因此可以应对高并发,如网站要求每个用户获取验证码后60秒内不得再次获取,那么第一次获取的时候用incr给该用户设置key,过期时间为60秒,如果结果等于1则为第一次请求,那么第二次获取时比较决定是否操作频繁.</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>list的优势的有序性,两端插入复杂度为O(1),那么对于<strong>最近文章列表</strong>等类似需求是最佳解决方案,维护一个定长的列表,每次插入后执行trim操作.</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>set的优势是唯一性,O(1)的查找查找复杂度,并且支持差并集,那么二度好友问题就迎刃而解了.</p>
<h4 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h4><p>hash非常适合存储对象,不同的键为对象的特征,值为特征值,那么比string好的就是修改不需要每次都修改一个整串,而可以选择修改某一指定键值.</p>
<h4 id="sort-set-1"><a href="#sort-set-1" class="headerlink" title="sort set"></a>sort set</h4><p>sort set可排序特性使其很容易解决排行榜类应用,但是要注意值需要存储不变的属性,因为值要求唯一性,score可不唯一.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis学习记录-三-redis中的数据结构&quot;&gt;&lt;a href=&quot;#redis学习记录-三-redis中的数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis学习记录(三)-redis中的数据结构&quot;&gt;&lt;/a&gt;redis学习记录(三)-red
    
    </summary>
    
      <category term="redis" scheme="http://mrdear.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://mrdear.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(三)</title>
    <link href="http://mrdear.cn/2017/03/25/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://mrdear.cn/2017/03/25/毕业设计/毕业设计周记(三)/</id>
    <published>2017-03-25T13:50:00.000Z</published>
    <updated>2017-03-26T13:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>3.26更新</strong><br>周末把竞赛支持也写好了,但是总觉得和自己想要的不太一样了,前端太乏力,因此下周开始重构前端,采用VUE写成一个单页逻辑应用.希望不会耽误太多时间.</p>
<hr>
<p>花了一下午的时间把服务器重装了,所有实例包括mysql,redis,nginx都跑在docker中,项目也是跑在docker中,目前来看效果很不错,对服务器的利用率比之前高太多了.</p>
<p>部署的OJ漏洞挺多的,体验上也没怎么优化,尤其是注册流程,问题多多,接下来要优化代码,优化这个流程.</p>
<p>竞赛方面的支持,因为上周公司出了几个大活动,一直比较忙,而没去做,本周也继续做竞赛方面支持.</p>
<p>因此目前进度:</p>
<ol>
<li>服务器部署全部docker化</li>
<li>线上可以直接判题</li>
</ol>
<p>测试地址:  <a href="http://oj.mrdear.cn/" target="_blank" rel="external">http://oj.mrdear.cn/</a>    服务器比价渣,速度比较慢</p>
<p>测试账号:   1015315668@qq.com    密码: 111111</p>
<p>等待完成:</p>
<p>1.竞赛的支持<br>2.注册流程优化</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;3.26更新&lt;/strong&gt;&lt;br&gt;周末把竞赛支持也写好了,但是总觉得和自己想要的不太一样了,前端太乏力,因此下周开始重构前端,采用VUE写成一个单页逻辑应用.希望不会耽误太多时间.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;花了一下午的时间把服务器重装了,所有实例包括my
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ERP叛逃者(转)</title>
    <link href="http://mrdear.cn/2017/03/19/%E9%9A%8F%E8%B0%88/ERP%E5%8F%9B%E9%80%83%E8%80%85/"/>
    <id>http://mrdear.cn/2017/03/19/随谈/ERP叛逃者/</id>
    <published>2017-03-19T10:21:00.000Z</published>
    <updated>2017-03-19T10:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ERP叛逃者-转"><a href="#ERP叛逃者-转" class="headerlink" title="ERP叛逃者(转)"></a>ERP叛逃者(转)</h1><p>标签（空格分隔）： 随谈</p>
<hr>
<blockquote>
<p>作者:alswl<br>原文链接:<a href="https://blog.alswl.com/2011/04/erp-defectors/" target="_blank" rel="external">https://blog.alswl.com/2011/04/erp-defectors/</a></p>
</blockquote>
<p>一篇对于毕业生很有指导意义的文章,踏入职场,面临的第一个选择就是工作,第一份工作可能并不如你所期望的那样,那么你真正想要什么呢?文章会给你答案.</p>
<hr>
<p>大四实习时候，跑去驻厂开发，当时主管跟我说”我们做的是企业信息化软件”。毕业之后找工作，进入一家国内还算有名的ERP公司，做ERPII产品（CRM/工作流/ 电子商务平台等ERP软件附属产品）的开发和二次开发。</p>
<p>在这一年半的时间里，我学习了一些行业知识，熟悉了公司自己的开发模式、框架和工具。浑浑噩噩的直到某一天，我发现我写代码没有键盘飞扬的感觉。我惶恐，我感觉我遇到 瓶颈停止成长了。我开始思索我这种状况的产生，我重新翻开曾经看的糊里糊涂的《人月神话》，研读阿朱的《走出软件作坊》，尝试找到问题和解决办法。</p>
<p>我回想我工作之后做的事情：我负责的是从顾问那里拿到伪SQL+伪代码，然后将它们在公司的框架上面实现起来，再手工完成功能性测试。我做一个极端的假设：如果早50 年，ERP公司给用户提供解决方案可以是在纸上提出，根本不需要电脑。所以ERP的本质是对业务的梳理，规范化的引导，让企业高效整合资源充分发挥产能的公司。这与我 想象的IT公司完全不一样，我所希望的IT公司能够追求极致，创造用户喜欢的，快速响应用户需求，扩展性强的产品。如果具备这些元素，会很快被同类公司超越。</p>
<p>可是公司立足于市场近30年，绝对不是这么不堪，她有自己的核心竞争力：标准的业务流程，强大的顾问和实施团队，本土化的产品。</p>
<p>我比较了知名互联网公司、创业型IT公司和传统管理软件行业的区别，惊讶的发现，原来，计算机科学与技术专业毕业的我，不在IT公司，在一家服务咨询公司！！！我把这 个想法和主管进行交流，主管也认同我们提供的是service而不是soft。</p>
<p>我简单比较了互联网企业和传统行业软件企业的差异。</p>
<h3 id="目标人群不一样"><a href="#目标人群不一样" class="headerlink" title="目标人群不一样"></a>目标人群不一样</h3><p>行业软件：企业用户</p>
<p>互联网产品：个人用户更多，也有企业用户</p>
<p>由于给企业用户进行定制，导致内部封闭现象严重，更新周期漫长。另外，企业用户可以强制要求用户使用某种操作方式或者某种环境，比如我就是要让你用IE6，你不用IE 6系统出现问题，那是你的原因。而互联网产品就面对所有网民，必须考虑到标准问题。</p>
<p>另外，企业用户更换系统平台频率低，系统一旦投入使用，需要经过几年的使用，才会可能考虑更换，其依赖性比互联网产品高出个数量级。由于互联网的开放性，互联网用户很 容易在不同产品之间进行更换。</p>
<h3 id="盈利点不一样"><a href="#盈利点不一样" class="headerlink" title="盈利点不一样"></a>盈利点不一样</h3><p>互联网：吸引用户使用，所以用户体验，速度是需要考虑的，依赖用户使用情况（VIP制度、广告收入）盈利。</p>
<p>行业软件：卖给产品和服务给用户，功能符合用户需要，顾问实施精准，依赖销售产品+服务盈利。</p>
<p>盈利点造成行业软件未必会把用户体验、速度这些相对次要的问题放在首位考虑，而是考虑先解决实际问题，满足用户需要。</p>
<h3 id="核心竞争力"><a href="#核心竞争力" class="headerlink" title="核心竞争力"></a>核心竞争力</h3><p>行业软件最依赖的核心竞争力是对某个行业的了解，比如阿朱所在的明源专注于房地产，金蝶用友各有所擅长的行业。并不是他们不想在别的行业挣钱，而是对应行业的顾问极难 培养（行业/领域专家）。</p>
<p>互联网产品的核心竞争力就更多样化，Web2.0时代可以是用户关系，用户基数（腾讯，现在的人人），也可以是某一款特别大众需要的产品（淘宝，搜索引擎，书签服务） ，又或是核心技术（Google），这些核心竞争力会在发展过程中相互转换，相互渗透。</p>
<p>互联网产品的特性是快，这个快是表象，本质是在于互联网产品要充分挖掘用户需求，不断满足现有要求，并预测引领用户需求趋势，这也是创新精神具体体现。由于同质化严重 ，竞争白热化，导致互联网产品纷纷涌现，给人一种爆炸的感觉。其实，一款好的互联网产品从有创意到磨砺成熟，是需要经过一段还算长的时间的。（除非是搞搞微创新，大家 都知道怎么做，没什么核心竞争力，只是拼模拟速度了）</p>
<p>我在想清楚这些之后，发现ERP不是我的归宿，互联网才是我追寻的方向。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ERP叛逃者-转&quot;&gt;&lt;a href=&quot;#ERP叛逃者-转&quot; class=&quot;headerlink&quot; title=&quot;ERP叛逃者(转)&quot;&gt;&lt;/a&gt;ERP叛逃者(转)&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 随谈&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;作者:als
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="选择" scheme="http://mrdear.cn/tags/%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(二)</title>
    <link href="http://mrdear.cn/2017/03/18/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://mrdear.cn/2017/03/18/毕业设计/毕业设计周记(二)/</id>
    <published>2017-03-18T14:50:00.000Z</published>
    <updated>2017-03-18T14:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周学习docker之后,建立起docker的判题环境,目前已成功判题,前端部分也打通.目前支持语言C,C++,Java,后续会添加更多语言支持.接下来的任务是整理代码,重构部分逻辑代码,还有竞赛判题的支持.预计下周完成.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/M4V64IgxeMaWtWlUVumAWBvLrUh9VBT1rfWnLuKF.jpg" alt=""></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/Yd4SAenh4N3THhsau4GxNdxKE4XnpiTRqfsvhpkk.jpg" alt=""></p>
<p>因此目前进度:</p>
<ol>
<li>WEB端和Judge端打通,近期部署到自己的服务器上,以便展示.</li>
</ol>
<p>等待完成:</p>
<p>1.竞赛的支持<br>2.代码重构,一些体验上的逻辑优化</p>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周学习docker之后,建立起docker的判题环境,目前已成功判题,前端部分也打通.目前支持语言C,C++,Java,后续会添加更多语言支持.接下来的任务是整理代码,重构部分逻辑代码,还有竞赛判题的支持.预计下周完成.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://a
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>动漫推荐</title>
    <link href="http://mrdear.cn/2017/03/18/%E5%8A%A8%E6%BC%AB/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"/>
    <id>http://mrdear.cn/2017/03/18/动漫/动漫推荐/</id>
    <published>2017-03-18T03:21:00.000Z</published>
    <updated>2017-04-02T03:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动漫推荐"><a href="#动漫推荐" class="headerlink" title="动漫推荐"></a>动漫推荐</h1><p>标签（空格分隔）： 动漫</p>
<hr>
<p>从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典动漫剧场版.我也不知道自己是什么风格的动漫迷,只是觉得好看,有共鸣就认为是好作品.人们总是把自己喜爱的东西推荐给别人,我也不例外,下面推荐我认为很不错的片子.(排名不分先后)</p>
<h3 id="异邦人-无皇刃谭"><a href="#异邦人-无皇刃谭" class="headerlink" title="异邦人 无皇刃谭"></a>异邦人 无皇刃谭</h3><p>2017年初来在上海实习时看的,故事很温情,对于刚到一个陌生城市打拼的青年来说很容易引起共鸣,也因此我感触颇深,异邦人都是孤独的存在,内心是挣扎的,想要找到自己的归属,然而哪里才是归属?背景音乐很赞,听起来内心有点温暖,但是又会觉得很伤感,充满了无奈</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=508793&auto=0&height=66"></iframe>

<h3 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h3><p>大概高一的时候第一次看了这个作品,唯美的画面,伤感的故事,再加上年少懵懂的恋爱经历,从此新海诚一生粉.回想以前是不是很多事情都可以 <code>One more time,One more chance</code></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=540968&auto=0&height=66"></iframe>

<h3 id="你看起来很好吃"><a href="#你看起来很好吃" class="headerlink" title="你看起来很好吃"></a>你看起来很好吃</h3><p>相当有趣的一部动漫,看起来完全没有负重感,从母爱,父爱,独立,自强等方面诠释了一个龙的成长.电影版是温情的结局,萌萌的画面,治愈的故事,给心情带来不一样的体验.<br>记住:哭闹的孩子 不管在哪里都会被霸王龙叼走</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=795251922&auto=0&height=66"></iframe>

<h3 id="萤火之森"><a href="#萤火之森" class="headerlink" title="萤火之森"></a>萤火之森</h3><p>无法触碰的爱情,只是梦中的憧憬,这样的动漫是提醒你,在你年轻的时候曾经心里也住着一个无法触碰的他/她.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=541381&auto=0&height=66"></iframe>

<h3 id="fate-stay-night"><a href="#fate-stay-night" class="headerlink" title="fate stay night"></a>fate stay night</h3><p>作为番剧来说最喜欢的一个系列,fate stay night也是最早出来的一部,配乐,战斗,剧情都那么引人入胜,虽然fate zero也非常不错,但是让我来选择的话还是该部更让我难忘.</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=448119&auto=0&height=66"></iframe>




]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动漫推荐&quot;&gt;&lt;a href=&quot;#动漫推荐&quot; class=&quot;headerlink&quot; title=&quot;动漫推荐&quot;&gt;&lt;/a&gt;动漫推荐&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 动漫&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典
    
    </summary>
    
      <category term="动漫" scheme="http://mrdear.cn/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://mrdear.cn/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习记录(三)-构建非跨平台项目编译环境</title>
    <link href="http://mrdear.cn/2017/03/12/docker/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-%E6%9E%84%E5%BB%BA%E9%9D%9E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://mrdear.cn/2017/03/12/docker/Docker学习记录(三)-构建非跨平台项目编译环境/</id>
    <published>2017-03-12T07:21:00.000Z</published>
    <updated>2017-04-02T02:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录-三-构建非跨平台项目编译环境"><a href="#Docker学习记录-三-构建非跨平台项目编译环境" class="headerlink" title="Docker学习记录(三)-构建非跨平台项目编译环境"></a>Docker学习记录(三)-构建非跨平台项目编译环境</h1><p>标签（空格分隔）： docker</p>
<hr>
<blockquote>
<p>个人独立博客: <a href="http://mrdear.cn">http://mrdear.cn</a></p>
</blockquote>
<p>因为毕业设计的问题所以去学了docker,本文描述这个问题解决的过程.</p>
<hr>
<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>在毕业设计AUSTOJ中,判题端使用JNI方式调用C++来编译和执行代码,得到输出结果,Java端进行结果对比.然而该C++代码在mac下无法编译,总是会报错,JNI也会出问题.另外该子模块在mac下无法使用maven打包,所以打包也需要放在docker中.<br>因此docker需要环境 java maven gcc g++ make</p>
<h2 id="2-构建编译环境"><a href="#2-构建编译环境" class="headerlink" title="2.构建编译环境"></a>2.构建编译环境</h2><p>编写dockerfile文件,该文件的maven包我是从本机复制进去的,同样你也可以从外网下载.<br>Dockerfile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#构建judger端需要的环境,方便本地测试</div><div class="line">#基于java8环境</div><div class="line">FROM java:8</div><div class="line"></div><div class="line">#维护人信息</div><div class="line">MAINTAINER quding niudear@foxmail.com</div><div class="line">#更新源</div><div class="line">RUN apt-get update</div><div class="line">#gcc g++ make安装</div><div class="line">RUN apt-get install -y gcc-4.9</div><div class="line">RUN apt-get install -y g++-4.9</div><div class="line">RUN apt-get install -y build-essential</div><div class="line"></div><div class="line">#配置mvn环境</div><div class="line">ADD apache-maven-3.3.9.tar.gz /usr/local</div><div class="line">ENV M2_HOME /usr/local/apache-maven-3.3.9</div><div class="line">ENV PATH $PATH:$JAVA_HOME/bin:$M2_HOME/bin</div><div class="line"></div><div class="line">#jni环境</div><div class="line">RUN cp $JAVA_HOME/include/linux/jawt_md.h $JAVA_HOME/include/</div><div class="line">RUN cp $JAVA_HOME/include/linux/jni_md.h $JAVA_HOME/include/</div></pre></td></tr></table></figure></p>
<p>构建命令:<br><code>docker build -t dev .</code></p>
<h2 id="3-挂载运行"><a href="#3-挂载运行" class="headerlink" title="3.挂载运行"></a>3.挂载运行</h2><p>运行时需要挂载本项目到docker中,该挂载是映射,因此本地和docker任意位置改变项目中文件都会反映在真实项目中,这也是想要的结果.<br>挂载命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -ti -p 50013:50013  -v /Users/niuli/workspace/git/AUSTOJ2/:/AUSTOJ2 </div><div class="line">-v /Users/niuli/workspace/git/testcase/:/austoj/testcase dev</div></pre></td></tr></table></figure></p>
<p>该命令以交互模式启动一个docker容器,同时绑定docker的50013端口到此容器的50013,因为我的项目使用的是50013端口.另外我挂载了本项目目录AUSTOJ2和测试数据目录分别到docker的/AUSTOJ2目录和/austoj/testcase目录.</p>
<p>那么启动之后如下所示:<br><img src="http://ac-HSNl7zbI.clouddn.com/sVRm9T6RaAgcL0tqAX7vGz0kaTVDT21kJbSSokIA.jpg" alt=""></p>
<p>ok,到此编译环境搞定,可以随心所欲的编译启动该子模块,并且还能实时反映到本机目录下</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/y020GeCL2UrSuASyDaYbvWs0XF3LWRYqRbej5pAB.jpg" alt=""></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/bOKHInF9SpgHTSmr361EhU2geUFRjKW1yPwHap6s.jpg" alt=""></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/JXVXNAq7Q6JtPc9QhKzJAdu1h3HskLriYhruA1tY.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker学习记录-三-构建非跨平台项目编译环境&quot;&gt;&lt;a href=&quot;#Docker学习记录-三-构建非跨平台项目编译环境&quot; class=&quot;headerlink&quot; title=&quot;Docker学习记录(三)-构建非跨平台项目编译环境&quot;&gt;&lt;/a&gt;Docker学习记录
    
    </summary>
    
      <category term="docker" scheme="http://mrdear.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="http://mrdear.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习记录(二)-Dockerfile创建镜像</title>
    <link href="http://mrdear.cn/2017/03/10/docker/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)-Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <id>http://mrdear.cn/2017/03/10/docker/Docker学习记录(二)-Dockerfile创建镜像/</id>
    <published>2017-03-10T13:21:00.000Z</published>
    <updated>2017-04-02T02:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录-二-Dockerfile创建镜像"><a href="#Docker学习记录-二-Dockerfile创建镜像" class="headerlink" title="Docker学习记录(二)-Dockerfile创建镜像"></a>Docker学习记录(二)-Dockerfile创建镜像</h1><p>标签（空格分隔）： docker</p>
<hr>
<p>本文学习Dcokerfile的基本命令,并且创建一个支持ssh服务的镜像.</p>
<hr>
<h2 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h2><h3 id="1-1基本案例"><a href="#1-1基本案例" class="headerlink" title="1.1基本案例"></a>1.1基本案例</h3><p>dockerfile可以说是docker的描述符,该文件定义了docker镜像的所能拥有哪些东西.基本格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">第一行指定该镜像基于的基础镜像(必须)</div><div class="line">FROM java:8</div><div class="line"></div><div class="line">维护者信息</div><div class="line">MAINTAINER quding  niudear@foxmail.com</div><div class="line"></div><div class="line">镜像操作指令</div><div class="line">RUN echo $JAVA_HOME</div><div class="line"></div><div class="line">启动时操作的命令</div><div class="line"></div><div class="line">CMD ./usr/sbin/nginx</div></pre></td></tr></table></figure></p>
<p>该文件说明从Java8这个基础镜像创建一个新的镜像,输出Java路径,启动成功则启动nginx服务,这也是一个Dockerfile需要包含的操作步骤.</p>
<h3 id="1-2指令详解"><a href="#1-2指令详解" class="headerlink" title="1.2指令详解"></a>1.2指令详解</h3><p><strong>1.FROM</strong>：格式为 <code>FROM &lt;image&gt;</code>或<code>FROM&lt;image&gt;:&lt;tag&gt;</code>第一条指令必须是FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。</p>
<p><strong>2.MAINTAINER</strong>：格式为MAINTAIER<name>，指定维护者信息。</name></p>
<p><strong>3.RUN</strong>：格式为<code>RUN &lt;command&gt;</code>或者<code>RUN [“executable”，“param1”，“param2”]</code>。前者将在shell终端中运行的命令，即/bin/sh–c；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现，例如<code>RUN[“/bin/bash”，“-c”，“echohello”]</code>。每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\来换行。这实际上就是在容器构建时需要执行哪些指令，例如容器构建时需要下拉代码，但是默认启动的容器中是没有Git指令的，就需要下载，可以执行：<code>RUN apt-get install -y git</code>，然后<code>RUN git clonexxxx</code></p>
<p><strong>4.CMD</strong>：指定容器启动后执行的命令<br>命令格式为:<br>sh格式: CMD &lt;命令&gt;<br>exec格式:CMD [“可执行文件”,”参数1”,”参数2”]<br>一般都是早就写好的脚本或者启动一个服务，例如：<code>CMD[“/run.sh”]</code>。注意：如果Dockerfile中指定了多条命令，只有最后一条会被执行。如果用户启动时候加了运行的命令，则会覆盖掉CMD指定的指令。</p>
<p>这里有一个问题,很多时候我们想要docker一直在后台运行,但是往往docker启动后就停止.原因就在于此.<br>比如执行<code>CMD serice mysql start</code>,那么翻译过来的话是<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;serice mysql start&quot;]</code>,那么对于docker来说CMD主进程为sh,那么sh执行完该命令就结束,所以导致docker停止.所以要改成直接启动文件形式<code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;&quot;daemon off;]</code>,指定前台运行.</p>
<p><strong>5.EXPOSE</strong>：告诉Docker服务端容器需要暴露的端口号，供互联系统使用。在启动容器时需要通过-P（注意是大写），Docker主机会自动分配一个端口转发到指定的端口；使用-p，则可以具体指定哪个本地端口映射过来。<br>例如：我在elasticsearch镜像的Dockerfile中指定了暴露出9200和9300端口，我可以在Dockerfile中写：<code>EXPOSE 9200 9300</code></p>
<p><strong>6.ENV</strong>：创建的时候给容器中加上个需要的环境变量。指定一个值，为后续的RUN指令服务</p>
<p><strong>7.COPY</strong>：复制本地的文件或目录到容器中。目标路径不存在时，会自动创建。</p>
<p><strong>8.ENTRYPOINT</strong>：配置容器启动后执行的命令，并且不可被docker run 提供的参数覆盖。<br>每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效</p>
<p><strong>9.VOLUME</strong>：创建一个挂在点，可以从本机或其他容器挂载的挂载点。意思就是从容器中暴露出一部分，和外界共享这块东西，一般放数据库的数据或者是代码。在容器启动运行的时候，如果需要将volume暴露的东西和本地的一个文件夹进行映射，想要通过本地文件直接访问容器中暴露的部分，可以在运行的时候进行映射：</p>
<p><strong>10.USER</strong>：指定运行容器时的用户名或者UID，后续的RUN也会使用指定的用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。<br>要临时获取管理员权限的时候要使用gosu，不推荐使用sudo。如果不指定，容器默认是root运行。</p>
<p><strong>11.WORKDIR</strong>：定义工作目录，如果容器中没有此目录，会自动创建</p>
<p>创建指令<code>docker build 路径</code>,该命令会读取路径下的Dockerfile文件和其他文件,然后发送给服务端,由服务端创建镜像.</p>
<hr>
<h2 id="2-创建SSH服务镜像"><a href="#2-创建SSH服务镜像" class="headerlink" title="2.创建SSH服务镜像"></a>2.创建SSH服务镜像</h2><h3 id="2-1准备Java8环境"><a href="#2-1准备Java8环境" class="headerlink" title="2.1准备Java8环境"></a>2.1准备Java8环境</h3><p>后续教程需要利用到Java8环境,因此先下载一个官方的Java8镜像作为基础镜像.直接执行如下命令.可以利用之前的教程,启动容器查看下java路径.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull java:8</div></pre></td></tr></table></figure></p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/sJUUIIhnu1bxyfWnYtf8VfN7W3z5NMMj7lARWGpw.jpg" alt=""></p>
<h3 id="2-2编写Dockerfile"><a href="#2-2编写Dockerfile" class="headerlink" title="2.2编写Dockerfile"></a>2.2编写Dockerfile</h3><p>ssh服务主要是openssh-server来提供,因此需要在容器中安装该服务.<br><strong>Dockerfile:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#显示该镜像是基于java8镜像</div><div class="line">FROM java:8</div><div class="line"></div><div class="line">#维护人信息</div><div class="line">MAINTAINER quding niudear@foxmail.com</div><div class="line">#更新源</div><div class="line">RUN apt-get update</div><div class="line">#安装软件</div><div class="line">RUN apt-get install -y openssh-server</div><div class="line"></div><div class="line">RUN mkdir -p /var/run/sshd</div><div class="line">RUN mkdir -p /root/.ssh</div><div class="line"></div><div class="line">#取消pam限制</div><div class="line">RUN sed -ri &apos;s/session  required   pam_loginuid.so/#session    required  pam_loginuid.so/g&apos; /etc/pam.d/sshd</div><div class="line"></div><div class="line">#复制配置文件到相应位置</div><div class="line">COPY authorized_keys /root/.ssh/authorized_keys</div><div class="line">COPY run.sh /run.sh</div><div class="line"></div><div class="line">#赋予脚本权限</div><div class="line">RUN chmod 755 /run.sh</div><div class="line"></div><div class="line">#开放端口</div><div class="line">EXPOSE 22</div><div class="line"></div><div class="line">#设置启动命令</div><div class="line"></div><div class="line">CMD [&quot;/run.sh&quot;]</div></pre></td></tr></table></figure></p>
<p><strong>run.sh</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">/usr/sbin/sshd -D</div></pre></td></tr></table></figure></p>
<p><strong>拷贝本机的id_ras</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat ~/.ssh/id_rsa.pub &gt;authorized_keys</div><div class="line">//用来免密的</div></pre></td></tr></table></figure></p>
<p><strong>执行构建</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t sshd:java .</div></pre></td></tr></table></figure></p>
<p>构建成功后使用<code>docker images</code>即可查看,然后像上篇一样启动容器,暴露出端口,再使用ssh连接,和一般linux系统就没什么差别了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker学习记录-二-Dockerfile创建镜像&quot;&gt;&lt;a href=&quot;#Docker学习记录-二-Dockerfile创建镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker学习记录(二)-Dockerfile创建镜像&quot;&gt;&lt;/a&gt;Dock
    
    </summary>
    
      <category term="docker" scheme="http://mrdear.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="http://mrdear.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习记录(一)-基本概念</title>
    <link href="http://mrdear.cn/2017/03/10/docker/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://mrdear.cn/2017/03/10/docker/Docker学习记录(一)-基本概念/</id>
    <published>2017-03-10T09:21:00.000Z</published>
    <updated>2017-04-02T02:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录-一-基本概念"><a href="#Docker学习记录-一-基本概念" class="headerlink" title="Docker学习记录(一)-基本概念"></a>Docker学习记录(一)-基本概念</h1><p>标签（空格分隔）： docker</p>
<hr>
<p>因为做的项目用到了docker,所以开始学习下这方面的知识.</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>docker虚拟机:docker环境,docker的操作都要依赖此虚拟机,可以理解为JDK.<br>docker镜像:镜像可以用面向对象中的Model类来理解,就是一个已经建立好的模型.<br>docker容器:容器可以关联面向对象中的实例来理解,实例是依赖类来创建,所以容器就是依赖镜像创建,同样一个类可以有多个实例,那么一个镜像也可以对应多个容器.<br>docker仓库:仓库是镜像市场,里面有别人建立好的Model类,也就是镜像,可以直接拿来使用.</p>
<p>这样说应该很好理解了吧.</p>
<p>因此创建一个helloworld的流程就和清晰了.<br>启动docker虚拟机-&gt;创建docker镜像(或者从仓库拉取)-&gt;创建docker容器(运行helloworld)-&gt;结束</p>
<h2 id="2-docker虚拟机"><a href="#2-docker虚拟机" class="headerlink" title="2.docker虚拟机"></a>2.docker虚拟机</h2><p>首先docker安装后自带的虚拟机配置下载镜像又要GFW的原因速度很慢,一般使用<a href="https://cr.console.aliyun.com" target="_blank" rel="external">阿里云加速器</a>,登陆后找到加速器按照要求先创建一个新的docker主机,然后启动该主机.<br>这里要注意,阿里云给的命令是创建一个名字为default的主机,安装后自带了一个default,所以先运行<code>docker-machine rm default</code>删除默认主机.</p>
<p>2.1新建主机<br><img src="http://ac-HSNl7zbI.clouddn.com/sAxM3IuAIRznxVzOKQUSSmnVuh4KGub9bNLDN9P3.jpg" alt=""></p>
<p>2.2为当前shell配置环境<br><img src="http://ac-HSNl7zbI.clouddn.com/AK0TxhfaoaaJgUR6XLDAxWoiml1uNr5aEPyhOHkn.jpg" alt=""></p>
<p>2.3验证<br><img src="http://ac-HSNl7zbI.clouddn.com/BgvivpB6bjf61IBPyswjjHCb5XfcYjvrpOS9sDNo.jpg" alt=""></p>
<p>到此docker虚拟机创建完毕,这里需要掌握一些基本增删改查基本命令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">docker-machine kill 停止某个Docker主机</div><div class="line">docker-machine ls 列出所有管理的Docker主机</div><div class="line">docker-machine regenerate-certs 为某个主机重新成功TLS认证信息</div><div class="line">docker-machine restart 重启Docker主机</div><div class="line">docker-machine rm 删除Docker主机</div><div class="line">docker-machine scp 在Docker主机之间复制文件</div><div class="line">docker-machine ssh SSH到主机上执行命令</div><div class="line">docker-machine start 启动一个主机</div><div class="line">docker-machine status 查看一个主机状态</div><div class="line">docker-machine stop 停止一个主机</div><div class="line">docker-machine upgrade 更新主机Docker版本为最新</div><div class="line">docker-machine url 获取主机的URL</div></pre></td></tr></table></figure></p>
<h2 id="3-docker镜像"><a href="#3-docker镜像" class="headerlink" title="3.docker镜像"></a>3.docker镜像</h2><p>使用<code>docker images</code>可以列出机器上所有的docker镜像.<br><img src="http://ac-HSNl7zbI.clouddn.com/axr3cW667D3Awsul4QA0qnVlrx2OYsRz0QJel6yG.jpg" alt=""></p>
<p>其中:<br>REPOSTITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小</p>
<p>使用<code>docker search 镜像名</code>查找某一镜像,例如查找hello world,可以看到带有OFFICIAL的为官方提供的镜像.<br><img src="http://ac-HSNl7zbI.clouddn.com/LGnffJHC3CQIrxAMdBqUr6YXQf4s4CRiMLkhzwzY.jpg" alt=""></p>
<p>使用<code>docker pull 镜像名</code>获取一个镜像,这里获取hello world,另外镜像后可以跟版本号,例如<code>docker pull redis:3.2</code>,就指定拉去redis3.2版本<br><img src="http://ac-HSNl7zbI.clouddn.com/pGDCyoQUkK3vnLXFRasOUzpDyLFbprXFTghVbzLf.jpg" alt=""></p>
<p>使用<code>docker run 镜像名</code>从该镜像启动一个实例.</p>
<p>常见命令,另外对于docker镜像的创建和运行比较重要,后续文章单独学习分析.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker inspect 查看镜像详情</div><div class="line">docker rmi 删除镜像,带上-f参数则强制删除</div><div class="line">docker save 导出镜像</div><div class="line">docker load 导入镜像</div><div class="line">docker push 上传镜像到仓库</div><div class="line">docker tag 给镜像设置标签</div></pre></td></tr></table></figure></p>
<h2 id="4-docker容器"><a href="#4-docker容器" class="headerlink" title="4.docker容器"></a>4.docker容器</h2><p>容器是应用的实例,使用<code>docker create</code>创建一个容器,使用<code>docker start</code>启动一个容器,另一个简单方式就是<code>docker run</code>,等价于先创建再启动.</p>
<p>那么使用<code>docker run</code>的时候后台做了哪些操作?</p>
<ol>
<li>查找是否存在指定镜像,不存在则从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统,在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接到容器中去</li>
<li>从地址池配置一个ip地址给容器</li>
<li>执行用户指定应用程序</li>
<li>执行完毕后容器被终止</li>
</ol>
<p>使用<code>docker ps -a</code>查看最近启动的容器<br><img src="http://ac-HSNl7zbI.clouddn.com/aYGJha5vP2SwSQUEHtlNmRBU67vXS8co5KTCMO75.jpg" alt=""></p>
<p>使用<code>docker rm</code>删除容器,清理完毕后再删除hello world镜像.</p>
<p>下面使用redis镜像实战整个流程,并学习容器常用命令.</p>
<h2 id="5-创建redis镜像"><a href="#5-创建redis镜像" class="headerlink" title="5.创建redis镜像"></a>5.创建redis镜像</h2><p>有了helloworld经历,这里流程就很清晰了,搜索镜像-&gt;拉去镜像-&gt;创建实例-&gt;连接交互<br><img src="http://ac-HSNl7zbI.clouddn.com/6184zD9Mp4SvaS1srJVGcXN4H2HqDj9QXa23l43H.jpg" alt=""></p>
<p>可以看到启动了redis,但是这里直接输出到当前控制台了,可以通过参数配置使其后台运行.<br><strong>docker run参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</div><div class="line">-d: 后台运行容器，并返回容器ID；</div><div class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</div><div class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</div><div class="line">--name=&quot;nginx-lb&quot;: 为容器指定一个名称；</div><div class="line">--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</div><div class="line">--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</div><div class="line">-h &quot;mars&quot;: 指定容器的hostname；</div><div class="line">-e username=&quot;ritchie&quot;: 设置环境变量；</div><div class="line">--env-file=[]: 从指定文件读入环境变量；</div><div class="line">--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；</div><div class="line">-m :设置容器使用内存最大值；</div><div class="line">--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/Container: 四种类型；</div><div class="line">--link=[]: 添加链接到另一个容器；</div><div class="line">--expose=[]: 开放一个端口或一组端口；</div><div class="line">-p 指定容器端口映射,该参数可以使得容器端口和主机端口相互映射</div></pre></td></tr></table></figure></p>
<p>首先使用-d -p参数,可以看到redis跑在了后台.<br><img src="http://ac-HSNl7zbI.clouddn.com/spT76EzPOxiqmpHHvUfft1bCHwQPkeqVIjJAGtCt.jpg" alt=""></p>
<p><strong>外部连接:</strong><br>使用<code>docker port 容器id</code>查看映射出来的端口,该端口为<strong>docker主机</strong>的哈,所以要通过docker主机ip:端口才可以访问.<br>比如我的docker主机ip为:192.168.99.100(使用<code>docker-machine env查看</code>),docker分配映射端口为32768,那么访问就是192.168.99.100:32768,如果想用主机地址访问的话,就需要-p参数加上主机端口映射了</p>
<p><strong>进入容器</strong><br>使用<code>docker exec</code>命令可以进入容器内部,参数和run的参数作用相同.</p>
<p><img src="http://ac-HSNl7zbI.clouddn.com/fUQQvk3ApsvI4UbNYxO6C7tHu7d31M6v04aEhWmX.jpg" alt=""></p>
<p>其他命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker stop 停止一个容器</div><div class="line">docker rm 删除一个容器</div><div class="line">docker import 导入一个容器</div><div class="line">docker export 导出一个容器</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker学习记录-一-基本概念&quot;&gt;&lt;a href=&quot;#Docker学习记录-一-基本概念&quot; class=&quot;headerlink&quot; title=&quot;Docker学习记录(一)-基本概念&quot;&gt;&lt;/a&gt;Docker学习记录(一)-基本概念&lt;/h1&gt;&lt;p&gt;标签（空格分隔）
    
    </summary>
    
      <category term="docker" scheme="http://mrdear.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="http://mrdear.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计周记(一)</title>
    <link href="http://mrdear.cn/2017/03/10/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://mrdear.cn/2017/03/10/毕业设计/毕业设计周记(一)/</id>
    <published>2017-03-10T01:50:00.000Z</published>
    <updated>2017-03-11T02:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周算是正式开始做毕业设计,之前虽然一直在做,但是处于刚学习阶段,各方面做的都不是很好,因此自己也把第一版删除了,目前重构第二版.现在不止把这个当成毕业设计,而是想把他当成一个平台.用于自己学习到的技能在上面施展,因此很多没必要使用的东西都用上了.</p>
<p>关于判题内核,这个是一个难点.目前采取开源的方案,C++判题,使用JNI调用方式,(第一版是开源的windows判题内核,问题多多)WEB端和Judge端使用gRPC通信.目前卡在的难点<strong>判题内核是在linux下运行,但是自己用的是MAC,所以想采用Docker方案,这样的话还顺便更进一步解决了Judge的安全性问题</strong>,因此在学习Docker的知识.</p>
<p>因此目前进度:</p>
<ol>
<li>WEB端基本完成</li>
<li>Judge端完成</li>
</ol>
<p>等待完成:</p>
<ol>
<li>Judge移植到Docker中</li>
<li>打通WEB端和Judge端的通信,也就是实现判题.</li>
</ol>
<p>源码地址:</p>
<p><a href="https://github.com/nl101531/AUSTOJ2" target="_blank" rel="external">https://github.com/nl101531/AUSTOJ2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周算是正式开始做毕业设计,之前虽然一直在做,但是处于刚学习阶段,各方面做的都不是很好,因此自己也把第一版删除了,目前重构第二版.现在不止把这个当成毕业设计,而是想把他当成一个平台.用于自己学习到的技能在上面施展,因此很多没必要使用的东西都用上了.&lt;/p&gt;
&lt;p&gt;关于判题内
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="毕业设计" scheme="http://mrdear.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://mrdear.cn/2017/03/09/hello-world/"/>
    <id>http://mrdear.cn/2017/03/09/hello-world/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-03-11T01:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="随谈" scheme="http://mrdear.cn/tags/%E9%9A%8F%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>工作经验</title>
    <link href="http://mrdear.cn/2017/02/28/%E9%9A%8F%E8%B0%88/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
    <id>http://mrdear.cn/2017/02/28/随谈/工作经验(持续更新)/</id>
    <published>2017-02-28T01:50:00.000Z</published>
    <updated>2017-03-11T02:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己工作中的一点小经验,有不足的地方请指正.</p>
<p>1.调第三方的的服务的时候切记不能直接调用,为了扩展性要使用自己定义封装.<br>例子:我要使用支付宝的sdk调用支付宝的支付,那么为了让支付宝的SDK不侵染业务代码,那么就应该在上层再封装一层,保证自己业务的代码中不出现其他的方的代码.</p>
<p>2.服务封装要尽可能确保只为一个层服务,尽量减少跨层级调用,比如controller层就应该避免调用dao层,而是调用service层.</p>
<p>3.某一个方法无关状态,且复用性高的话最好写成静态类调用方式.语义清晰,调用方便.</p>
<p>4.接手某一个业务时,最好先画出该业务的流程图,设计出大概的代码结构后再去写代码,这样虽然前期成本高,但是综合来看的话最节省时间和精力.</p>
<p>5.<strong>业务性的代码</strong>怎么安全怎么写,在安全的基础上适当保证代码简洁.比如simpleDateFormat是线程不安全的,最简单的做法就是在需要的时候new一个,在业务性的代码中不要使用ThreadLocal这些东西进行优化,这样会增加CR成本.</p>
<p>6.对于工作中出现的一些在他人帮助下解决的问题,自己要想办法复现,然后尝试自己独立解决.</p>
<p>7.updateXXX 不应该出现在 XXXService 里,因为不同的业务流程不同导致update的原因可能很多,这样就带来了无谓的复杂度,该操作应该放在DAO层,Service 层的功能是做某个逻辑，而不是做某个数据操作。职责不一样的.所谓的Service层复用指的是业务操作复用,而不是简单的代码复用.</p>
<p>8.对于和第三方服务商服务交互的报文信息尽可能的全部打出来,避免以后因为某业务撕逼.这很重要!</p>
<p>9.数据库经常有一些extend字段,对于这些字段对应DO提供String映射,在DTO中提供HashMap映射,因为该字段可能存出多种类型数据.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录自己工作中的一点小经验,有不足的地方请指正.&lt;/p&gt;
&lt;p&gt;1.调第三方的的服务的时候切记不能直接调用,为了扩展性要使用自己定义封装.&lt;br&gt;例子:我要使用支付宝的sdk调用支付宝的支付,那么为了让支付宝的SDK不侵染业务代码,那么就应该在上层再封装一层,保证自己业务的
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="工作" scheme="http://mrdear.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何学习一门新技术</title>
    <link href="http://mrdear.cn/2017/02/01/%E9%9A%8F%E8%B0%88/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    <id>http://mrdear.cn/2017/02/01/随谈/如何学习一门新技术/</id>
    <published>2017-02-01T02:37:00.000Z</published>
    <updated>2017-03-11T02:14:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在看他人博客的时候发现的,自己也是一直按照这样的模式去学,现在分享下整个流程.</p>
<p>图片来源: <a href="http://dreamfy.cn/2016/11/24/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%8A%80%E6%9C%AF/" target="_blank" rel="external">dreamfy</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2148449-71e36af82735d03d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="是什么-为什么会出现"><a href="#是什么-为什么会出现" class="headerlink" title="是什么?为什么会出现?"></a>是什么?为什么会出现?</h3><p>这一阶段主要是对该技术有一个整体了解,他所解决的是什么问题,他的整体结构等.</p>
<h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做?"></a>怎么做?</h3><p>最简单的是找一个上手视频,因为视频是非常直观的展示了技术的使用.先学会用是最根本的,对于没有视频的技术的话,就可以搜索XX上手教程,XX学习记录之类的关键词,很轻松就找到了相关的上手博文,这一阶段一般都是环境整合搭建,然后写一个简单的入门Demo.</p>
<p>第二个阶段,学会基本使用了就要去看官方文档,文档会让你更加详细的了解该技术的特性,开一个Demo项目把官方的一些例子都试试.</p>
<p>第三个阶段,尝试在一些复杂的项目中使用(非生产项目),使用过程中难免会遇到各种各样的问题,官方文档和搜索引擎会帮助你解决,这一过程你会对该技术掌握更加娴熟.</p>
<p>第三个阶段,去github上找一些别人的项目,主要是看他人的使用方法,模块设计,代码封装等.</p>
<p>第四个阶段,生产项目使用吧,遇到问题还是官方文档和搜索引擎.</p>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>好记性不如烂笔头,博客记录是一个很好地习惯,能把自己学的东西和他人讲清楚才叫真正的懂了这个技术.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看他人博客的时候发现的,自己也是一直按照这样的模式去学,现在分享下整个流程.&lt;/p&gt;
&lt;p&gt;图片来源: &lt;a href=&quot;http://dreamfy.cn/2016/11/24/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%95%99%E4%BD%A0%
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="学习方法" scheme="http://mrdear.cn/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面经</title>
    <link href="http://mrdear.cn/2017/01/10/%E9%9A%8F%E8%B0%88/%E9%9D%A2%E7%BB%8F/"/>
    <id>http://mrdear.cn/2017/01/10/随谈/面经/</id>
    <published>2017-01-10T01:50:00.000Z</published>
    <updated>2017-03-11T02:08:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>从2016.7来到上海后记录下自己的面试经历,希望能对其他人有所帮助,同时给自己一个提醒.</p>
<h2 id="第二次面试2017-1"><a href="#第二次面试2017-1" class="headerlink" title="第二次面试2017.1"></a>第二次面试2017.1</h2><p>上一家公司干了六个月,做的还不错,中间涨了一次工资,也就500左右,但是公司没技术氛围,而且加班是家常便饭,所以为了自己打算离开了,这里我是提前和领导说不打算续签的,自己离职不太好意思拿年终奖再离职,不过领导知道后还是给我申请了年终奖,感动Ing</p>
<p>第二次面试先电面再去公司面试的,总体感觉很不错,结果还在等…</p>
<p>###1.电面<br>首先自我介绍,这个很随意,技术人员一般都不看重这个.<br><strong>1.ArrayList的扩容机制.</strong><br>这个抓住几个点,本质是一个Object的数组,初始容量10,1.7JDK之后每次扩容是1.5倍,但是1.6的JDK版本是1.5倍+1,这个回答出来说明你研究过这个而不是直接背答案.每次add都会进行容量检查,扩容是调用一个native方法System.arrayCopy,<br><strong>2.Map的containsKey和List的contain方法效率一样吗?</strong><br>这个问题回答要表现出List基于数组在查找方面的缺点,就是最坏情况下是查找全部元素后才找到,但是Map是基于Hash链表,查找是根据hash计算出来的索引地址,找到索引后会判断上面是否有链表存在,有的话会接着查找,补充下JDK8之后的HashMap当哈希桶上的链表长度大于8则会转换为一颗红黑树,因此随着碰撞增加仍然会提供稳定的性能.<br><strong>3.自己的项目问题</strong><br>这个就实打实的说就好了.其中有一个项目提到了python,因此面试官问我python学的怎么样,可以来聊聊python,但是我就会基础,所以不了了之,简历上不熟的东西尽量少写.</p>
<p>###2.现场面<br>现场面就没问很多基础问题了,主要是一些突发的问题,问了不少Linux的知识,自己又不是太熟,所以处于被虐状态…<br><strong>1.Linux的top命令</strong><br>不会,我说因为公司有运维,用服务器也就查看日志什么,自己不是很了解.<br>面试官说了一句话,说我们这是工程师和运维不分家的,一个好的工程师必然要了解代码是怎么运行的,也就需要对代码运行环境有很深的了解,这样才能写出优秀的代码,大概意思是这样的,感觉很有道理,自己Linux的服务器知识欠缺很多.<br><strong>2.Linux下怎么查看日志</strong><br>因为上面提到了自己用服务器查看日志,所以就直接被问了,博主说一般用cat命令配合grep来查看,或者使用VIM来查看,用tail -f查看实时日志,head查看开始日志等,然后被问了假设<strong>日志是10G大小,怎么快速找到自己想要的东西</strong>?这个问题想了一会,直接说不会….尴尬,后来提示用less命令,该命令不会全部加载文件.参考博文:<a href="http://www.cnblogs.com/aijianshi/p/5750911.html" target="_blank" rel="external">Linux下的more和less的使用</a><br><strong>3.爬取新浪微博用户,怎么判断该用户是否已经爬过</strong><br>博主说了数据量小的话使用Map集合或者Set集合,数据量多的话,就把某一个唯一字段设置为数据库主键,爬取的用户插入到数据库,去重交给数据库来做就好了.<br>接着面试官问如果不使用数据库呢?<br>博主想了想,就随口说爬取一部分用户后写入到文件,然后生成MD5摘要,这样每次写入文件后判断该摘要是否已存在,存在就不写入,牺牲时间,保证最终的结果重复性最低.现在想来还是有问题,爬取是随机的,所以导致生成摘要碰撞几率太低.可能多一个字符少一个字符就导致摘要不同.没想到好办法…<br><strong>4.在做项目中有没有什么取巧的经历?</strong><br>一时间还真想不到…就没答上来.<br><strong>5.在项目中遇到的难点</strong><br>博主说了自己写的集成微信,支付宝,银联,预付费卡的一个支付模块,主要讲了遇到问题怎么解决的,然后怎么封装的.<br><strong>6.关于代码洁癖举个例子</strong><br>博主简历上写自己有代码洁癖,所以就被问了这个,我举了前公司,也就第一家面试的,使用JPA的多表查询时候返回一个Objec[]数组,导致代码没法维护,并且重复代码太多,自己使用queryDSL,对公司代码进行了大面积的修改.</p>
<p>本以为要挂了,最后说技术面过了,不知道是安慰我还是什么,接着是HR面,聊了聊公司现状,待遇问题等,最后也没说过还是不过等通知.因为现在时间点比较尴尬,我提出年后入职,也不知道可不可以….<strong>等消息中</strong><br>更新:<br>已收到offer,年后入职,这家公司效率真不错,接下来希望自己有所提高!</p>
<hr>
<h2 id="第一次面试2016-7"><a href="#第一次面试2016-7" class="headerlink" title="第一次面试2016.7"></a>第一次面试2016.7</h2><p>首先简历很重要,程序员不需要太花哨的简历,尽可能的展现出自己的特点就可以了,推荐下面简历,很不错的一个模板.<br><a href="https://github.com/penglongli/My-Resume" target="_blank" rel="external">https://github.com/penglongli/My-Resume</a></p>
<p>第一次面试没有多紧张,可能对方是小公司吧,感觉很随意,面试就问了三个问题.<br><strong>1.谈一谈Java集合</strong><br>这种问题一般都很宽泛,博主就从List讲到Set再到Map这样的顺序来讲的,重点描述Arraylist,LinkedList,HashMap,TreeMap,最后再总结下什么样的场景用什么,算是回答好了.<br><strong>2.谈谈对Spring的理解.</strong><br>博主当时心里我哩个擦,又是这种宽泛的问题.但是还是微笑着回答Spring的核心是Ioc和AOP,其中Ioc是基于反射实现的,AOP是动态代理实现的,然后讲了从读取xml配置文件,实例化Spring容器,然后实例化Bean(这个过程挺复杂的,一会附上一张图),最后销毁Bean这一过程,结束.具体可以参考:<a href="http://blog.csdn.net/u013256816/article/details/51386182" target="_blank" rel="external">Spring知识点提炼</a><br><strong>3.自己项目中的问题.</strong><br>自己在学校接到过一个微信公众号的开发,问了怎么实现的,遇到的问题之类的.这种问题回答要表现出<strong>自己不是很了解的情况下是如何快速解决一个问题的能力</strong></p>
<p>拿到offer,博主是比较安逸的人,薪资还不错就不继续再找工作了,其实应该多投几家的,才能选择最适合自己的.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2016.7来到上海后记录下自己的面试经历,希望能对其他人有所帮助,同时给自己一个提醒.&lt;/p&gt;
&lt;h2 id=&quot;第二次面试2017-1&quot;&gt;&lt;a href=&quot;#第二次面试2017-1&quot; class=&quot;headerlink&quot; title=&quot;第二次面试2017.1&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="随谈" scheme="http://mrdear.cn/categories/%E9%9A%8F%E8%B0%88/"/>
    
    
      <category term="面试" scheme="http://mrdear.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
