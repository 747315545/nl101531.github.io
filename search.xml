<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[动漫推荐]]></title>
      <url>%2F2017%2F03%2F18%2F%E5%8A%A8%E6%BC%AB%2F%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[动漫推荐标签（空格分隔）： 动漫 从小就是个动漫爱好者,年轻时追番,现在老了追不动了,只追动漫电影和一些经典动漫剧场版.我也不知道自己是什么风格的动漫迷,只是觉得好看,有共鸣就认为是好作品.人们总是把自己喜爱的东西推荐给别人,我也不例外,下面推荐我认为很不错的片子.(排名不分先后) 异邦人 无皇刃谭2017年初来在上海实习时看的,故事很温情,对于刚到一个陌生城市打拼的青年来说很容易引起共鸣,也因此我感触颇深,异邦人都是孤独的存在,内心是挣扎的,想要找到自己的归属,然而哪里才是归属?背景音乐很赞,听起来内心有点温暖,但是又会觉得很伤感,充满了无奈 秒速五厘米大概高一的时候第一次看了这个作品,唯美的画面,伤感的故事,再加上年少懵懂的恋爱经历,从此新海诚一生粉.回想以前是不是很多事情都可以 One more time,One more chance]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker学习记录(三)-构建非跨平台项目编译环境]]></title>
      <url>%2F2017%2F03%2F12%2Fdocker%2FDocker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%89)-%E6%9E%84%E5%BB%BA%E9%9D%9E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[Docker学习记录(三)-构建非跨平台项目编译环境标签（空格分隔）： docker 因为毕业设计的问题所以去学了docker,本文描述这个问题解决的过程. 1.问题在毕业设计AUSTOJ中,判题端使用JNI方式调用C++来编译和执行代码,得到输出结果,Java端进行结果对比.然而该C++代码在mac下无法编译,总是会报错,JNI也会出问题.另外该子模块在mac下无法使用maven打包,所以打包也需要放在docker中.因此docker需要环境 java maven gcc g++ make 2.构建编译环境编写dockerfile文件,该文件的maven包我是从本机复制进去的,同样你也可以从外网下载.Dockerfile:123456789101112131415161718192021#构建judger端需要的环境,方便本地测试#基于java8环境FROM java:8#维护人信息MAINTAINER quding niudear@foxmail.com#更新源RUN apt-get update#gcc g++ make安装RUN apt-get install -y gcc-4.9RUN apt-get install -y g++-4.9RUN apt-get install -y build-essential#配置mvn环境ADD apache-maven-3.3.9.tar.gz /usr/localENV M2_HOME /usr/local/apache-maven-3.3.9ENV PATH $PATH:$JAVA_HOME/bin:$M2_HOME/bin#jni环境RUN cp $JAVA_HOME/include/linux/jawt_md.h $JAVA_HOME/include/RUN cp $JAVA_HOME/include/linux/jni_md.h $JAVA_HOME/include/ 构建命令:docker build -t dev . 3.挂载运行运行时需要挂载本项目到docker中,该挂载是映射,因此本地和docker任意位置改变项目中文件都会反映在真实项目中,这也是想要的结果.挂载命令:12docker run -ti -p 50013:50013 -v /Users/niuli/workspace/git/AUSTOJ2/:/AUSTOJ2 -v /Users/niuli/workspace/git/testcase/:/austoj/testcase dev 该命令以交互模式启动一个docker容器,同时绑定docker的50013端口到此容器的50013,因为我的项目使用的是50013端口.另外我挂载了本项目目录AUSTOJ2和测试数据目录分别到docker的/AUSTOJ2目录和/austoj/testcase目录. 那么启动之后如下所示: ok,到此编译环境搞定,可以随心所欲的编译启动该子模块,并且还能实时反映到本机目录下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker学习记录(二)-Dockerfile创建镜像]]></title>
      <url>%2F2017%2F03%2F10%2Fdocker%2FDocker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)-Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%2F</url>
      <content type="text"><![CDATA[Docker学习记录(二)-Dockerfile创建镜像标签（空格分隔）： docker 本文学习Dcokerfile的基本命令,并且创建一个支持ssh服务的镜像. 1.Dockerfile1.1基本案例dockerfile可以说是docker的描述符,该文件定义了docker镜像的所能拥有哪些东西.基本格式如下:123456789101112第一行指定该镜像基于的基础镜像(必须)FROM java:8维护者信息MAINTAINER quding niudear@foxmail.com镜像操作指令RUN echo $JAVA_HOME启动时操作的命令CMD ./usr/sbin/nginx 该文件说明从Java8这个基础镜像创建一个新的镜像,输出Java路径,启动成功则启动nginx服务,这也是一个Dockerfile需要包含的操作步骤. 1.2指令详解1.FROM：格式为 FROM &lt;image&gt;或FROM&lt;image&gt;:&lt;tag&gt;第一条指令必须是FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。 2.MAINTAINER：格式为MAINTAIER，指定维护者信息。 3.RUN：格式为RUN &lt;command&gt;或者RUN [“executable”，“param1”，“param2”]。前者将在shell终端中运行的命令，即/bin/sh–c；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现，例如RUN[“/bin/bash”，“-c”，“echohello”]。每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\来换行。这实际上就是在容器构建时需要执行哪些指令，例如容器构建时需要下拉代码，但是默认启动的容器中是没有Git指令的，就需要下载，可以执行：RUN apt-get install -y git，然后RUN git clonexxxx 4.CMD：指定容器启动后执行的命令，一般都是早就写好的脚本，例如：CMD[“/run.sh”]。注意：如果Dockerfile中指定了多条命令，只有最后一条会被执行。如果用户启动时候加了运行的命令，则会覆盖掉CMD指定的指令。 5.EXPOSE：告诉Docker服务端容器需要暴露的端口号，供互联系统使用。在启动容器时需要通过-P（注意是大写），Docker主机会自动分配一个端口转发到指定的端口；使用-p，则可以具体指定哪个本地端口映射过来。例如：我在elasticsearch镜像的Dockerfile中指定了暴露出9200和9300端口，我可以在Dockerfile中写：EXPOSE 9200 9300 6.ENV：创建的时候给容器中加上个需要的环境变量。指定一个值，为后续的RUN指令服务 7.COPY：复制本地的文件或目录到容器中。目标路径不存在时，会自动创建。 8.ENTRYPOINT：配置容器启动后执行的命令，并且不可被docker run 提供的参数覆盖。每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效 9.VOLUME：创建一个挂在点，可以从本机或其他容器挂载的挂载点。意思就是从容器中暴露出一部分，和外界共享这块东西，一般放数据库的数据或者是代码。在容器启动运行的时候，如果需要将volume暴露的东西和本地的一个文件夹进行映射，想要通过本地文件直接访问容器中暴露的部分，可以在运行的时候进行映射： 10.USER：指定运行容器时的用户名或者UID，后续的RUN也会使用指定的用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。要临时获取管理员权限的时候要使用gosu，不推荐使用sudo。如果不指定，容器默认是root运行。 11.WORKDIR：定义工作目录，如果容器中没有此目录，会自动创建 创建指令docker build 路径,该命令会读取路径下的Dockerfile文件和其他文件,然后发送给服务端,由服务端创建镜像. 2.创建SSH服务镜像2.1准备Java8环境后续教程需要利用到Java8环境,因此先下载一个官方的Java8镜像作为基础镜像.直接执行如下命令.可以利用之前的教程,启动容器查看下java路径.1docker pull java:8 2.2编写Dockerfilessh服务主要是openssh-server来提供,因此需要在容器中安装该服务.Dockerfile:1234567891011121314151617181920212223242526272829#显示该镜像是基于java8镜像FROM java:8#维护人信息MAINTAINER quding niudear@foxmail.com#更新源RUN apt-get update#安装软件RUN apt-get install -y openssh-serverRUN mkdir -p /var/run/sshdRUN mkdir -p /root/.ssh#取消pam限制RUN sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&apos; /etc/pam.d/sshd#复制配置文件到相应位置COPY authorized_keys /root/.ssh/authorized_keysCOPY run.sh /run.sh#赋予脚本权限RUN chmod 755 /run.sh#开放端口EXPOSE 22#设置启动命令CMD [&quot;/run.sh&quot;] run.sh12#!/bin/bash/usr/sbin/sshd -D 拷贝本机的id_ras12cat ~/.ssh/id_rsa.pub &gt;authorized_keys//用来免密的 执行构建1docker build -t sshd:java . 构建成功后使用docker images即可查看,然后像上篇一样启动容器,暴露出端口,再使用ssh连接,和一般linux系统就没什么差别了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker学习记录(一)-基本概念]]></title>
      <url>%2F2017%2F03%2F10%2Fdocker%2FDocker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[Docker学习记录(一)-基本概念标签（空格分隔）： docker 因为做的项目用到了docker,所以开始学习下这方面的知识. 1.基本概念docker虚拟机:docker环境,docker的操作都要依赖此虚拟机,可以理解为JDK.docker镜像:镜像可以用面向对象中的Model类来理解,就是一个已经建立好的模型.docker容器:容器可以关联面向对象中的实例来理解,实例是依赖类来创建,所以容器就是依赖镜像创建,同样一个类可以有多个实例,那么一个镜像也可以对应多个容器.docker仓库:仓库是镜像市场,里面有别人建立好的Model类,也就是镜像,可以直接拿来使用. 这样说应该很好理解了吧. 因此创建一个helloworld的流程就和清晰了.启动docker虚拟机-&gt;创建docker镜像(或者从仓库拉取)-&gt;创建docker容器(运行helloworld)-&gt;结束 2.docker虚拟机首先docker安装后自带的虚拟机配置下载镜像又要GFW的原因速度很慢,一般使用阿里云加速器,登陆后找到加速器按照要求先创建一个新的docker主机,然后启动该主机.这里要注意,阿里云给的命令是创建一个名字为default的主机,安装后自带了一个default,所以先运行docker-machine rm default删除默认主机. 2.1新建主机 2.2为当前shell配置环境 2.3验证 到此docker虚拟机创建完毕,这里需要掌握一些基本增删改查基本命令.123456789101112docker-machine kill 停止某个Docker主机docker-machine ls 列出所有管理的Docker主机docker-machine regenerate-certs 为某个主机重新成功TLS认证信息docker-machine restart 重启Docker主机docker-machine rm 删除Docker主机docker-machine scp 在Docker主机之间复制文件docker-machine ssh SSH到主机上执行命令docker-machine start 启动一个主机docker-machine status 查看一个主机状态docker-machine stop 停止一个主机docker-machine upgrade 更新主机Docker版本为最新docker-machine url 获取主机的URL 3.docker镜像使用docker images可以列出机器上所有的docker镜像. 其中:REPOSTITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小 使用docker search 镜像名查找某一镜像,例如查找hello world,可以看到带有OFFICIAL的为官方提供的镜像. 使用docker pull 镜像名获取一个镜像,这里获取hello world,另外镜像后可以跟版本号,例如docker pull redis:3.2,就指定拉去redis3.2版本 使用docker run 镜像名从该镜像启动一个实例. 常见命令,另外对于docker镜像的创建和运行比较重要,后续文章单独学习分析.123456docker inspect 查看镜像详情docker rmi 删除镜像,带上-f参数则强制删除docker save 导出镜像docker load 导入镜像docker push 上传镜像到仓库docker tag 给镜像设置标签 4.docker容器容器是应用的实例,使用docker create创建一个容器,使用docker start启动一个容器,另一个简单方式就是docker run,等价于先创建再启动. 那么使用docker run的时候后台做了哪些操作? 查找是否存在指定镜像,不存在则从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统,在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接到容器中去 从地址池配置一个ip地址给容器 执行用户指定应用程序 执行完毕后容器被终止 使用docker ps -a查看最近启动的容器 使用docker rm删除容器,清理完毕后再删除hello world镜像. 下面使用redis镜像实战整个流程,并学习容器常用命令. 5.创建redis镜像有了helloworld经历,这里流程就很清晰了,搜索镜像-&gt;拉去镜像-&gt;创建实例-&gt;连接交互 可以看到启动了redis,但是这里直接输出到当前控制台了,可以通过参数配置使其后台运行.docker run参数12345678910111213141516-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；-d: 后台运行容器，并返回容器ID；-i: 以交互模式运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；--name=&quot;nginx-lb&quot;: 为容器指定一个名称；--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；-h &quot;mars&quot;: 指定容器的hostname；-e username=&quot;ritchie&quot;: 设置环境变量；--env-file=[]: 从指定文件读入环境变量；--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；-m :设置容器使用内存最大值；--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/Container: 四种类型；--link=[]: 添加链接到另一个容器；--expose=[]: 开放一个端口或一组端口；-p 指定容器端口映射 首先使用-d -p参数,可以看到redis跑在了后台. 外部连接:使用docker port 容器id查看映射出来的端口,该端口为docker主机的哈,所以要通过docker主机ip:端口才可以访问.比如我的docker主机ip为:192.168.99.100(使用docker-machine env查看),docker分配映射端口为32768,那么访问就是192.168.99.100:32768 进入容器使用docker exec命令可以进入容器内部,参数和run的参数作用相同. 其他命令1234docker stop 停止一个容器docker rm 删除一个容器docker import 导入一个容器docker export 导出一个容器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[毕业设计周记(一)]]></title>
      <url>%2F2017%2F03%2F10%2F%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%2F%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%91%A8%E8%AE%B0(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[本周算是正式开始做毕业设计,之前虽然一直在做,但是处于刚学习阶段,各方面做的都不是很好,因此自己也把第一版删除了,目前重构第二版.现在不止把这个当成毕业设计,而是想把他当成一个平台.用于自己学习到的技能在上面施展,因此很多没必要使用的东西都用上了. 关于判题内核,这个是一个难点.目前采取开源的方案,C++判题,使用JNI调用方式,(第一版是开源的windows判题内核,问题多多)WEB端和Judge端使用gRPC通信.目前卡在的难点判题内核是在linux下运行,但是自己用的是MAC,所以想采用Docker方案,这样的话还顺便更进一步解决了Judge的安全性问题,因此在学习Docker的知识. 因此目前进度: WEB端基本完成 Judge端完成 等待完成: Judge移植到Docker中 打通WEB端和Judge端的通信,也就是实现判题. 源码地址: https://github.com/nl101531/AUSTOJ2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作经验]]></title>
      <url>%2F2017%2F02%2F28%2F%E9%9A%8F%E8%B0%88%2F%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)%2F</url>
      <content type="text"><![CDATA[记录自己工作中的一点小经验,有不足的地方请指正. 1.调第三方的的服务的时候切记不能直接调用,为了扩展性要使用自己定义封装.例子:我要使用支付宝的sdk调用支付宝的支付,那么为了让支付宝的SDK不侵染业务代码,那么就应该在上层再封装一层,保证自己业务的代码中不出现其他的方的代码. 2.服务封装要尽可能确保只为一个层服务,尽量减少跨层级调用,比如controller层就应该避免调用dao层,而是调用service层. 3.某一个方法无关状态,且复用性高的话最好写成静态类调用方式.语义清晰,调用方便. 4.接手某一个业务时,最好先画出该业务的流程图,设计出大概的代码结构后再去写代码,这样虽然前期成本高,但是综合来看的话最节省时间和精力. 5.业务性的代码怎么安全怎么写,在安全的基础上适当保证代码简洁.比如simpleDateFormat是线程不安全的,最简单的做法就是在需要的时候new一个,在业务性的代码中不要使用ThreadLocal这些东西进行优化,这样会增加CR成本. 6.对于工作中出现的一些在他人帮助下解决的问题,自己要想办法复现,然后尝试自己独立解决. 7.updateXXX 不应该出现在 XXXService 里,因为不同的业务流程不同导致update的原因可能很多,这样就带来了无谓的复杂度,该操作应该放在DAO层,Service 层的功能是做某个逻辑，而不是做某个数据操作。职责不一样的.所谓的Service层复用指的是业务操作复用,而不是简单的代码复用. 8.对于和第三方服务商服务交互的报文信息尽可能的全部打出来,避免以后因为某业务撕逼.这很重要! 9.数据库经常有一些extend字段,对于这些字段对应DO提供String映射,在DTO中提供HashMap映射,因为该字段可能存出多种类型数据.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何学习一门新技术]]></title>
      <url>%2F2017%2F02%2F01%2F%E9%9A%8F%E8%B0%88%2F%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[在看他人博客的时候发现的,自己也是一直按照这样的模式去学,现在分享下整个流程. 图片来源: dreamfy 是什么?为什么会出现?这一阶段主要是对该技术有一个整体了解,他所解决的是什么问题,他的整体结构等. 怎么做?最简单的是找一个上手视频,因为视频是非常直观的展示了技术的使用.先学会用是最根本的,对于没有视频的技术的话,就可以搜索XX上手教程,XX学习记录之类的关键词,很轻松就找到了相关的上手博文,这一阶段一般都是环境整合搭建,然后写一个简单的入门Demo. 第二个阶段,学会基本使用了就要去看官方文档,文档会让你更加详细的了解该技术的特性,开一个Demo项目把官方的一些例子都试试. 第三个阶段,尝试在一些复杂的项目中使用(非生产项目),使用过程中难免会遇到各种各样的问题,官方文档和搜索引擎会帮助你解决,这一过程你会对该技术掌握更加娴熟. 第三个阶段,去github上找一些别人的项目,主要是看他人的使用方法,模块设计,代码封装等. 第四个阶段,生产项目使用吧,遇到问题还是官方文档和搜索引擎. 分享好记性不如烂笔头,博客记录是一个很好地习惯,能把自己学的东西和他人讲清楚才叫真正的懂了这个技术.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面经]]></title>
      <url>%2F2017%2F01%2F10%2F%E9%9A%8F%E8%B0%88%2F%E9%9D%A2%E7%BB%8F%2F</url>
      <content type="text"><![CDATA[从2016.7来到上海后记录下自己的面试经历,希望能对其他人有所帮助,同时给自己一个提醒. 第二次面试2017.1上一家公司干了六个月,做的还不错,中间涨了一次工资,也就500左右,但是公司没技术氛围,而且加班是家常便饭,所以为了自己打算离开了,这里我是提前和领导说不打算续签的,自己离职不太好意思拿年终奖再离职,不过领导知道后还是给我申请了年终奖,感动Ing 第二次面试先电面再去公司面试的,总体感觉很不错,结果还在等… ###1.电面首先自我介绍,这个很随意,技术人员一般都不看重这个.1.ArrayList的扩容机制.这个抓住几个点,本质是一个Object的数组,初始容量10,1.7JDK之后每次扩容是1.5倍,但是1.6的JDK版本是1.5倍+1,这个回答出来说明你研究过这个而不是直接背答案.每次add都会进行容量检查,扩容是调用一个native方法System.arrayCopy,2.Map的containsKey和List的contain方法效率一样吗?这个问题回答要表现出List基于数组在查找方面的缺点,就是最坏情况下是查找全部元素后才找到,但是Map是基于Hash链表,查找是根据hash计算出来的索引地址,找到索引后会判断上面是否有链表存在,有的话会接着查找,补充下JDK8之后的HashMap当哈希桶上的链表长度大于8则会转换为一颗红黑树,因此随着碰撞增加仍然会提供稳定的性能.3.自己的项目问题这个就实打实的说就好了.其中有一个项目提到了python,因此面试官问我python学的怎么样,可以来聊聊python,但是我就会基础,所以不了了之,简历上不熟的东西尽量少写. ###2.现场面现场面就没问很多基础问题了,主要是一些突发的问题,问了不少Linux的知识,自己又不是太熟,所以处于被虐状态…1.Linux的top命令不会,我说因为公司有运维,用服务器也就查看日志什么,自己不是很了解.面试官说了一句话,说我们这是工程师和运维不分家的,一个好的工程师必然要了解代码是怎么运行的,也就需要对代码运行环境有很深的了解,这样才能写出优秀的代码,大概意思是这样的,感觉很有道理,自己Linux的服务器知识欠缺很多.2.Linux下怎么查看日志因为上面提到了自己用服务器查看日志,所以就直接被问了,博主说一般用cat命令配合grep来查看,或者使用VIM来查看,用tail -f查看实时日志,head查看开始日志等,然后被问了假设日志是10G大小,怎么快速找到自己想要的东西?这个问题想了一会,直接说不会….尴尬,后来提示用less命令,该命令不会全部加载文件.参考博文:Linux下的more和less的使用3.爬取新浪微博用户,怎么判断该用户是否已经爬过博主说了数据量小的话使用Map集合或者Set集合,数据量多的话,就把某一个唯一字段设置为数据库主键,爬取的用户插入到数据库,去重交给数据库来做就好了.接着面试官问如果不使用数据库呢?博主想了想,就随口说爬取一部分用户后写入到文件,然后生成MD5摘要,这样每次写入文件后判断该摘要是否已存在,存在就不写入,牺牲时间,保证最终的结果重复性最低.现在想来还是有问题,爬取是随机的,所以导致生成摘要碰撞几率太低.可能多一个字符少一个字符就导致摘要不同.没想到好办法…4.在做项目中有没有什么取巧的经历?一时间还真想不到…就没答上来.5.在项目中遇到的难点博主说了自己写的集成微信,支付宝,银联,预付费卡的一个支付模块,主要讲了遇到问题怎么解决的,然后怎么封装的.6.关于代码洁癖举个例子博主简历上写自己有代码洁癖,所以就被问了这个,我举了前公司,也就第一家面试的,使用JPA的多表查询时候返回一个Objec[]数组,导致代码没法维护,并且重复代码太多,自己使用queryDSL,对公司代码进行了大面积的修改. 本以为要挂了,最后说技术面过了,不知道是安慰我还是什么,接着是HR面,聊了聊公司现状,待遇问题等,最后也没说过还是不过等通知.因为现在时间点比较尴尬,我提出年后入职,也不知道可不可以….等消息中更新:已收到offer,年后入职,这家公司效率真不错,接下来希望自己有所提高! 第一次面试2016.7首先简历很重要,程序员不需要太花哨的简历,尽可能的展现出自己的特点就可以了,推荐下面简历,很不错的一个模板.https://github.com/penglongli/My-Resume 第一次面试没有多紧张,可能对方是小公司吧,感觉很随意,面试就问了三个问题.1.谈一谈Java集合这种问题一般都很宽泛,博主就从List讲到Set再到Map这样的顺序来讲的,重点描述Arraylist,LinkedList,HashMap,TreeMap,最后再总结下什么样的场景用什么,算是回答好了.2.谈谈对Spring的理解.博主当时心里我哩个擦,又是这种宽泛的问题.但是还是微笑着回答Spring的核心是Ioc和AOP,其中Ioc是基于反射实现的,AOP是动态代理实现的,然后讲了从读取xml配置文件,实例化Spring容器,然后实例化Bean(这个过程挺复杂的,一会附上一张图),最后销毁Bean这一过程,结束.具体可以参考:Spring知识点提炼3.自己项目中的问题.自己在学校接到过一个微信公众号的开发,问了怎么实现的,遇到的问题之类的.这种问题回答要表现出自己不是很了解的情况下是如何快速解决一个问题的能力 拿到offer,博主是比较安逸的人,薪资还不错就不继续再找工作了,其实应该多投几家的,才能选择最适合自己的.]]></content>
    </entry>

    
  
  
</search>
